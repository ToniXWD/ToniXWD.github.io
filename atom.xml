<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ToniBlog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-10-11T13:47:21.703Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>ToniXWD</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Scoop--windows下的软件包管理工具</title>
    <link href="http://example.com/2024/10/11/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%AC%94%E8%AE%B0/scoop--windows%E4%B8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://example.com/2024/10/11/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%AC%94%E8%AE%B0/scoop--windows%E4%B8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</id>
    <published>2024-10-11T12:13:56.000Z</published>
    <updated>2024-10-11T13:47:21.703Z</updated>
    
    <content type="html"><![CDATA[<p>今天介绍一个非常好用的 <code>windows</code>平台下的软件包管理工具<code>scoop</code>, 简单来说, 它就是<code>windows</code>平台上的<code>apt\yam</code>, 如果日常使用<code>Linux</code>进行开发且熟悉<code>Linux</code>的命令, 那么<code>scoop</code>就非常适合了。完整的文档参见 <a href="https://scoop.sh/">https://scoop.sh/</a></p><h1 id="1-安装和使用"><a href="#1-安装和使用" class="headerlink" title="1 安装和使用"></a>1 安装和使用</h1><h2 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h2><p>在<code>Powershell</code>中运行下面的命令:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> <span class="literal">-ExecutionPolicy</span> RemoteSigned <span class="literal">-Scope</span> CurrentUser</span><br><span class="line"><span class="built_in">Invoke-RestMethod</span> <span class="literal">-Uri</span> https://get.scoop.sh | <span class="built_in">Invoke-Expression</span></span><br></pre></td></tr></table></figure><h2 id="1-2-常用命令"><a href="#1-2-常用命令" class="headerlink" title="1.2 常用命令"></a>1.2 常用命令</h2><h3 id="1-2-1-安装和卸载"><a href="#1-2-1-安装和卸载" class="headerlink" title="1.2.1 安装和卸载"></a>1.2.1 安装和卸载</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; scoop search grep <span class="comment"># 搜索软件包, 以grep为例</span></span><br><span class="line">Results from local buckets...</span><br><span class="line"></span><br><span class="line">Name       Version         Source Binaries</span><br><span class="line"><span class="literal">----</span>       <span class="literal">-------</span>         <span class="literal">------</span> <span class="literal">--------</span></span><br><span class="line">ast<span class="literal">-grep</span>   <span class="number">0.27</span>.<span class="number">3</span>          main</span><br><span class="line">busybox    <span class="number">5467</span><span class="literal">-g9376eebd8</span> main   egrep | fgrep | grep | pgrep</span><br><span class="line">gettext    <span class="number">0.21</span><span class="literal">-v1</span>.<span class="number">16</span>      main   msggrep.exe</span><br><span class="line">gow        <span class="number">0.8</span>.<span class="number">0</span>           main   egrep.exe | fgrep.exe | grep.exe</span><br><span class="line">grep       <span class="number">3.11</span>            main</span><br><span class="line">igrep      <span class="number">1.3</span>.<span class="number">0</span>           main</span><br><span class="line">nim        <span class="number">2.2</span>.<span class="number">0</span>           main   nimgrep.exe</span><br><span class="line">pcre2grep  <span class="number">10.39</span>           main</span><br><span class="line">pcregrep   <span class="number">8.45</span>            main</span><br><span class="line">ripgrep    <span class="number">14.1</span>.<span class="number">1</span>          main</span><br><span class="line">rktools2k3 <span class="number">1.0</span>             main   qgrep.exe</span><br><span class="line">ugrep      <span class="number">6.5</span>.<span class="number">0</span>           main</span><br><span class="line">unxutils   <span class="number">2007.03</span>.<span class="number">01</span>      main   agrep.exe | egrep.exe | fgrep.exe | grep.exe</span><br><span class="line"></span><br><span class="line">&gt; scoop search gow <span class="comment"># 安装</span></span><br><span class="line">&gt; scoop search gow <span class="comment"># 卸载</span></span><br><span class="line">&gt; scoop list <span class="comment"># 列出已安装的软件列表</span></span><br></pre></td></tr></table></figure><h3 id="1-2-2-更新和检查"><a href="#1-2-2-更新和检查" class="headerlink" title="1.2.2 更新和检查"></a>1.2.2 更新和检查</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; scoop update <span class="comment"># 更新所有已安装的软件包</span></span><br><span class="line">&gt; scoop update gow <span class="comment"># 更新具体的某个包</span></span><br><span class="line">&gt; scoop status <span class="comment"># 显示状态并检查是否有新的应用程序版本</span></span><br><span class="line">&gt; scoop checkup <span class="comment"># 检查潜在的问题</span></span><br></pre></td></tr></table></figure><h3 id="1-2-3-清理优化"><a href="#1-2-3-清理优化" class="headerlink" title="1.2.3 清理优化"></a>1.2.3 清理优化</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; scoop cleanup cmake <span class="comment"># 清理应用程序，移除旧版本</span></span><br><span class="line">&gt; scoop cache <span class="built_in">rm</span> * <span class="comment"># 清理所有缓存</span></span><br><span class="line">&gt; scoop cache <span class="built_in">rm</span> cmake <span class="comment"># 清理cmake的下载缓存</span></span><br></pre></td></tr></table></figure><h3 id="1-2-4-查看软件官方文档"><a href="#1-2-4-查看软件官方文档" class="headerlink" title="1.2.4 查看软件官方文档"></a>1.2.4 查看软件官方文档</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; scoop home gow <span class="comment"># 会打开gow的github主页</span></span><br></pre></td></tr></table></figure><h3 id="1-2-5-alias别名系统"><a href="#1-2-5-alias别名系统" class="headerlink" title="1.2.5 alias别名系统"></a>1.2.5 alias别名系统</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; scoop alias add up <span class="string">&quot;scoop update&quot;</span></span><br><span class="line">&gt; scoop up <span class="comment"># 等效于scoop update</span></span><br><span class="line">Updating Scoop...</span><br><span class="line">Updating Buckets...</span><br><span class="line">Scoop was updated successfully!</span><br><span class="line">&gt; scoop alias <span class="built_in">del</span> up <span class="comment"># 删除别名</span></span><br><span class="line">&gt; scoop alias list <span class="comment"># 查看别名列表</span></span><br></pre></td></tr></table></figure><h3 id="1-2-6-shim快捷方式"><a href="#1-2-6-shim快捷方式" class="headerlink" title="1.2.6 shim快捷方式"></a>1.2.6 shim快捷方式</h3><p><code>shim</code>创建一个指向这些可执行文件的快捷方式，并确保这些文件能够在命令行环境中无缝使用:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scoop shim add <span class="built_in">search-files</span><span class="literal">-app</span> <span class="string">&quot;C:\Users\toni\AppData\Local\search-files-app\search-files-app.exe&quot;</span></span><br><span class="line"><span class="built_in">search-files</span><span class="literal">-app</span> <span class="comment"># 此时可以打开应用程序</span></span><br><span class="line">scoop shim <span class="built_in">rm</span> <span class="built_in">search-files</span><span class="literal">-app</span> <span class="comment"># 删除这个快捷方式</span></span><br></pre></td></tr></table></figure><p>可以在文档的 <strong>bucket 部分</strong> 中补充以下命令：</p><h3 id="1-2-7-bucket-管理"><a href="#1-2-7-bucket-管理" class="headerlink" title="1.2.7 bucket 管理"></a>1.2.7 bucket 管理</h3><p><code>bucket</code> 是 Scoop 用来存储和管理软件包的仓库，你可以通过以下命令进行 bucket 的管理。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; scoop bucket add &lt;bucket_name&gt; [&lt;<span class="type">repo</span>&gt;] <span class="comment"># 添加 bucket（软件包仓库）</span></span><br><span class="line">&gt; scoop bucket add extras <span class="comment"># 添加官方的 extras bucket</span></span><br><span class="line"></span><br><span class="line">&gt; scoop bucket list <span class="comment"># 列出已添加的 bucket</span></span><br><span class="line"></span><br><span class="line">&gt; scoop bucket <span class="built_in">rm</span> &lt;bucket_name&gt; <span class="comment"># 移除已添加的 bucket</span></span><br><span class="line">&gt; scoop bucket <span class="built_in">rm</span> extras <span class="comment"># 移除 extras bucket</span></span><br><span class="line"></span><br><span class="line">&gt; scoop bucket known <span class="comment"># 查看 Scoop 已知的官方 bucket 列表</span></span><br><span class="line"></span><br><span class="line">&gt; scoop bucket update &lt;bucket_name&gt; <span class="comment"># 更新某个 bucket 的软件包信息</span></span><br><span class="line">&gt; scoop bucket update <span class="comment"># 更新所有已添加 bucket 的信息</span></span><br></pre></td></tr></table></figure><h1 id="2-核心概念"><a href="#2-核心概念" class="headerlink" title="2 核心概念"></a>2 核心概念</h1><p><code>Scoop</code> 的核心概念主要包括 <code>Apps</code>（应用程序）、<code>Buckets</code>（桶）和 <code>App Manifests</code>（应用程序清单）。这些概念共同构成了 <code>Scoop</code> 的基础架构，使得软件包管理变得更加简单和高效。下面我们分别介绍这三个概念：</p><p>当然可以！以下是将 Scoop 的核心概念整理成表格的形式，以便更清晰地展示每个概念的关键信息：</p><table><thead><tr><th><strong>概念</strong></th><th><strong>定义</strong></th><th><strong>用途</strong></th><th><strong>命令</strong></th></tr></thead><tbody><tr><td><strong>Apps (应用程序)</strong></td><td>指通过 Scoop 安装的各种软件包，可以是命令行工具、库或其他类型的应用程序。</td><td>- 安装、更新和卸载应用程序。<br>- 提供命令行工具。</td><td>- <code>scoop install &lt;package-name&gt;</code><br>- <code>scoop update &lt;package-name&gt;</code><br>- <code>scoop uninstall &lt;package-name&gt;</code></td></tr><tr><td><strong>Buckets (桶)</strong></td><td>Scoop 中用于存储和管理软件包的仓库，每个 bucket 是一个 GitHub 仓库，包含了多个应用程序的清单文件。</td><td>- 存储应用程序清单文件。<br>- 提供多种软件包来源。</td><td>- <code>scoop bucket add &lt;bucket-name&gt; &lt;bucket-url&gt;</code><br>- <code>scoop search &lt;query&gt;</code><br>- <code>scoop bucket add extras</code> 添加预定义的常见的桶</td></tr><tr><td><strong>App Manifests (应用程序清单)</strong></td><td>描述应用程序的 JSON 文件，包含基本信息（如名称、版本、下载链接、校验和等）。</td><td>- 描述应用程序的元数据。<br>- 提供安装和更新所需的详细信息。</td><td>- <code>scoop create &lt;package-name&gt;</code><br>- <code>scoop cat &lt;package-name&gt;</code></td></tr></tbody></table><blockquote><p>就个人使用体验而言, 官方的<code>bucket</code>在开个tizi的情况下速度还可以, 如果想使用国内的bucket, 请参考 <a href="https://gitee.com/RubyMetric/scoop-cn">https://gitee.com/RubyMetric/scoop-cn</a></p></blockquote><h1 id="3-常用的scoop软件包推荐"><a href="#3-常用的scoop软件包推荐" class="headerlink" title="3 常用的scoop软件包推荐"></a>3 常用的scoop软件包推荐</h1><table><thead><tr><th><strong>类别</strong></th><th><strong>软件名称</strong></th><th><strong>描述</strong></th><th><strong>力荐 &amp;&amp; 理由</strong></th></tr></thead><tbody><tr><td>核心桶(Core Bucket)</td><td>7zip</td><td>文件压缩工具</td><td></td></tr><tr><td>核心桶(Core Bucket)</td><td>sudo</td><td>允许使用<code>Linux</code>的<code>sudo</code>模式</td><td>√ 个人常用</td></tr><tr><td>核心桶(Core Bucket)</td><td>cloc</td><td>代码统计工具</td><td>√</td></tr><tr><td>核心桶(Core Bucket)</td><td>jq</td><td>json格式化和高亮工具</td><td></td></tr><tr><td>核心桶(Core Bucket)</td><td>gow</td><td>Unix下的常见命令行工具(包含<code>grep</code>, <code>xargs</code>, <code>which</code>等)</td><td>√ <code>windows</code> -&gt; <code>Unix</code></td></tr><tr><td>核心桶(Core Bucket)</td><td>cmake</td><td>c++构建工具</td><td>√ 随时升级<code>cmake</code>很方便</td></tr><tr><td>核心桶(Core Bucket)</td><td>git</td><td>…</td><td>√ 随时升级<code>git</code>很方便</td></tr><tr><td>核心桶(Core Bucket)</td><td>cmder</td><td>终端模拟器</td><td></td></tr><tr><td>核心桶(Core Bucket)</td><td>vscode</td><td>…</td><td></td></tr><tr><td>核心桶(Core Bucket)</td><td>python</td><td>…</td><td></td></tr><tr><td>核心桶(Core Bucket)</td><td>nodejs</td><td>…</td><td>√</td></tr><tr><td>核心桶(Core Bucket)</td><td>ffmpeg</td><td>多媒体处理工具</td><td>√</td></tr><tr><td>核心桶(Core Bucket)</td><td>curl</td><td>命令行工具，用于获取或发送数据</td><td></td></tr><tr><td>核心桶(Core Bucket)</td><td>wget</td><td>从网络下载文件</td><td></td></tr><tr><td>核心桶(Core Bucket)</td><td>vlc</td><td>媒体播放器</td><td></td></tr><tr><td>核心桶(Core Bucket)</td><td>discord</td><td>语音和文字聊天应用</td><td></td></tr><tr><td>扩展桶(Extras Bucket)</td><td>calibre</td><td>电子书管理工具</td><td></td></tr><tr><td>扩展桶(Extras Bucket)</td><td>draw.io</td><td>图形绘制软件</td><td></td></tr><tr><td>扩展桶(Extras Bucket)</td><td>filezilla</td><td>FTP 客户端</td><td></td></tr><tr><td>扩展桶(Extras Bucket)</td><td>gparted</td><td>分区编辑器</td><td></td></tr><tr><td>扩展桶(Extras Bucket)</td><td>inkscape</td><td>向量图形编辑器</td><td></td></tr><tr><td>扩展桶(Extras Bucket)</td><td>keepassxc</td><td>密码管理器</td><td></td></tr><tr><td>扩展桶(Extras Bucket)</td><td>notepad++</td><td>文本编辑器</td><td></td></tr><tr><td>扩展桶(Extras Bucket)</td><td>virtualbox</td><td>虚拟机软件</td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天介绍一个非常好用的 &lt;code&gt;windows&lt;/code&gt;平台下的软件包管理工具&lt;code&gt;scoop&lt;/code&gt;, 简单来说, 它就是&lt;code&gt;windows&lt;/code&gt;平台上的&lt;code&gt;apt&#92;yam&lt;/code&gt;, 如果日常使用&lt;code&gt;Linux&lt;/</summary>
      
    
    
    
    <category term="实用工具" scheme="http://example.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>.clangd配置文件简介</title>
    <link href="http://example.com/2024/10/08/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%AC%94%E8%AE%B0/clangd%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E4%BB%8B/"/>
    <id>http://example.com/2024/10/08/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%AC%94%E8%AE%B0/clangd%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E4%BB%8B/</id>
    <published>2024-10-08T07:38:37.000Z</published>
    <updated>2024-10-08T09:51:49.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1 背景介绍"></a>1 背景介绍</h1><p><code>clangd</code> 是一个基于 LLVM 的 Clang 编译器前端提供的代码补全服务工具，主要用于 C 和 C++ 的代码补全、诊断、重构等功能。它支持多种编辑器和 IDE，并且通过 Language Server Protocol (LSP) 提供服务，使得它可以很容易地集成到不同的开发环境中。</p><p>个实际开发过程中不需要了解 <code>clangd</code> 的细节, 只需要通过 <code>.clangd</code> 配置文件指导 <code>clangd</code>行为。</p><h1 id="2-配置规则介绍"><a href="#2-配置规则介绍" class="headerlink" title="2 配置规则介绍"></a>2 配置规则介绍</h1><p><code>.clangd</code> 是 Clangd 的配置文件，用于在项目中自定义 Clangd 的行为。这个文件通常位于项目的根目录下，Clangd 会在当前文件所在的所有父目录中搜索 <code>.clangd</code> 文件。</p><h2 id="2-1-配置文件层次结构"><a href="#2-1-配置文件层次结构" class="headerlink" title="2.1 配置文件层次结构"></a>2.1 配置文件层次结构</h2><p><code>.clangd</code> 文件使用 YAML 格式，可以包含以下几个主要部分：</p><ul><li><code>CompileFlags</code>: 编译标志部分</li><li><code>Diagnostics</code>: 诊断设置部分</li><li><code>InlayHints</code>: 代码提示设置部分</li><li><code>Completion</code>: 代码补全设置部分</li><li><code>SemanticTokens</code>: 语义标记设置部分</li></ul><h2 id="2-2-案例配置文件说明"><a href="#2-2-案例配置文件说明" class="headerlink" title="2.2 案例配置文件说明"></a>2.2 案例配置文件说明</h2><p>更详细的配置工作参考 <a href="https://clangd.llvm.org/config">https://clangd.llvm.org/config</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最顶层包含几个主要部分：If, CompileFlags, Diagnostics, InlayHints, Completion, 和 SemanticTokens</span></span><br><span class="line"></span><br><span class="line"><span class="attr">If:</span>                               <span class="comment"># 设置配置文件的使用条件</span></span><br><span class="line">  <span class="attr">PathMatch:</span> <span class="string">.*\.h</span>                <span class="comment"># 所有头文件都使用</span></span><br><span class="line">  <span class="attr">PathExclude:</span> <span class="string">include/llvm-c/.*</span>  <span class="comment"># 排除该路径下的所有文件</span></span><br><span class="line"></span><br><span class="line"><span class="attr">CompileFlags:</span>            <span class="comment"># 编译标志部分</span></span><br><span class="line">  <span class="attr">Add:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;-Wall&quot;</span>           <span class="comment"># 启用所有警告</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;-Wextra&quot;</span>         <span class="comment"># 启用额外警告</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;-std=c++20&quot;</span>      <span class="comment"># 使用C++20标准</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;-Iinclude&quot;</span>       <span class="comment"># 包含头文件, 相对路径</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;-isystemF:/include&quot;</span> <span class="comment"># 包含头文件, 绝对路径</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">Remove:</span> [<span class="string">&quot;-Werror&quot;</span>]   <span class="comment"># 移除将所有警告作为错误的选项</span></span><br><span class="line">  <span class="attr">Compiler:</span> <span class="string">clang++</span>     <span class="comment"># 指定编译器</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Index:</span></span><br><span class="line">  <span class="attr">Background:</span> <span class="literal">true</span>            <span class="comment"># 在后台索引项目代码</span></span><br><span class="line">  <span class="attr">BuildSystem:</span> <span class="string">&quot;CMake&quot;</span>        <span class="comment"># 指定构建系统类型</span></span><br><span class="line">  <span class="attr">IndexFile:</span> <span class="string">&quot;.clangd-index&quot;</span>  <span class="comment"># 索引文件路径</span></span><br><span class="line">  <span class="attr">ImplicitDynamic:</span> <span class="literal">true</span>       <span class="comment"># 动态索引所有头文件</span></span><br><span class="line">  <span class="attr">ResourceDir:</span> <span class="string">&quot;/path/to/resource&quot;</span>  <span class="comment"># 资源目录路径</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Diagnostics:</span>             <span class="comment"># 诊断设置部分</span></span><br><span class="line">  <span class="attr">ClangTidy:</span>             <span class="comment"># Clang-Tidy 配置</span></span><br><span class="line">    <span class="attr">Add:</span> [<span class="string">&quot;cppcoreguidelines-*&quot;</span>, <span class="string">&quot;modernize-*&quot;</span>, <span class="string">&quot;performance-*&quot;</span>] </span><br><span class="line">    <span class="comment"># 添加Clang-Tidy检查项, 其含义参见https://clang.llvm.org/extra/clang-tidy/</span></span><br><span class="line">    <span class="attr">Remove:</span> [<span class="string">&quot;clang-analyzer-*&quot;</span>] <span class="comment"># 移除Clang分析器检查项</span></span><br><span class="line">  <span class="attr">ClangTidyChecks:</span> <span class="literal">true</span>  <span class="comment"># 启用 Clang-Tidy 检查</span></span><br><span class="line">  <span class="attr">Options:</span>               <span class="comment"># Clang-Tidy 的选项设置</span></span><br><span class="line">    <span class="attr">UseChecks:</span> [<span class="string">&quot;*&quot;</span>]     <span class="comment"># 使用所有检查项</span></span><br><span class="line">    <span class="attr">HeaderFilterRegex:</span> <span class="string">&quot;.*&quot;</span> <span class="comment"># 正则表达式，用于过滤头文件</span></span><br><span class="line">    <span class="attr">WarningsAsErrors:</span> <span class="string">&quot;cppcoreguidelines-*&quot;</span> <span class="comment"># 将特定警告视为错误</span></span><br><span class="line"></span><br><span class="line"><span class="attr">InlayHints:</span>              <span class="comment"># 代码提示设置部分</span></span><br><span class="line">  <span class="attr">Enabled:</span> <span class="literal">true</span>          <span class="comment"># 启用代码提示</span></span><br><span class="line">  <span class="attr">ParameterNames:</span> <span class="literal">true</span>   <span class="comment"># 显示参数名称提示</span></span><br><span class="line">  <span class="attr">DeducedTypes:</span> <span class="literal">true</span>     <span class="comment"># 显示推断类型提示</span></span><br><span class="line">  <span class="attr">Designators:</span> <span class="literal">true</span>      <span class="comment"># 显示设计器提示</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Completion:</span>              <span class="comment"># 代码补全设置部分</span></span><br><span class="line">  <span class="attr">AllScopes:</span> <span class="literal">true</span>        <span class="comment"># 启用所有作用域的代码补全</span></span><br><span class="line">  <span class="attr">Brackets:</span> <span class="string">&quot;[]&quot;</span>         <span class="comment"># 补全时使用的括号类型</span></span><br><span class="line"></span><br><span class="line"><span class="attr">SemanticTokens:</span>          <span class="comment"># 语义标记设置部分</span></span><br><span class="line">  <span class="attr">Enabled:</span> <span class="literal">true</span>          <span class="comment"># 启用语义标记</span></span><br><span class="line">  <span class="attr">DisabledKinds:</span> [<span class="string">&quot;Macro&quot;</span>] <span class="comment"># 禁用宏语义标记</span></span><br><span class="line">  <span class="attr">DisabledModifiers:</span> [<span class="string">&quot;Static&quot;</span>] <span class="comment"># 禁用静态修饰符语义标记</span></span><br></pre></td></tr></table></figure><h1 id="3-生成-compile-commands-json-文件"><a href="#3-生成-compile-commands-json-文件" class="headerlink" title="3 生成 compile_commands.json 文件"></a>3 生成 <code>compile_commands.json</code> 文件</h1><p><code>compile_commands.json</code> 是一个包含编译命令的 JSON 文件，用于描述项目中每个源文件的编译方式。它的主要作用是帮助 <code>Clangd</code> 和其他工具了解项目的编译设置，从而提供更准确的代码补全、跳转和诊断功能。具体作用如下：</p><h2 id="3-1-Cmake生成-compile-commands-json"><a href="#3-1-Cmake生成-compile-commands-json" class="headerlink" title="3.1 Cmake生成 compile_commands.json"></a>3.1 Cmake生成 <code>compile_commands.json</code></h2><h3 id="3-1-1-方案一-CMakeLists-txt设置"><a href="#3-1-1-方案一-CMakeLists-txt设置" class="headerlink" title="3.1.1 方案一: CMakeLists.txt设置"></a>3.1.1 方案一: <code>CMakeLists.txt</code>设置</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><h3 id="3-1-2-方案二-命令行参数设置"><a href="#3-1-2-方案二-命令行参数设置" class="headerlink" title="3.1.2 方案二: 命令行参数设置"></a>3.1.2 方案二: 命令行参数设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON ..</span><br></pre></td></tr></table></figure><h2 id="3-2-Makefile生成-compile-commands-json"><a href="#3-2-Makefile生成-compile-commands-json" class="headerlink" title="3.2 Makefile生成 compile_commands.json"></a>3.2 Makefile生成 <code>compile_commands.json</code></h2><p>Makefile本身不能直接生成 <code>compile_commands.json</code>文件1。不过，可以使用一些工具来生成这个文件，例如<strong>Bear</strong>和<strong>CompileDB</strong>。</p><h3 id="3-2-1-Bear"><a href="#3-2-1-Bear" class="headerlink" title="3.2.1 Bear"></a>3.2.1 Bear</h3><p>Bear是一个生成JSON编译数据库的工具，非常适合用于Makefile项目3。使用方法如下：</p><ol><li><p>安装Bear：<br><strong>bash</strong>Copy</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install bear</span><br></pre></td></tr></table></figure></li><li><p>运行Makefile并生成 <code>compile_commands.json</code>：<br><strong>bash</strong>Copy</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bear make <span class="comment"># 有的版本需要使用 bear -- make</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="3-2-2-CompileDB"><a href="#3-2-2-CompileDB" class="headerlink" title="3.2.2 CompileDB"></a>3.2.2 CompileDB</h3><p>CompileDB是另一个生成 <code>compile_commands.json</code>的工具，适用于GNU Make项目5。使用方法如下：</p><ol><li><p>安装CompileDB：<br><strong>bash</strong>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install compiledb</span><br></pre></td></tr></table></figure></li><li><p>运行Makefile并生成 <code>compile_commands.json</code>：<br><strong>bash</strong>Copy</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compiledb make</span><br></pre></td></tr></table></figure></li></ol><h1 id="4-实际案例"><a href="#4-实际案例" class="headerlink" title="4 实际案例"></a>4 实际案例</h1><p>以一个使用 <code>C++20</code> + <code>vcpkg</code>包管理的 <code>CMake</code>项目为例，详细代码参考: <a href="https://github.com/ToniXWD/ClangdLearn">https://github.com/ToniXWD/ClangdLearn</a></p><blockquote><p>关于vcpkg的使用可以参考我上一篇文章: <a href="https://tonixwd.github.io/2024/10/04/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%AC%94%E8%AE%B0/vcpkg%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/">vcpkg包管理工具介绍</a></p></blockquote><p><strong>配置 <code>CMakeLixts.txt</code></strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(ClangdLearn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(fmt CONFIG REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(ClangdLearn main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(ClangdLearn PRIVATE fmt::fmt)</span><br></pre></td></tr></table></figure><p><strong><code>main.cpp</code>, 使用C++20的协程</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fmt/core.h&quot;</span> <span class="comment">// 引入fmt库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用C++20的range库</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_even_numbers</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;numbers)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> even_numbers =</span><br><span class="line">      numbers | std::views::<span class="built_in">filter</span>([](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;num : even_numbers) &#123;</span><br><span class="line">    fmt::<span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, num);</span><br><span class="line">  &#125;</span><br><span class="line">  fmt::<span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用C++20的协程</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="type">int</span> current_value;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">yield_value</span><span class="params">(<span class="type">int</span> value)</span> -&gt; std::suspend_always </span>&#123;</span><br><span class="line">      current_value = value;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">initial_suspend</span><span class="params">()</span> -&gt; std::suspend_always </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> -&gt; std::suspend_always </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">get_return_object</span><span class="params">()</span> -&gt; Generator </span>&#123; <span class="keyword">return</span> Generator&#123;<span class="keyword">this</span>&#125;; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123; std::<span class="built_in">terminate</span>(); &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> handle_type = std::coroutine_handle&lt;promise_type&gt;;</span><br><span class="line">  handle_type coro;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Generator</span>(promise_type *p) : <span class="built_in">coro</span>(handle_type::<span class="built_in">from_promise</span>(*p)) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">Generator</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (coro)</span><br><span class="line">      coro.<span class="built_in">destroy</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">move_next</span><span class="params">()</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">    coro.<span class="built_in">resume</span>();</span><br><span class="line">    <span class="keyword">return</span> !coro.<span class="built_in">done</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  [[nodiscard]] <span class="function"><span class="keyword">auto</span> <span class="title">current_value</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> coro.<span class="built_in">promise</span>().current_value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">generate_numbers</span><span class="params">(<span class="type">int</span> max)</span> -&gt; Generator </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    <span class="keyword">co_yield</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">  fmt::<span class="built_in">print</span>(<span class="string">&quot;Even numbers: &quot;</span>);</span><br><span class="line">  <span class="built_in">print_even_numbers</span>(numbers);</span><br><span class="line"></span><br><span class="line">  fmt::<span class="built_in">print</span>(<span class="string">&quot;Generated numbers: &quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> gen = <span class="built_in">generate_numbers</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">while</span> (gen.<span class="built_in">move_next</span>()) &#123;</span><br><span class="line">    fmt::<span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, gen.<span class="built_in">current_value</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  fmt::<span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置 <code>.clangd</code> 文件</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CompileFlags:</span></span><br><span class="line">  <span class="attr">Add:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;-Wall&quot;</span> <span class="comment"># 启用所有警告</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;-Wextra&quot;</span> <span class="comment"># 启用额外警告</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;-std=c++20&quot;</span> <span class="comment"># 使用C++20标准</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;-Iinclude&quot;</span> <span class="comment"># 包含头文件, 相对路径, 这里没有使用, 只是一个示意</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;-isystemF:/software/vcpkg/installed/x64-windows/include&quot;</span> <span class="comment"># 包含头文件, 绝对路径, vcpkg的安装包头文件路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">Diagnostics:</span></span><br><span class="line">  <span class="attr">ClangTidy:</span></span><br><span class="line">    <span class="attr">Add:</span> [<span class="string">&quot;cppcoreguidelines-*&quot;</span>, <span class="string">&quot;modernize-*&quot;</span>, <span class="string">&quot;performance-*&quot;</span>]</span><br><span class="line">    <span class="attr">Remove:</span> [<span class="string">&quot;clang-analyzer-*&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">InlayHints:</span></span><br><span class="line">  <span class="attr">Enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">ParameterNames:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">DeducedTypes:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">Designators:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Completion:</span></span><br><span class="line">  <span class="attr">AllScopes:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>编译运行</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake <span class="literal">--preset</span> vcpkg</span><br><span class="line">cmake <span class="literal">--build</span> build <span class="comment"># 可以成功运行</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-背景介绍&quot;&gt;&lt;a href=&quot;#1-背景介绍&quot; class=&quot;headerlink&quot; title=&quot;1 背景介绍&quot;&gt;&lt;/a&gt;1 背景介绍&lt;/h1&gt;&lt;p&gt;&lt;code&gt;clangd&lt;/code&gt; 是一个基于 LLVM 的 Clang 编译器前端提供的代码补全服务工</summary>
      
    
    
    
    <category term="实用工具" scheme="http://example.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="vcpkg" scheme="http://example.com/tags/vcpkg/"/>
    
  </entry>
  
  <entry>
    <title>vcpkg包管理工具介绍</title>
    <link href="http://example.com/2024/10/04/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%AC%94%E8%AE%B0/vcpkg%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2024/10/04/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%AC%94%E8%AE%B0/vcpkg%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</id>
    <published>2024-10-04T07:11:58.000Z</published>
    <updated>2024-10-08T09:41:56.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-vcpkg简介"><a href="#1-vcpkg简介" class="headerlink" title="1 vcpkg简介"></a>1 vcpkg简介</h1><p>vcpkg 是一个开源项目，由微软开发并维护，旨在简化跨平台 C++ 库的获取与管理过程。对于开发者来说，寻找、安装以及管理第三方C++库往往是一件既耗时又容易出错的工作，尤其是在不同的操作系统上进行开发时。vcpkg 就是为了解决这一痛点而诞生的工具。官方文档: <a href="https://learn.microsoft.com/zh-cn/vcpkg/">vcpkg 文档 | Microsoft Learn</a>, 这里我会结合自己实际的使用体验进行介绍。</p><ul><li><strong>跨平台支持</strong>：vcpkg 支持 Windows、Linux 和 macOS 操作系统，这意味着你可以用一种方式在所有这些平台上管理你的依赖项。</li><li><strong>简化依赖管理</strong>：通过简单的命令行操作即可安装、卸载和升级库。这使得开发者能够更加专注于应用程序本身的开发，而不是被复杂的库管理和构建流程所困扰。</li><li><strong>预编译二进制文件</strong>：为了加速开发流程，vcpkg 提供了许多库的预编译二进制文件。这样就避免了每次都要从源码编译库的麻烦，特别是在开发环境中频繁地切换或测试不同版本的库时。</li><li><strong>社区驱动</strong>：vcpkg 是一个活跃的开源项目，拥有庞大的社区支持。这意味着它不仅有定期更新以包含最新的库版本，还有一群热心的贡献者可以帮助解决使用过程中遇到的问题。</li></ul><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/microsoft/vcpkg.git <span class="comment"># 克隆仓库</span></span><br><span class="line"><span class="built_in">cd</span> vcpkg</span><br><span class="line">./bootstrap-vcpkg.sh <span class="comment"># Linux bash</span></span><br><span class="line">.\bootstrap-vcpkg.bat <span class="comment"># Windows Powershell</span></span><br></pre></td></tr></table></figure><p>设置环境变量:</p><p><strong>Windows</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">$env:VCPKG_ROOT</span> = <span class="string">&quot;C:\path\to\vcpkg&quot;</span></span><br><span class="line"><span class="variable">$env:PATH</span> = <span class="string">&quot;<span class="variable">$env:VCPKG_ROOT</span>;<span class="variable">$env:PATH</span>&quot;</span></span><br><span class="line"><span class="comment"># 永久设置需要再系统环境变量中添加</span></span><br></pre></td></tr></table></figure><p><strong>Linux</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export VCPKG_ROOT=/path/to/vcpkg</span><br><span class="line">export PATH=<span class="variable">$VCPKG_ROOT:</span><span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 永久设置需要添加到~/.bashrc</span></span><br></pre></td></tr></table></figure><h1 id="3-案例项目解析"><a href="#3-案例项目解析" class="headerlink" title="3 案例项目解析"></a>3 案例项目解析</h1><h2 id="3-1-官方案例引入"><a href="#3-1-官方案例引入" class="headerlink" title="3.1 官方案例引入"></a>3.1 官方案例引入</h2><h3 id="3-1-1-项目配置"><a href="#3-1-1-项目配置" class="headerlink" title="3.1.1 项目配置"></a>3.1.1 项目配置</h3><p>这里引入官方的案例项目:<a href="https://learn.microsoft.com/zh-cn/vcpkg/get_started/get-started?pivots=shell-bash">通过 CMake 安装和使用包 | Microsoft Learn</a>, 但对其进行相应的补充和扩展</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> vckpg_example</span><br><span class="line"><span class="built_in">cd</span> vcpkg_example</span><br><span class="line">vcpkg new --application <span class="comment"># 初始化vcpkg项目</span></span><br><span class="line">vcpkg add port <span class="built_in">fmt</span> <span class="comment"># 添加 fmt 依赖项</span></span><br></pre></td></tr></table></figure><p>添加如下所示的 <code>CMakeLists.txt</code>:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(HelloWorld)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(fmt CONFIG REQUIRED) <span class="comment"># 指定vcpkg的查找的库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(HelloWorld helloworld.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(HelloWorld PRIVATE fmt::fmt)</span><br></pre></td></tr></table></figure><p>创建包含以下内容的 <code>helloworld.cpp</code> 文件:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fmt::<span class="built_in">print</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置vcpkg</strong></p><p>创建 <code>CMakePresets.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;configurePresets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vcpkg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;generator&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Ninja&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;binaryDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;sourceDir&#125;/build&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cacheVariables&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;CMAKE_TOOLCHAIN_FILE&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$env&#123;VCPKG_ROOT&#125;/scripts/buildsystems/vcpkg.cmake&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>创建 <code>CMakeUserPresets.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurePresets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;inherits&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vcpkg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;VCPKG_ROOT&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/toni/proj/vcpkg&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>配置文件 <code>CMakePresets.json</code> 和 <code>CMakeUserPresets.json</code>的区别是什么?</p><ul><li><code>CMakePresets.json与 CMakeLists.txt 文件同级, 用于项目级和用户级的 CMake 配置。</code></li><li><code>CMakeUserPresets.json允许用户自定义与个人开发环境相关的构建预设，通常不共享给其他开发者,可以继承和覆盖项目级的 CMakePresets.json 中的预设，增加额外的个性化配置。</code></li><li><code>CMakePresets.json</code>是必须的, 而 <code>CMakeUserPresets.json</code>是可选的</li></ul></blockquote><h3 id="3-1-2-编译指令"><a href="#3-1-2-编译指令" class="headerlink" title="3.1.2 编译指令"></a>3.1.2 编译指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --preset=default <span class="comment"># 或vcpkg</span></span><br><span class="line">$ cmake --build build</span><br><span class="line">$ ./build/HelloWorld <span class="comment">#运行编译结果</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><h2 id="3-2-代码智能补全配置"><a href="#3-2-代码智能补全配置" class="headerlink" title="3.2 代码智能补全配置"></a>3.2 代码智能补全配置</h2><p>按照官网的提示完成的项目虽然可以运行, 但其由于依赖包是vcpkg统一管理的, 因此IDE通常找不到头文件而无法提供代码智能补全, 这里我以 <code>VSCode+clangd</code>开发环境为例:</p><p><img src="/../../images/vcpkg/vcpkg_include_error.png" alt="1728029671453"></p><p>这里需要手动将其头文件搜索路径引入进来, 这里提前引入统一的安装命令:<code>install</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install <span class="built_in">fmt</span></span><br></pre></td></tr></table></figure><p>安装后再如下位置可以找到源文件:</p><p><img src="/../../images/vcpkg/vcpkg_install.png" alt="1728030298083"></p><p>在项目根目录创建 <code>.clangd</code>文件:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CompileFlags:</span></span><br><span class="line">    <span class="attr">Add:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;-isystem/home/toni/proj/vcpkg/installed/x64-linux/include&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意还需修改头文件的&lt;&gt;引入符合为””, 现在已经能够识别头文件位置了:</p><p><img src="/../../images/vcpkg/vcpkg_clangd.png" alt="1728030546951"></p><h1 id="4-基本概念和术语"><a href="#4-基本概念和术语" class="headerlink" title="4 基本概念和术语"></a>4 基本概念和术语</h1><table><thead><tr><th><strong>术语</strong></th><th><strong>定义</strong></th><th><strong>作用&#x2F;用途</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>Package（包）</strong></td><td>项目依赖的第三方库或软件组件</td><td>用于安装和管理库，例如 <code>boost</code> 或 <code>sqlite3</code></td><td><code>vcpkg install boost</code></td></tr><tr><td><strong>Port（端口）</strong></td><td>将库移植到 <code>vcpkg</code> 的构建和安装说明</td><td>定义如何下载、编译、安装库。通常在 <code>ports/&lt;package&gt;</code> 目录下</td><td><code>ports/boost</code> 中定义了 <code>boost</code> 的安装和配置方式</td></tr><tr><td><strong>Triplet（三元组）</strong></td><td>定义目标平台的架构、操作系统和链接方式（静态或动态）</td><td>通过三元组为不同平台编译库，如 <code>x64-windows-static</code></td><td><code>x64-windows-static</code>, <code>x86-linux-dynamic</code>, <code>arm64-osx</code></td></tr><tr><td><strong>Overlay Ports</strong></td><td>自定义或覆盖默认端口文件</td><td>允许自定义端口的行为和版本，避免修改 <code>vcpkg</code> 官方端口</td><td><code>--overlay-ports=&lt;path&gt;</code> 参数用来指定自定义端口</td></tr><tr><td><strong>Manifest Mode（清单模式）</strong></td><td>使用 <code>vcpkg.json</code> 定义项目的依赖</td><td>自动解析并安装项目依赖，简化依赖管理</td><td><code>vcpkg.json</code> 中定义依赖库，如 <code>boost</code>, <code>openssl</code></td></tr><tr><td><strong>Classic Mode（经典模式）</strong></td><td>手动管理和安装依赖库，不依赖 <code>vcpkg.json</code></td><td>包会安装在全局环境中，多个项目可以共享</td><td><code>vcpkg install &lt;package&gt;</code></td></tr><tr><td><strong>Registries（注册表）</strong></td><td>存储和分发包的仓库，类似于 <code>npm</code> 的注册表</td><td>可以使用官方注册表或配置私有注册表</td><td><code>vcpkg</code> 默认使用 GitHub 仓库，但可以自定义注册表</td></tr><tr><td><strong>Baseline（基线）</strong></td><td>定义依赖包的稳定版本集合</td><td>锁定项目的依赖包版本，避免因更新包导致的不兼容问题</td><td><code>vcpkg.json</code> 中的 <code>builtin-baseline</code> 定义项目依赖的基线版本</td></tr><tr><td><strong>Toolchain File（工具链文件）</strong></td><td><code>CMake</code> 中用于配置编译器、链接器和选项的文件</td><td>让 CMake 项目在构建时自动使用 <code>vcpkg</code> 安装的包</td><td><code>cmake -DCMAKE_TOOLCHAIN_FILE=&lt;path-to-vcpkg&gt;/scripts/buildsystems/vcpkg.cmake</code></td></tr><tr><td><strong>Vcpkg Artifacts</strong></td><td>扩展机制，用于管理和安装开发工具和工具链</td><td>不仅限于库的管理，还可以安装编译器、调试工具等</td><td>安装编译器、调试工具等其他构建工具</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-vcpkg简介&quot;&gt;&lt;a href=&quot;#1-vcpkg简介&quot; class=&quot;headerlink&quot; title=&quot;1 vcpkg简介&quot;&gt;&lt;/a&gt;1 vcpkg简介&lt;/h1&gt;&lt;p&gt;vcpkg 是一个开源项目，由微软开发并维护，旨在简化跨平台 C++ 库的获取与管理</summary>
      
    
    
    
    <category term="实用工具" scheme="http://example.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="vcpkg" scheme="http://example.com/tags/vcpkg/"/>
    
  </entry>
  
  <entry>
    <title>Rust好库-notify</title>
    <link href="http://example.com/2024/10/04/Rust%E9%9A%8F%E7%AC%94/Rust%E5%A5%BD%E5%BA%93-notify/"/>
    <id>http://example.com/2024/10/04/Rust%E9%9A%8F%E7%AC%94/Rust%E5%A5%BD%E5%BA%93-notify/</id>
    <published>2024-10-03T17:18:55.000Z</published>
    <updated>2024-10-04T08:32:32.750Z</updated>
    
    <content type="html"><![CDATA[<p><code>notify</code> 主要用于文件系统监控，可以让你的应用程序监听文件或目录的变化。当需要在文件发生变化（如创建、删除、修改等）时得到通知，这个库就非常有用。<code>notify</code> 支持多种操作系统，并且在内部使用了特定平台的文件系统监控机制，比如在 <code>Linux</code> 上使用 <code>inotify，在</code> <code>macOS</code> 上使用 <code>FSEvents，在</code> <code>Windows</code> 上则使用 <code>ReadDirectoryChangesW</code> API。</p><p>库地址: <a href="https://github.com/notify-rs/notify">https://github.com/notify-rs/notify</a></p><h1 id="1-版本features说明"><a href="#1-版本features说明" class="headerlink" title="1 版本features说明"></a>1 版本features说明</h1><table><thead><tr><th>版本</th><th>描述</th><th>使用场景</th></tr></thead><tbody><tr><td><code>notify</code></td><td>核心模块，提供基本的文件系统事件监听功能。内建去抖动逻辑。</td><td>适合一般用途的文件系统监控，不需要额外的去抖动特性。</td></tr><tr><td><code>notify_debouncer_mini</code></td><td>轻量级去抖动实现，提供简单而有效的去抖动功能。</td><td>性能敏感的应用场景，希望保持依赖关系简单。</td></tr><tr><td><code>notify_debouncer_full</code></td><td>全功能去抖动解决方案，提供更复杂的逻辑来处理各种情况下的去抖动需求。</td><td>需要更强大、更灵活去抖动功能的情况，或在复杂环境中运行的应用程序。</td></tr></tbody></table><p><strong>说明：</strong></p><ul><li><strong>去抖动</strong>：减少由于短时间内频繁触发事件而导致的重复或不必要的通知。</li><li><strong>性能敏感</strong>：对于那些对执行效率有较高要求的应用程序。</li><li><strong>复杂环境</strong>：指涉及多种类型的文件系统事件以及需要正确合并或过滤这些事件的情况。</li></ul><p><code>debouncer</code> 的作用:</p><ul><li>如果有多次重命名, 仅发出单个重命名事件</li><li>合并多个重命名事件</li><li>考虑重命名事件并更新重命名事件之前发生但尚未发出的事件的路径<br>（可选）跟踪文件系统 ID、所有文件和整合重命名事件（FSevents、Windows）</li><li>删除目录时仅发出一个删除事件 (inotify)</li><li>不发出重复的创建事件</li><li>创建事件后不发出修改事件</li></ul><h1 id="2-实战案例"><a href="#2-实战案例" class="headerlink" title="2 实战案例"></a>2 实战案例</h1><p>这里最简单的应用就是创建一个文件缓存索引, 当监听到文件变化时, 惰性建立缓存索引</p><p>完整的代码(包括客户端应用、数据库持久化、CRUD等)请参考 <a href="https://github.com/ToniXWD/file_elf">file_elf</a>, 这里给出监听的逻辑</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> util;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> writer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::path::PathBuf;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc::Sender;</span><br><span class="line"><span class="keyword">use</span> std::&#123;sync::mpsc, time::Duration&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> log::&#123;debug, error, info, trace&#125;;</span><br><span class="line"><span class="keyword">use</span> notify::&#123;DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher&#125;;</span><br><span class="line"><span class="keyword">use</span> writer::DbAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::db::DB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::util::is_blacklisted;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">file_checker</span>(target: &amp;<span class="type">str</span>, db_sender: mpsc::Sender&lt;DbAction&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">watcher</span>: RecommendedWatcher = Watcher::<span class="title function_ invoke__">new</span>(tx, Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>)).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 制定监听器和通知间隔时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听指定目录 target</span></span><br><span class="line">    watcher</span><br><span class="line">        .<span class="title function_ invoke__">watch</span>(target, RecursiveMode::Recursive) <span class="comment">// RecursiveMode表示递归监听子文件夹</span></span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to watch directory&quot;</span>);</span><br><span class="line"></span><br><span class="line">    info!(<span class="string">&quot;Watching directory: &#123;&#125; for changes...&quot;</span>, target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> rx.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(event) =&gt; <span class="keyword">match</span> event &#123;</span><br><span class="line">                DebouncedEvent::<span class="title function_ invoke__">Create</span>(path) | DebouncedEvent::<span class="title function_ invoke__">Write</span>(path) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="title function_ invoke__">is_blacklisted</span>(&amp;path) &#123;</span><br><span class="line">                        trace!(<span class="string">&quot;File: &#123;:#?&#125; is blacklisted, ignoring...&quot;</span>, path);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="title function_ invoke__">new_event_handler</span>(&amp;path, &amp;db_sender);</span><br><span class="line">                &#125;</span><br><span class="line">                DebouncedEvent::<span class="title function_ invoke__">Remove</span>(path) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="title function_ invoke__">is_blacklisted</span>(&amp;path) &#123;</span><br><span class="line">                        trace!(<span class="string">&quot;File: &#123;:#?&#125; is blacklisted, ignoring...&quot;</span>, path);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="title function_ invoke__">del_event_handler</span>(&amp;path, &amp;db_sender);</span><br><span class="line">                &#125;</span><br><span class="line">                DebouncedEvent::<span class="title function_ invoke__">Rename</span>(old_path, new_path) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="title function_ invoke__">is_blacklisted</span>(&amp;old_path) &#123;</span><br><span class="line">                        trace!(<span class="string">&quot;File: &#123;:#?&#125; is blacklisted, ignoring...&quot;</span>, old_path);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    info!(<span class="string">&quot;File renamed from &#123;:?&#125; to &#123;:?&#125;&quot;</span>, old_path, new_path);</span><br><span class="line">                    <span class="title function_ invoke__">del_event_handler</span>(&amp;old_path, &amp;db_sender);</span><br><span class="line">                    <span class="title function_ invoke__">new_event_handler</span>(&amp;new_path, &amp;db_sender);</span><br><span class="line">                &#125;</span><br><span class="line">                DebouncedEvent::<span class="title function_ invoke__">NoticeWrite</span>(path) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="title function_ invoke__">is_blacklisted</span>(&amp;path) &#123;</span><br><span class="line">                        trace!(<span class="string">&quot;File: &#123;:#?&#125; is blacklisted, ignoring...&quot;</span>, path);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    info!(<span class="string">&quot;File notice write: &#123;:?&#125;&quot;</span>, path);</span><br><span class="line">                &#125;</span><br><span class="line">                DebouncedEvent::<span class="title function_ invoke__">NoticeRemove</span>(path) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="title function_ invoke__">is_blacklisted</span>(&amp;path) &#123;</span><br><span class="line">                        trace!(<span class="string">&quot;File: &#123;:#?&#125; is blacklisted, ignoring...&quot;</span>, path);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    info!(<span class="string">&quot;File notice remove: &#123;:?&#125;&quot;</span>, path);</span><br><span class="line">                &#125;</span><br><span class="line">                DebouncedEvent::<span class="title function_ invoke__">Chmod</span>(path) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="title function_ invoke__">is_blacklisted</span>(&amp;path) &#123;</span><br><span class="line">                        trace!(<span class="string">&quot;File: &#123;:#?&#125; is blacklisted, ignoring...&quot;</span>, path);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    info!(<span class="string">&quot;File permissions changed: &#123;:?&#125;&quot;</span>, path);</span><br><span class="line">                &#125;</span><br><span class="line">                DebouncedEvent::Rescan =&gt; &#123;</span><br><span class="line">                    info!(<span class="string">&quot;Directory rescan occurred.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                DebouncedEvent::<span class="title function_ invoke__">Error</span>(err, path) =&gt; &#123;</span><br><span class="line">                    error!(<span class="string">&quot;An error occurred: &#123;:?&#125;, related path &#123;:#?&#125;&quot;</span>, err, path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(e) =&gt; error!(<span class="string">&quot;watch error: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new_event_handler</span>(path: &amp;PathBuf, db_sender: &amp;Sender&lt;DbAction&gt;) &#123;</span><br><span class="line">    <span class="comment">// CRUD、持久化等操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">del_event_handler</span>(path: &amp;PathBuf, db_sender: &amp;Sender&lt;DbAction&gt;) &#123;</span><br><span class="line">    <span class="comment">// CRUD、持久化等操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-去抖动器debouncer的使用"><a href="#3-去抖动器debouncer的使用" class="headerlink" title="3 去抖动器debouncer的使用"></a>3 去抖动器debouncer的使用</h1><p>先看官方代码:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> notify_debouncer_full::&#123;notify::*, new_debouncer, DebounceEventResult&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Select recommended watcher for debouncer.</span></span><br><span class="line"><span class="comment">// Using a callback here, could also be a channel.</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">debouncer</span> = <span class="title function_ invoke__">new_debouncer</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>), <span class="literal">None</span>, |result: DebounceEventResult| &#123;</span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(events) =&gt; events.<span class="title function_ invoke__">iter</span>().for_each(|event| <span class="built_in">println!</span>(<span class="string">&quot;&#123;event:?&#125;&quot;</span>)),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(errors) =&gt; errors.<span class="title function_ invoke__">iter</span>().for_each(|error| <span class="built_in">println!</span>(<span class="string">&quot;&#123;error:?&#125;&quot;</span>)),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure><p>具体进行分析:</p><ul><li><code>DebounceEventResult</code> 是去抖动结果的类型。</li><li><code>new_debouncer(Duration::from_secs(2), None, ...)</code> 创建一个新的去抖动器实例，设置去抖动延迟时间为2秒，并传入一个回调函数。</li><li>回调函数接收一个 <code>DebounceEventResult</code> 类型的结果，该结果表示去抖动后的事件集合或错误集合。</li><li><code>Ok(events)</code> 表示成功处理事件，打印每个事件。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debouncer.<span class="title function_ invoke__">watcher</span>().<span class="title function_ invoke__">watch</span>(Path::<span class="title function_ invoke__">new</span>(<span class="string">&quot;.&quot;</span>), RecursiveMode::Recursive).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure><p>这行代码添加一个路径到去抖动器的监听列表中：</p><ul><li><code>debouncer.watcher()</code> 获取底层的 <code>Watcher</code> 实例。</li><li><code>watch(Path::new(&quot;.&quot;), RecursiveMode::Recursive)</code> 监听当前目录及其所有子目录的文件系统变化。</li><li><code>unwrap()</code> 确保监听操作成功，否则抛出错误。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debouncer.<span class="title function_ invoke__">cache</span>().<span class="title function_ invoke__">add_root</span>(Path::<span class="title function_ invoke__">new</span>(<span class="string">&quot;.&quot;</span>), RecursiveMode::Recursive);</span><br></pre></td></tr></table></figure><p>这行代码向去抖动器的文件 ID 缓存中添加相同的路径：</p><ul><li><code>debouncer.cache()</code> 获取去抖动器的缓存实例。</li><li><code>add_root(Path::new(&quot;.&quot;), RecursiveMode::Recursive)</code> 将当前目录及其所有子目录添加到文件 ID 缓存中。</li><li>文件 ID 缓存利用文件系统提供的唯一文件 ID 来组合重命名事件，特别是在通知后端不提供重命名标记的情况下。</li></ul><p><strong>这里对<code>watcher()</code>和<code>cache()</code>进行特殊的区别说明</strong></p><ul><li><code>watcher()</code> 方法返回的是底层的 <code>Watcher</code> 实例，它负责实际的文件系统监听工作。</li><li><code>cache()</code> 方法返回的是文件 ID 缓存组件，它主要用于处理文件系统的重命名事件。帮助正确识别和处理重命名事件：</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;notify&lt;/code&gt; 主要用于文件系统监控，可以让你的应用程序监听文件或目录的变化。当需要在文件发生变化（如创建、删除、修改等）时得到通知，这个库就非常有用。&lt;code&gt;notify&lt;/code&gt; 支持多种操作系统，并且在内部使用了特定平台的文件系统监控机</summary>
      
    
    
    
    <category term="Rust随笔" scheme="http://example.com/categories/Rust%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>C++新特性梳理02</title>
    <link href="http://example.com/2024/05/05/C++/C++%E6%96%B0%E7%89%B9%E6%80%A7%E6%A2%B3%E7%90%8602/"/>
    <id>http://example.com/2024/05/05/C++/C++%E6%96%B0%E7%89%B9%E6%80%A7%E6%A2%B3%E7%90%8602/</id>
    <published>2024-05-05T04:39:12.000Z</published>
    <updated>2024-10-03T17:47:36.137Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直在准备暑期实习的笔试和面试, 因此博客断更了很久…回头做6.5840发现自己的代码逻辑都快忘了…</p><p>先整理下实习求职过程中学习的C++的新特性, 由于C++11已经使用得很广泛了, 包括智能指针、各种转换运算符、lambda表达式已经成为面试常见考点了，这里我就不提这些了，因此我只梳理从C++17开始的知识点，包括C++17、C++20、C++23和少量C++26。</p><p><del>之前断更的6.5840的最后一个lab4B也会补上</del></p><h2 id="1-结构体优化"><a href="#1-结构体优化" class="headerlink" title="1 结构体优化"></a>1 结构体优化</h2><h3 id="1-1-支持指定项的初始化列表"><a href="#1-1-支持指定项的初始化列表" class="headerlink" title="1.1 支持指定项的初始化列表"></a>1.1 支持指定项的初始化列表</h3><p><code>C++20</code>支持类似<code>golang</code>的结构体声明, 可以显式地为每个成员进行命名, 这在结构体成员数量很多时有助于提高代码可读性:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// C++20 introduces the designated initializer list W</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">A</span> a&#123;.x = <span class="number">1</span>, .y = <span class="number">2</span>, .z = <span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-结构体成员绑定"><a href="#1-2-结构体成员绑定" class="headerlink" title="1.2 结构体成员绑定"></a>1.2 结构体成员绑定</h3><p><code>C++17</code>运行直接从结构体成员初始化变量:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// C++20 introduces the designated initializer list W</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">A</span> a&#123;.x = <span class="number">1</span>, .y = <span class="number">2</span>, .z = <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Structure Binding declaration C++17 binds the specified names to elements of</span></span><br><span class="line">    <span class="comment">// initializer:</span></span><br><span class="line">    <span class="keyword">auto</span> [x, y, z] = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时绑定时支持<code>&amp;&amp;</code>和<code>&amp;</code>获取引用:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// C++20 introduces the designated initializer list W</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">A</span> a&#123;.x = <span class="number">1</span>, .y = <span class="number">2</span>, .z = <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Structure Binding declaration C++17 binds the specified names to elements of</span></span><br><span class="line">    <span class="comment">// initializer:</span></span><br><span class="line">    <span class="keyword">auto</span> [x, y, z] = a;</span><br><span class="line">    <span class="keyword">auto</span> &amp;[x2, y2, z2] = a;</span><br><span class="line"></span><br><span class="line">    a.x++;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; x2 &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-放松对constexpr用于函数的限制"><a href="#2-放松对constexpr用于函数的限制" class="headerlink" title="2 放松对constexpr用于函数的限制"></a>2 放松对<code>constexpr</code>用于函数的限制</h2><p><code>constexpr</code>用于修饰函数时，表示该函数可以在编译时求值。这样的函数可以用于计算编译时常量表达式，例如数组的大小、整数模板参数、枚举值等。<code>constexpr</code>修饰的函数存在一些限制, 但不同的版本限制不同, 每一个标准基本上都解除了之前的限制, 先总结如下:</p><table><thead><tr><th align="left">标准</th><th align="right">解除的限制</th></tr></thead><tbody><tr><td align="left">C++14</td><td align="right">只能有一个<code>return</code>语句, 且不应包含循环和<code>switch</code></td></tr><tr><td align="left">C++20</td><td align="right">不能包含<code>assert</code></td></tr><tr><td align="left">C++23</td><td align="right">不能包含<code>static</code>变量</td></tr></tbody></table><p>目前所有标准下都不能解除的限制:</p><ul><li>不能使用<code>runtime</code>的特性, 如<code>try-catch</code>和<code>exception</code></li><li>不能包含<code>goto</code></li><li>不能使用运行时的类型转换<code>reinterpret cast</code></li></ul><p>案例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> v &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> v; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">3</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">A a1;</span><br><span class="line"><span class="comment">// constexpr int x = a1.f(); // compile error, f() is evaluated at run-time</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> y = a1.<span class="built_in">g</span>(); <span class="comment">// ok, same as &#x27;A::g()&#x27;</span></span><br><span class="line"><span class="keyword">constexpr</span> A a2;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> x = a2.<span class="built_in">f</span>(); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>注意, 这里的<code>v</code>尽管有默认的初始化值3, 但仍然依赖于运行时的实例, 因此<code>constexpr int x = a1.f()</code>会导致编译器报错, 但静态成员函数<code>g</code>不依赖于类的任何特定实例，因此可以在没有创建任何 A 类型对象的情况下调用。</p><h2 id="3-新引入的const-关键字"><a href="#3-新引入的const-关键字" class="headerlink" title="3 新引入的const*关键字"></a>3 新引入的<code>const*</code>关键字</h2><h3 id="3-1-consteval关键字"><a href="#3-1-consteval关键字" class="headerlink" title="3.1 consteval关键字"></a>3.1 <code>consteval</code>关键字</h3><p><code>C++20</code>引入了<code>consteval</code>关键字, 这个关键字的含义为: <strong>保证所修饰的函数在编译时就能求值</strong></p><p>这一关键字会让人感到迷惑, 其与<code>constexpr</code>的区别是什么? 其区别其实就是一个是建议, 一个是硬性要求:</p><ul><li><code>constexpr</code>关键字是指示编译器尽可能在编译时对函数或变量进行求值。但如果编译时无法求值，它不会导致编译错误，函数或变量也可以在运行时求值。</li><li><code>consteval</code>关键字表示函数必须在编译时求值，每次调用都必须产生一个编译时常量。如果函数的调用不能在编译时求值，编译器将报错。</li></ul><h3 id="3-2-constinit关键字"><a href="#3-2-constinit关键字" class="headerlink" title="3.2 constinit关键字"></a>3.2 <code>constinit</code>关键字</h3><p><code>C++20</code>引入的<code>constinit</code>关键字保证变量的初始化必须在编译时完成, 运行时初始化的变量将引起报错:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value * value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constinit</span> <span class="type">int</span> v1 = <span class="built_in">square</span>(<span class="number">4</span>); <span class="comment">// compile-time evaluation</span></span><br><span class="line">v1 = <span class="number">3</span>; <span class="comment">// ok, v1 can change</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">4</span>; <span class="comment">// &quot;v&quot; is dynamic</span></span><br><span class="line"><span class="comment">// constinit int v2 = square(a); // compile error</span></span><br></pre></td></tr></table></figure><h3 id="3-3-if-constexpr"><a href="#3-3-if-constexpr" class="headerlink" title="3.3 if constexpr"></a>3.3 <code>if constexpr</code></h3><p><code>C++17</code>引入<code>if constexpr</code>, 允许在编译时根据常量表达式进行条件分支。与普通的<code>if</code>语句不同，<code>if constexpr</code>允许编译器在编译时就丢弃不适用的代码分支。</p><p>使用<code>if constexpr</code>的主要作用是在模板编程中提供更多的灵活性。当模板被不同类型的参数实例化时，某些代码可能只对特定类型有效，而<code>if constexpr</code>可以确保只有在条件为真时，相关的代码才会被编译和实例化。这样可以避免编译错误，并减少不必要的代码膨胀。</p><p>下面是一个简单的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">auto</span> <span class="title">process</span><span class="params">(<span class="type">const</span> T &amp;value)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral&lt;T&gt;())</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;传入的是整数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;传入的是浮点数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> value / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">process</span>(<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">process</span>(<span class="number">5.0</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-is-constant-evaluated"><a href="#3-4-is-constant-evaluated" class="headerlink" title="3.4 is constant evaluated"></a>3.4 <code>is constant evaluated</code></h3><p><code>C++20</code>引入的<code>is_constant_evaluated</code>用于检测函数自身是否在一个常量求值:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">compute</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">is_constant_evaluated</span>()) &#123;</span><br><span class="line">        <span class="comment">// 编译时求值的路径</span></span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 运行时求值的路径</span></span><br><span class="line">        <span class="keyword">return</span> x + x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> compile_time_result = <span class="built_in">compute</span>(<span class="number">10</span>); <span class="comment">// 编译时求值，结果为100</span></span><br><span class="line">    <span class="type">int</span> runtime_result = <span class="built_in">compute</span>(<span class="number">10</span>);                <span class="comment">// 运行时求值，结果为20</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Compile time: &quot;</span> &lt;&lt; compile_time_result &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Run time: &quot;</span> &lt;&lt; runtime_result &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-if-consteval"><a href="#3-5-if-consteval" class="headerlink" title="3.5 if consteval"></a>3.5 <code>if consteval</code></h3><p><code>if consteval</code>是<code>C++23</code>中引入的一个新特性，它解决了<code>std::is_constant_evaluated()</code>在某些情况下可能带来的问题。具体来说，<code>if consteval</code>可以直接检测当前的上下文是否为常量求值上下文，而不需要任何参数。</p><p>在<code>C++20</code>中，<code>std::is_constant_evaluated()</code>函数用于检测其调用是否发生在常量求值的上下文中。当<code>std::is_constant_evaluated()</code>被用作<code>if constexpr</code>语句的条件时，它总是返回<code>true</code>，这可能导致逻辑错误。因为<code>if constexpr</code>要求其条件必须是一个编译时已知的常量表达式，所以<code>std::is_constant_evaluated()</code>在这种情况下的行为并不总是符合预期。</p><p><code>if consteval</code>提供了一种更清晰、更直接的方式来检测编译时求值的上下文，而且它不需要包含任何头文件。此外，如果<code>if consteval</code>的结果为<code>true</code>，可以在其内部调用<code>consteval</code>函数，这在使用<code>std::is_constant_evaluated()</code>时是不可能的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">consteval</span> &#123;</span><br><span class="line">        <span class="comment">// 如果g在编译时求值的上下文中被调用，则执行此分支</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f</span>(i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，执行此分支</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fallback</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>if consteval</code>确保只有在编译时求值的上下文中，<code>f(i)</code>才会被调用。这样可以避免在运行时上下文中错误地调用<code>consteval</code>函数，从而解决了<code>std::is_constant_evaluated()</code>可能带来的问题。</p><p><strong>最后补充说明<code>if consteval</code>和<code>if constexpr</code>的区别</strong>：</p><ul><li><p><strong><code>if constexpr</code></strong>: 用于编译时的条件分支。如果条件为真，则编译器只会编译该分支内的代码，其他分支的代码会被丢弃。这对于模板编程非常有用，因为它可以在不同的模板实例化中根据类型选择不同的代码路径。<code>if constexpr</code>的条件必须是一个编译时已知的常量表达式¹。</p></li><li><p><strong><code>if consteval</code></strong>: 用于检测当前的上下文是否为常量求值上下文。如果<code>if consteval</code>的条件为真，那么它内部的代码只能在编译时求值的上下文中执行。这意味着，如果<code>if consteval</code>的条件为真，可以确信当前的代码是在编译时执行的。这对于需要区分编译时和运行时代码路径的情况非常有用²。</p></li></ul><h2 id="4-类型操作的优化"><a href="#4-类型操作的优化" class="headerlink" title="4 类型操作的优化"></a>4 类型操作的优化</h2><h3 id="4-1-bit-cast运算符"><a href="#4-1-bit-cast运算符" class="headerlink" title="4.1 bit_cast运算符"></a>4.1 <code>bit_cast</code>运算符</h3><p>是<code>C++20</code>引入<code>std::bit_cast</code>, 作用是在不同类型之间进行位级别的转换。</p><p>使用<code>std::bit_cast</code>的主要优点是它提供了一种类型安全的方式来重新解释数据的位表示，这在之前通常需要使用<code>reinterpret_cast</code>或直接内存操作来完成。<code>std::bit_cast</code>确保了源类型和目标类型的大小完全相同，并且不会违反严格别名规则。</p><p>以下是<code>std::bit_cast</code>的基本用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">3.14159f</span>;</span><br><span class="line">    <span class="comment">// 将float类型的变量f的位表示转换为无符号整数</span></span><br><span class="line">    <span class="keyword">auto</span> bits = std::<span class="built_in">bit_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(f);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Float value: &quot;</span> &lt;&lt; f &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bitwise representation: &quot;</span> &lt;&lt; std::hex &lt;&lt; bits &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>std::bit_cast</code>将一个<code>float</code>类型的变量<code>f</code>的位表示转换为了一个<code>unsigned int</code>类型的值。这种转换是通过位复制完成的，而不是通过类型转换。</p><p>需要注意的是，<code>std::bit_cast</code>只能在两个类型的大小完全相同的情况下使用。如果尝试在大小不同的类型之间使用<code>std::bit_cast</code>，编译器将会报错。此外，<code>std::bit_cast</code>也不能用于含有引用成员、非平凡的构造函数或析构函数的类型。</p><p><code>std::bit_cast</code>在需要精确控制对象表示的低级编程中非常有用，例如在硬件编程、网络通信或文件I&#x2F;O中处理二进制数据。</p><h3 id="4-2-no-unique-address"><a href="#4-2-no-unique-address" class="headerlink" title="4.2 [[no_unique_address]]"></a>4.2 <code>[[no_unique_address]]</code></h3><p><code>C++20</code>引入新的属性<code>[[no_unique_address]]</code>，用于告诉编译器一个类的非静态数据成员不需要有一个独一无二的地址。这意味着如果该成员是一个空类型（例如，没有数据成员的类），编译器可以优化它，使其不占用任何空间，就像它是一个空基类一样。</p><p>这个属性的主要用途是优化内存布局，特别是在使用空类型作为成员时。在没有<code>[[no_unique_address]]</code>的情况下，即使是空类型的成员也会占用一定的空间（通常是1字节），以确保它有一个独一无二的地址。但是使用了<code>[[no_unique_address]]</code>之后，这个空间就可以被省略，从而减少整个对象的大小。</p><p>下面是一个使用<code>[[no_unique_address]]</code>的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Empty</span> &#123;&#125;; <span class="comment">// 空类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithoutNoUniqueAddress</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Empty e; <span class="comment">// 即使是空类型，也会占用空间</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithNoUniqueAddress</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    [[no_unique_address]] Empty e; <span class="comment">// 不会占用额外空间</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通常情况下，空类型成员会占用至少1字节的空间</span></span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(WithoutNoUniqueAddress) &gt; <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="comment">// 使用了[[no_unique_address]]，空类型成员可以不占用空间</span></span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(WithNoUniqueAddress) == <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-lambda表达式的优化"><a href="#5-lambda表达式的优化" class="headerlink" title="5 lambda表达式的优化"></a>5 <code>lambda</code>表达式的优化</h2><h3 id="5-1-在lambda中使用consteval和constexpr"><a href="#5-1-在lambda中使用consteval和constexpr" class="headerlink" title="5.1 在lambda中使用consteval和constexpr"></a>5.1 在<code>lambda</code>中使用<code>consteval</code>和<code>constexpr</code></h3><p><code>C++17</code>支持在<code>lambda</code>中使用<code>constexpr</code>, <code>C++20</code>支持在<code>lambda</code>中使用<code>consteval</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// constexpr lambda</span></span><br><span class="line">  <span class="keyword">auto</span> func1 = [](<span class="type">int</span> value) <span class="keyword">constexpr</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= value; i++)</span><br><span class="line">      ret *= i;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">auto</span> func2 = [](<span class="type">int</span> v) <span class="keyword">consteval</span> &#123; <span class="keyword">return</span> v * <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">int</span> v1 = <span class="built_in">func1</span>(<span class="number">4</span>) + <span class="built_in">func2</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; v1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子一开始很容易让人误解: <code>consteval</code> 的语义是保证所修饰的函数在编译时就能求值, 但这里的<code>func2</code>中<code>int v</code>是未知的, 不是不满足这个语义吗?</p><p>原因是<code>func2</code>虽然被声明为<code>consteval</code>，但它是在<code>constexpr</code>表达式的上下文中使用的，这意味着它的参数在编译时是已知的。</p><h3 id="5-2-支持模板-模板参数类型校验"><a href="#5-2-支持模板-模板参数类型校验" class="headerlink" title="5.2 支持模板&amp;&amp;模板参数类型校验"></a>5.2 支持模板&amp;&amp;模板参数类型校验</h3><p><code>C++</code>引入了<code>lambda</code>对模板的支持:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> func1 = []&lt;<span class="keyword">typename</span> T&gt;(T val) &#123; cout &lt;&lt; val &lt;&lt; endl; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">func1</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> func2 = []&lt;<span class="keyword">typename</span> T&gt;(T val)</span><br><span class="line">    <span class="keyword">requires</span> std::is_arithmetic_v&lt;T&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">func2</span>(<span class="number">5.4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-nodiscard-属性"><a href="#5-3-nodiscard-属性" class="headerlink" title="5.3 [[nodiscard]]属性"></a>5.3 <code>[[nodiscard]]</code>属性</h3><p><code>C++23</code>引入<code>[[nodiscard]]</code>属性, 表示<code>lambda</code>表达式的返回值不能被丢弃:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = [] [[nodiscard]] ()&#123; <span class="keyword">return</span> <span class="number">4</span>; &#125;;</span><br><span class="line"><span class="built_in">lambda</span>(); <span class="comment">// compiler warning</span></span><br><span class="line"><span class="keyword">auto</span> x = <span class="built_in">lambda</span>(); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><h2 id="6-支持更多的工具处理宏"><a href="#6-支持更多的工具处理宏" class="headerlink" title="6 支持更多的工具处理宏"></a>6 支持更多的工具处理宏</h2><h3 id="6-1-更多的预处理宏"><a href="#6-1-更多的预处理宏" class="headerlink" title="6.1 更多的预处理宏"></a>6.1 更多的预处理宏</h3><p><code>c++23</code>引入了如下的预处理宏:</p><table><thead><tr><th align="left">宏</th><th align="right">语义</th></tr></thead><tbody><tr><td align="left"><code>#if defined(MACRO)</code></td><td align="right">和 <code>#ifdef MACRO</code>一致</td></tr><tr><td align="left"><code>#elif defined(MACRO)</code></td><td align="right">和 <code>#elifdef MACRO</code>一致</td></tr><tr><td align="left"><code>#if !defined(MACRO)</code></td><td align="right">和 <code>#ifndef MACRO</code>一致</td></tr><tr><td align="left"><code>#elif !defined(MACRO)</code></td><td align="right">和 <code>#elifndef MACRO</code>一致</td></tr></tbody></table><p><strong>PS:尽量减少宏的使用, 尤其是在头文件中</strong></p><h3 id="6-2-更多处理源码位置宏的工具"><a href="#6-2-更多处理源码位置宏的工具" class="headerlink" title="6.2 更多处理源码位置宏的工具"></a>6.2 更多处理源码位置宏的工具</h3><p>首先先回顾源码位置相关的宏:</p><table><thead><tr><th>宏</th><th>描述</th><th>示例</th><th>备注</th></tr></thead><tbody><tr><td><code>__FILE__</code></td><td>当前源文件的名称。</td><td><code>&quot;main.cpp&quot;</code></td><td></td></tr><tr><td><code>__LINE__</code></td><td>当前源代码的行号。</td><td><code>42</code></td><td></td></tr><tr><td><code>__func__</code></td><td>当前函数的名称。</td><td><code>&quot;main&quot;</code></td><td></td></tr><tr><td><code>__PRETTY_FUNCTION__</code></td><td>当前函数的装饰过的名称，通常包括返回类型和参数类型。</td><td><code>&quot;int main(int, char**)&quot;</code></td><td>GCC特有的扩展，在标准C++中并不保证可用</td></tr></tbody></table><p>下面给出相关宏的一个代码示例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string &amp;message)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;File:&quot;</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">&quot;, Line:&quot;</span> &lt;&lt; __LINE__</span><br><span class="line">            &lt;&lt; <span class="string">&quot;, func:&quot;</span> &lt;&lt; __func__</span><br><span class="line">            &lt;&lt; <span class="string">&quot;, PRETTY_FUNCTION:&quot;</span> &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="built_in">log</span>(<span class="string">&quot;Hello, World!&quot;</span>); &#125;</span><br></pre></td></tr></table></figure><p><code>C++20</code>引入了一个新的工具<code>std::source_location</code>，提供了一种类型安全的方式来获取源代码位置的信息，而不需要依赖预处理器宏。<code>std::source_location</code>可以捕获调用点的文件名、行号、列号和函数名等信息，使得源代码位置的处理更加灵活和方便:</p><h3 id="6-3-测试宏"><a href="#6-3-测试宏" class="headerlink" title="6.3 测试宏"></a>6.3 测试宏</h3><p><code>C++17</code>提供了<code>__has_include</code>判断头文件是否存在, <code>C++20</code>提供了<code>__cpp_*</code>判断是否支持指定的特性:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __has_include(<span class="string">&lt;iostream&gt;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cpp_constexpr</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="6-4-错误警告"><a href="#6-4-错误警告" class="headerlink" title="6.4 错误警告"></a>6.4 错误警告</h3><p><code>C++23</code>引入了 <code>#warning &quot;text&quot;</code>用于在编译时发出用户自定义的警告:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELFWARN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(SELFWARN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">warning</span> <span class="string">&quot;自定义警告&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前一直在准备暑期实习的笔试和面试, 因此博客断更了很久…回头做6.5840发现自己的代码逻辑都快忘了…&lt;/p&gt;
&lt;p&gt;先整理下实习求职过程中学习的C++的新特性, 由于C++11已经使用得很广泛了, 包括智能指针、各种转换运算符、lambda表达式已经成为面试常见考点了，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++新特性梳理01</title>
    <link href="http://example.com/2024/05/04/C++/C++%E6%96%B0%E7%89%B9%E6%80%A7%E6%A2%B3%E7%90%8601/"/>
    <id>http://example.com/2024/05/04/C++/C++%E6%96%B0%E7%89%B9%E6%80%A7%E6%A2%B3%E7%90%8601/</id>
    <published>2024-05-04T03:18:31.000Z</published>
    <updated>2024-10-03T17:47:36.137Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直在准备暑期实习的笔试和面试, 因此博客断更了很久…回头做6.5840发现自己的代码逻辑都快忘了…</p><p>先整理下实习求职过程中学习的C++的新特性, 由于C++11已经使用得很广泛了, 包括智能指针、各种转换运算符、lambda表达式已经成为面试常见考点了，这里我就不提这些了，因此我只梳理从C++17开始的知识点，包括C++17、C++20、C++23和少量C++26。</p><p><del>之前断更的6.5840的最后一个lab4B也会补上</del></p><h2 id="1-auto作为函数形参"><a href="#1-auto作为函数形参" class="headerlink" title="1 auto作为函数形参"></a>1 auto作为函数形参</h2><p>C++20 中允许在函数声明中直接使用 <code>auto</code> 作为参数类型，这其实是一种简化模板函数定义的语法糖。该 <code>auto</code> 的使用方式类似于模板函数，但语法更为简洁。</p><ul><li>原始的函数模板实现<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>auto</code>作为形参的实现<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="keyword">auto</span> x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当编译器遇到一个使用 <code>auto</code> 作为参数类型的函数定义时，它会将这个函数视为一个模板函数。编译器内部的处理过程如下：</p><ol><li><p><strong>模板化</strong>：编译器将 <code>auto</code> 参数的函数自动转换为模板函数。上述 <code>void f(auto x)</code> 实际上被编译器转换为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>T</code> 是由编译器自动生成的一个模板参数。</p></li><li><p><strong>类型推导</strong>：当这个函数被调用时，编译器将根据传入的实参推导出 <code>T</code> 的具体类型。</p></li></ol><h2 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2 &lt;=&gt;运算符"></a>2 <code>&lt;=&gt;</code>运算符</h2><p>C++20 引入的了新的比较运算符<code>&lt;=&gt;</code>, 该运算符允许在一个表达式中执行多态的、全面的比较，并根据比较结果返回一个可传递到<code>std::strong_ordering</code>、<code>std::weak_ordering</code>或<code>std::partial_ordering</code>枚举类型的值, 其比较逻辑如下:。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &lt;=&gt; b</span><br></pre></td></tr></table></figure><p>比较左右两边的操作数<code>a</code>和<code>b</code>，并可能返回以下三个值之一：</p><ol><li><p><code>std::strong_ordering</code>:</p><ul><li><code>std::strong_ordering::less</code>：如果<code>a</code>严格小于<code>b</code>。</li><li><code>std::strong_ordering::equal</code>：如果<code>a</code>等于<code>b</code>。</li><li><code>std::strong_ordering::greater</code>：如果<code>a</code>严格大于<code>b</code>。</li></ul></li><li><p><code>std::weak_ordering</code>（适用于无法提供强排序的对象，比如浮点数NaN）：</p><ul><li><code>std::weak_ordering::less</code></li><li><code>std::weak_ordering::equivalent</code>（不同于等于，可能涉及NaN的比较）</li><li><code>std::weak_ordering::greater</code></li></ul></li><li><p><code>std::partial_ordering</code>（用于那些只在部分情况下可以比较的对象）：</p><ul><li><code>std::partial_ordering::less</code></li><li><code>std::partial_ordering::equivalent</code></li><li><code>std::partial_ordering::greater</code></li><li><code>std::partial_ordering::unordered</code>（表示两个操作数不可比较）</li></ul></li></ol><p>简而言之, <code>&lt;=&gt;</code>使得单一的运算符具备处理所有比较的情况的能力。其重载方式也类似其他如<code>=</code>的运算符:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> MyClass&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// 根据类的成员或某种逻辑来比较两个对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/* some condition */</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::strong_ordering::less;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/* equality condition */</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::strong_ordering::equal;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> std::strong_ordering::greater;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-枚举优化"><a href="#3-枚举优化" class="headerlink" title="3 枚举优化"></a>3 枚举优化</h2><h3 id="3-1-支持特性的枚举"><a href="#3-1-支持特性的枚举" class="headerlink" title="3.1 支持特性的枚举"></a>3.1 支持特性的枚举</h3><p><code>C++17</code> 支持对枚举成员进行特性声明:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE [[deprecated]] &#125;;</span><br><span class="line"><span class="keyword">auto</span> x = Color::BLUE; <span class="comment">// compiler warning</span></span><br></pre></td></tr></table></figure><h3 id="3-2-switch中枚举的优化"><a href="#3-2-switch中枚举的优化" class="headerlink" title="3.2 switch中枚举的优化"></a>3.2 switch中枚举的优化</h3><p><code>C++20</code>在<code>switch</code>枚举使做出了优化, 可以通过<code>using ...</code>的方式简化枚举类型的声明:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11 enum/enum class allows setting the underlying type</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> : <span class="type">int</span> &#123; RED, GREEN, BLUE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++20 allows introducing the enumerator identiﬁers</span></span><br><span class="line"><span class="comment">// into the local scope todecrease the verbosity</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printColor</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">enum</span> <span class="title class_">Color</span>;</span><br><span class="line">  <span class="keyword">case</span> RED:</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;RED\n&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> GREEN:</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;GREEN\n&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> BLUE:</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;BLUE\n&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-更方便的流程控制"><a href="#4-更方便的流程控制" class="headerlink" title="4 更方便的流程控制"></a>4 更方便的流程控制</h2><h3 id="4-1-条件判断前的初始化"><a href="#4-1-条件判断前的初始化" class="headerlink" title="4.1 条件判断前的初始化"></a>4.1 条件判断前的初始化</h3><p><code>C++17</code>允许在<code>if</code>和<code>switch</code>前进行变量的初始化(类似<code>golang</code>的语法):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// C++17 introduces if statement with initializer</span></span><br><span class="line">  <span class="type">int</span> x = <span class="number">3</span>, y = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="type">int</span> ret = x + y; ret &lt; <span class="number">10</span>)</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// C++17 introduces switch statement with initializer</span></span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">auto</span> i = <span class="built_in">f</span>(); x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    cout &lt;&lt; i + x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-指定迭代范围的for循环"><a href="#4-2-指定迭代范围的for循环" class="headerlink" title="4.2 指定迭代范围的for循环"></a>4.2 指定迭代范围的for循环</h3><p>C++20引入了指定范围的<code>for</code>循环语法, 其支持自定义的初始化列表:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// C++20 introduces range-for loop statement with initializer</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; <span class="keyword">auto</span> x : &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;) &#123;</span><br><span class="line">    cout &lt;&lt; i++ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-安全的联合体variant"><a href="#5-安全的联合体variant" class="headerlink" title="5 安全的联合体variant"></a>5 安全的联合体variant</h2><p><code>C++17 </code>引入了一个 <code>std::variant</code> 提供类型安全的联合体（Type-Safe Union）。<code>std::variant</code> 是一个模板类，它可以存储一组预定义的不同类型的数据，但是在任何时候仅能存储其中的一种类型，类似于传统的 C 语言中的 <code>union</code>，但它带有现代 C++ 的类型安全保证。</p><p><code>std::variant</code> 提供了多种工具来管理和访问存储的值，例如：</p><ul><li><code>index()</code> 函数用于返回当前存储类型的索引。</li><li><code>holds_alternative&lt;SomeType&gt;()</code> 用于检查当前存储的值是否为特定类型。</li><li><code>get&lt;T&gt;()</code> 或 <code>get_if&lt;T&gt;()</code> 方法用于访问存储的值；若试图访问错误的类型，则 <code>get()</code> 将抛出 <code>std::bad_variant_access</code> 异常，而 <code>get_if()</code> 则返回一个指向相应类型值的指针（若不匹配则返回 <code>nullptr</code>）。</li></ul><p>案例代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个 variant 类型，可以存储 int 和 std::string</span></span><br><span class="line">    std::variant&lt;<span class="type">int</span>, std::string&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化为 int 类型</span></span><br><span class="line">    v = <span class="number">42</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v contains: &quot;</span>; </span><br><span class="line">    <span class="comment">// 使用 std::visit 处理不同类型的值</span></span><br><span class="line">    std::<span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; arg) &#123; std::cout &lt;&lt; arg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;, v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变 v 的内容为 string 类型</span></span><br><span class="line">    v = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v now contains: &quot;</span>;</span><br><span class="line">    std::<span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; arg) &#123; std::cout &lt;&lt; arg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;, v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查并安全访问 variant 中的值</span></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;std::string&gt;(v)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The string in v is: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(v) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 错误的访问尝试：尝试获取 int 类型，但 v 现在存储的是 string 类型</span></span><br><span class="line">        <span class="comment">// 这将会抛出 std::bad_variant_access 异常</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The int in v is: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(v) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_variant_access&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Tried to access the wrong type in the variant: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-避免unused-warning"><a href="#6-避免unused-warning" class="headerlink" title="6 避免unused warning"></a>6 避免<code>unused warning</code></h2><p><code>C++17</code>和<code>C++26</code>引入了更优雅的避免<code>unused warning</code>的手段:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">static_cast</span>&lt;<span class="type">void</span>&gt;(a);       <span class="comment">// C++17 以前的方式</span></span><br><span class="line">  [[maybe_unused]] <span class="type">int</span> x = <span class="number">5</span>; <span class="comment">// C++17</span></span><br><span class="line">  <span class="keyword">auto</span> _ = <span class="number">3</span>;                 <span class="comment">// C++26</span></span><br><span class="line">  cout &lt;&lt; _ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前一直在准备暑期实习的笔试和面试, 因此博客断更了很久…回头做6.5840发现自己的代码逻辑都快忘了…&lt;/p&gt;
&lt;p&gt;先整理下实习求职过程中学习的C++的新特性, 由于C++11已经使用得很广泛了, 包括智能指针、各种转换运算符、lambda表达式已经成为面试常见考点了，</summary>
      
    
    
    
    <category term="C++随笔" scheme="http://example.com/categories/C-%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="面经" scheme="http://example.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="C++17" scheme="http://example.com/tags/C-17/"/>
    
    <category term="C++20" scheme="http://example.com/tags/C-20/"/>
    
    <category term="C++23" scheme="http://example.com/tags/C-23/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.5840(6.824) Lab4: 分片KV数据库 4A</title>
    <link href="http://example.com/2024/03/03/MIT6.5840/lab4A/"/>
    <id>http://example.com/2024/03/03/MIT6.5840/lab4A/</id>
    <published>2024-03-03T02:10:46.000Z</published>
    <updated>2024-10-03T17:47:36.142Z</updated>
    
    <content type="html"><![CDATA[<p><em>最新的更新在博客 <a href="https://tonixwd.github.io/">ToniBlog</a></em></p><p>本文将介绍<code>lab4A</code>部分的实现, <code>lab4A</code>要求实现分片控制器, 其实就是<code>lab3</code>的翻版, 基本上可以照搬<code>lab3</code>。如果仅仅是为了通过测试，<code>lab4A</code>倒是极其简单，只需要每次更新<code>Group</code>后随机完成<code>Shard</code>的映射就好了, 但还要考虑将配置项的改动最小话, 还是有一些坑的。</p><p><code>Lab</code>文档见: <a href="http://nil.csail.mit.edu/6.5840/2023/labs/lab-shard.html">http://nil.csail.mit.edu/6.5840/2023/labs/lab-shard.html</a></p><p>我的代码: <a href="https://github.com/ToniXWD/MIT6.5840/tree/lab4A">https://github.com/ToniXWD/MIT6.5840/tree/lab4A</a></p><h1 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1 项目结构"></a>1 项目结构</h1><p>分片数据库的组成结构是：1个<code>controller</code> + 多个<code>replica groups</code>。<code>controller</code>将数据进行分片， 存储在不同的集群上， 每个集群都是一个<code>raft</code>集群, <code>controller</code>负责管理分片, 也就是管理配置项。<code>clients</code> 和 <code>servers</code> 都会询问 <code>controller</code> 最新的配置信息。 分片控制器需要具备如下的功能:</p><ol><li>为了负载均衡 -&gt; 能够迁移分片</li><li>需要处理请求和配置项更新几乎同时到达的情况</li><li>建议的实现: <code>raft</code>集群也要保存配置项</li><li>配置更新后, 新的负责某分片的<code>replica groups</code>需要从旧的<code>replica groups</code>复制旧分片</li></ol><p><code>Shard controller</code>使用下面的<code>RPC</code>来实现管理和查询:</p><ol><li><code>Join</code>:<ol><li>重新分片时尽量平均</li><li>重新分片时移动的分片尽量少</li><li>允许重用<code>GID</code></li></ol></li><li><code>Leave</code><ol><li>重新分片时尽量平均</li><li>重新分片时移动的分片尽量少</li></ol></li><li><code>Move</code><ol><li>将某个<code>shard</code>分配给某个<code>group</code></li></ol></li><li><code>Query</code> <ol><li>返回配置信息</li><li>必须反映在其之前做出的配置信息更改</li></ol></li></ol><p>主要的坑包括:</p><ol><li>需要滤除重复的<code>RPC</code>(照抄<code>lab3</code>即可)</li><li>执行碎片再平衡的状态机中的代码需要具有确定性(大坑)</li></ol><h1 id="2-实现思路"><a href="#2-实现思路" class="headerlink" title="2 实现思路"></a>2 实现思路</h1><p>由于我们的目标不仅仅是通过测例, 还需要完成下面2个目标:</p><ol><li>实现负载均衡<br> 实现负载均衡, 意味着所有的集群被映射的数量只差不能大于1(手动<code>Move</code>的情况除外), 因此需要对已经映射的集群号(<code>gid</code>)实现统计计数</li><li>最小化改动<br>新配置和旧配置之间的改动要最小化</li></ol><p>因此我的实现思路和逻辑如下:</p><h2 id="2-1-Join"><a href="#2-1-Join" class="headerlink" title="2.1 Join"></a>2.1 <code>Join</code></h2><ol><li>首先继承旧配置<code>lastConfig</code>创建新配置<code>newConfig</code></li><li>将要<code>Join</code>的<code>newGroups</code>追加到<code>newConfig.Groups</code>, 但需要注意下面的情况<ol><li><code>len(lastConfig.Groups) + len(newGroups) &lt;= NShards</code>, 此时无脑将<code>Join</code>的<code>newGroups</code>追加到<code>newConfig.Groups</code>即可</li><li><code>len(lastConfig.Groups) + len(newGroups) &gt; NShards</code>, 此时只需要将<code>newConfig.Groups</code>填充至<code>len(newConfig.Groups) == NShards</code>即可, 剩余的部分缓存起来, 记缓存区为<code>CachedGid</code></li></ol></li><li>统计<code>newConfig.Groups</code>中对<code>Shard</code>的映射次数, 映射次数最高的和映射次数最低的绝对值不能大于1, 由于新增了目前没有映射的<code>Join</code>的新集群, 此特性不可能满足, 因此需要:<ol><li>将目前对<code>Shard</code>的映射次数最少的<code>gid</code>剥夺一个映射, 被剥夺的这个映射本来是被映射到拥有<code>Shard</code>最多的一个<code>gid</code></li><li>更新映射次数统计信息, 直到映射次数最少的<code>gid</code>(也就是之前新加入的)大于等于映射平均值(<code>NShards / len(newConfig.Groups)</code>)即可</li></ol></li></ol><h2 id="2-2-Leave"><a href="#2-2-Leave" class="headerlink" title="2.2 Leave"></a>2.2 <code>Leave</code></h2><ol><li>首先继承旧配置<code>lastConfig</code>创建新配置<code>newConfig</code></li><li>从<code>newConfig.Groups</code>和<code>newConfig.CachedGid</code>中移除指定的<code>gid</code>(因为可能目前所有的<code>gid</code>数量大于<code>NShards</code>, 部分被暂存到了<code>CachedGid</code>), 被移除的<code>gid</code>在<code>newConfig.Shards</code>用0标记</li><li>如果<code>newConfig.CachedGid</code>还有剩余且<code>len(newConfig.Groups) &lt; NShards</code>, 将<code>newConfig.CachedGid</code>中的<code>gid</code>移动到<code>newConfig.Groups</code>使其填充满或者使<code>newConfig.CachedGid</code>为空</li><li>获取当前映射数量最少的<code>gid</code>的统计信息</li><li>在<code>newConfig.Shards</code>用0标记的位置用映射数量最少的<code>gid</code>代替, 每代替一次后需要重新统计</li></ol><h2 id="2-3-Move-Query"><a href="#2-3-Move-Query" class="headerlink" title="2.3 Move &amp;&amp; Query"></a>2.3 <code>Move &amp;&amp; Query</code></h2><p>这两个没啥坑, 就不说了</p><h1 id="3-易错点解析"><a href="#3-易错点解析" class="headerlink" title="3 易错点解析"></a>3 易错点解析</h1><ol><li><code>Go</code>的<code>map</code>的迭代顺序<br><code>Go</code>的<code>map</code>的迭代顺序是无序的, 即使其插入时的顺序和数据都是相同的, 但多次进行迭代, 其顺序不一致, 因此在多个副本上想保证确定性的话, 需要先对<code>map</code>的<code>key</code>获取切片并排序</li><li><code>gid</code>的数量和<code>NShards</code>的关系<br>由于每个<code>Shard</code>都会映射一个<code>gid</code>, 因此如果<code>gid</code>的数量大于<code>NShard</code>的话, 会存在有<code>gid</code>映射不到的情况, 这时我的处理是将其放到暂存区, 保证<code>Group</code>中的<code>gid</code>数量</li><li><code>map</code>的复制<br><code>Go</code>的<code>map</code>的复制是浅复制, 复制一个<code>map</code>时，只是复制了对底层数据结构的引用，而不是底层数据本身的副本。意味着如果在一个<code>map</code>中做出了改变（比如删除或添加键值对），这些改变会在所有对这个底层数据结构的引用中体现出来。因此，对原始<code>map</code>的修改会影响到复制后的<code>map</code>，因为它们都引用同一个数据结构。</li></ol><h1 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4 代码实现"></a>4 代码实现</h1><p>我自己实现的代码比较繁琐(很丑), 但逻辑其实很简单, 参见: <a href="https://github.com/ToniXWD/MIT6.5840/tree/lab4A">https://github.com/ToniXWD/MIT6.5840/tree/lab4A</a></p><h1 id="5-测试"><a href="#5-测试" class="headerlink" title="5 测试"></a>5 测试</h1><p><img src="/../../images/MIT6.5840/lab4A/lab4A-test.png" alt="lab4A-test"></p><p>此测试经过50次没有报错</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;最新的更新在博客 &lt;a href=&quot;https://tonixwd.github.io/&quot;&gt;ToniBlog&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;本文将介绍&lt;code&gt;lab4A&lt;/code&gt;部分的实现, &lt;code&gt;lab4A&lt;/code&gt;要求实现分片控制器, 其实就</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="Lab笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/Lab%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Go" scheme="http://example.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>清华大学开源操作系统训练营: rCore chapter4练习</title>
    <link href="http://example.com/2024/02/28/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/rCore-chapter4%E7%BB%83%E4%B9%A0/"/>
    <id>http://example.com/2024/02/28/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/rCore-chapter4%E7%BB%83%E4%B9%A0/</id>
    <published>2024-02-28T06:03:30.000Z</published>
    <updated>2024-10-03T17:47:36.145Z</updated>
    
    <content type="html"><![CDATA[<p><strong>练习实验书</strong>: <a href="https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter4/7exercise.html">https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter4/7exercise.html</a></p><p><strong>我的代码</strong>: <a href="https://github.com/LearningOS/2023a-rcore-ToniXWD">https://github.com/LearningOS/2023a-rcore-ToniXWD</a></p><h1 id="1-编程作业"><a href="#1-编程作业" class="headerlink" title="1 编程作业"></a>1 编程作业</h1><blockquote><blockquote><ol><li>重写 <code>sys_get_time</code> 和 <code>sys_task_info</code></li><li>实现 <code>mmap</code> 和 <code>munmap</code> 两个系统调用，通过所有测例</li></ol></blockquote></blockquote><h2 id="1-1-重写-sys-get-time-和-sys-task-info"><a href="#1-1-重写-sys-get-time-和-sys-task-info" class="headerlink" title="1.1 重写 sys_get_time 和 sys_task_info"></a>1.1 重写 <code>sys_get_time</code> 和 <code>sys_task_info</code></h2><p>这一部分的实现很简单, 引入虚拟内存和页表后无非就是内核无法直接使用系统调用传递的地址了, 需要将这个用户空间的虚拟地址做一层手动翻译, 这样的方法已经为我们提供了: <code>translated_struct_ptr</code>, 因此实现很简单:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_get_time</span>(_ts: *<span class="keyword">mut</span> TimeVal, _tz: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    trace!(<span class="string">&quot;kernel: sys_get_time&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">us</span> = <span class="title function_ invoke__">get_time_us</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ts</span> = <span class="title function_ invoke__">translated_struct_ptr</span>(<span class="title function_ invoke__">current_user_token</span>(), _ts);</span><br><span class="line">    *ts = TimeVal &#123;</span><br><span class="line">        sec: us / <span class="number">1_000_000</span>,</span><br><span class="line">        usec: us % <span class="number">1_000_000</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_task_info</span>(_ti: *<span class="keyword">mut</span> TaskInfo) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    trace!(<span class="string">&quot;kernel: sys_task_info NOT IMPLEMENTED YET!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ti</span> = <span class="title function_ invoke__">translated_struct_ptr</span>(<span class="title function_ invoke__">current_user_token</span>(), _ti);</span><br><span class="line"></span><br><span class="line">    *ti = TaskInfo &#123;</span><br><span class="line">        status: TaskStatus::Running,</span><br><span class="line">        syscall_times: <span class="title function_ invoke__">get_sys_call_times</span>(),</span><br><span class="line">        time: <span class="title function_ invoke__">get_task_run_times</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-实现-mmap-和-munmap"><a href="#1-2-实现-mmap-和-munmap" class="headerlink" title="1.2 实现 mmap 和 munmap"></a>1.2 实现 <code>mmap</code> 和 <code>munmap</code></h2><blockquote><blockquote><p><code>mmap</code> 在 <code>Linux</code> 中主要用于在内存中映射文件， 本次实验简化它的功能，仅用于申请内存</p></blockquote></blockquote><h3 id="1-2-1-MemorySet结构体"><a href="#1-2-1-MemorySet结构体" class="headerlink" title="1.2.1 MemorySet结构体"></a>1.2.1 <code>MemorySet</code>结构体</h3><p>由于<code>mmap</code>要在地址空间中添加新的映射, 因此无非就是在<code>MemorySet</code>中添加一块映射的内存区域, 先看看每个内存地址空间本来的结构:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// address space</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MemorySet</span> &#123;</span><br><span class="line">    page_table: PageTable,</span><br><span class="line">    areas: <span class="type">Vec</span>&lt;MapArea&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>areas</code>存放的是本地址空间的多个逻辑段, 每个逻辑段的地址是连续的, 但<code>mmap</code>是动态申请地址空间的, 多次调用会创建多哥不连续的内存区域, 因此不适合存放在<code>areas</code>, 因此创建一个新的成员存放:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// address space</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MemorySet</span> &#123;</span><br><span class="line">    page_table: PageTable,</span><br><span class="line">    areas: <span class="type">Vec</span>&lt;MapArea&gt;,</span><br><span class="line">    map_tree: BTreeMap&lt;VirtPageNum, FrameTracker&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>map_tree</code>还是<code>RAII</code>的思想, <code>munmap</code>调用时, 会将页帧从<code>map_tree</code>中释放, 触发<code>drop trait</code>使内存页分配器回收内存页</p><h3 id="1-2-2-MemorySet-mmap-MemorySet-unmmap"><a href="#1-2-2-MemorySet-mmap-MemorySet-unmmap" class="headerlink" title="1.2.2 MemorySet::mmap &amp;&amp; MemorySet::unmmap"></a>1.2.2 <code>MemorySet::mmap</code> &amp;&amp; <code>MemorySet::unmmap</code></h3><p>有了上述的数据结构, <code>mmap</code>时只需要调用<code>frame_alloc</code>分配一个新的内存页即可:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"><span class="comment">/// mmap</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mmap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, start: <span class="type">usize</span>, len: <span class="type">usize</span>, port: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">va_start</span>: VirtAddr = start.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="keyword">if</span> !va_start.<span class="title function_ invoke__">aligned</span>() &#123;</span><br><span class="line">        debug!(<span class="string">&quot;unmap fail don&#x27;t aligned&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">va_start</span>: VirtPageNum = va_start.<span class="title function_ invoke__">into</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">flags</span> = PTEFlags::<span class="title function_ invoke__">from_bits</span>(port <span class="keyword">as</span> <span class="type">u8</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">if</span> port &amp; <span class="number">0b0000_0001</span> != <span class="number">0</span> &#123;</span><br><span class="line">        flags |= PTEFlags::R;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> port &amp; <span class="number">0b0000_0010</span> != <span class="number">0</span> &#123;</span><br><span class="line">        flags |= PTEFlags::W;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> port &amp; <span class="number">0b0000_0100</span> != <span class="number">0</span> &#123;</span><br><span class="line">        flags |= PTEFlags::X;</span><br><span class="line">    &#125;</span><br><span class="line">    flags |= PTEFlags::U;</span><br><span class="line">    flags |= PTEFlags::V;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">va_end</span>: VirtAddr = (start + len).<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">va_end</span>: VirtPageNum = va_end.<span class="title function_ invoke__">ceil</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// println!(</span></span><br><span class="line">    <span class="comment">//     &quot;start = &#123;:x&#125; &amp;&amp; va_star = &#123;&#125; &amp;&amp; va_end = &#123;&#125;&quot;,</span></span><br><span class="line">    <span class="comment">//     start, va_start.0, va_end.0</span></span><br><span class="line">    <span class="comment">// );</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> va_start != va_end &#123;</span><br><span class="line">        <span class="comment">// println!(&quot;map va_start = &#123;&#125;&quot;, va_start.0);</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(pte) = <span class="keyword">self</span>.page_table.<span class="title function_ invoke__">translate</span>(va_start) &#123;</span><br><span class="line">            <span class="keyword">if</span> pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">                <span class="comment">// println!(&quot;mmap found exit va_start &#123;&#125;&quot;, va_start.0);</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(ppn) = <span class="title function_ invoke__">frame_alloc</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.page_table.<span class="title function_ invoke__">map</span>(va_start, ppn.ppn, flags);</span><br><span class="line">            <span class="keyword">self</span>.map_tree.<span class="title function_ invoke__">insert</span>(va_start, ppn);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        va_start.<span class="title function_ invoke__">step</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unmmap</code>则更简单, 从<code>map_tree</code>中删除即可, 这会自动触发<code>drop trait</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"><span class="comment">/// unmap</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmmap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, start: <span class="type">usize</span>, len: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">va_start</span>: VirtAddr = start.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="keyword">if</span> !va_start.<span class="title function_ invoke__">aligned</span>() &#123;</span><br><span class="line">        debug!(<span class="string">&quot;unmap fail don&#x27;t aligned&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">va_start</span>: VirtPageNum = va_start.<span class="title function_ invoke__">into</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">va_end</span>: VirtAddr = (start + len).<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">va_end</span>: VirtPageNum = va_end.<span class="title function_ invoke__">ceil</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> va_start != va_end &#123;</span><br><span class="line">        <span class="comment">// println!(&quot;unmap va_start = &#123;&#125;&quot;, va_start.0);</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(item) = <span class="keyword">self</span>.page_table.<span class="title function_ invoke__">translate</span>(va_start) &#123;</span><br><span class="line">            <span class="keyword">if</span> !item.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">                debug!(<span class="string">&quot;unmap on no map vpn&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.page_table.<span class="title function_ invoke__">unmap</span>(va_start);</span><br><span class="line">        <span class="keyword">self</span>.map_tree.<span class="title function_ invoke__">remove</span>(&amp;va_start);</span><br><span class="line">        va_start.<span class="title function_ invoke__">step</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-简答作业"><a href="#2-简答作业" class="headerlink" title="2 简答作业"></a>2 简答作业</h1><h2 id="2-1-请列举-SV39-页表页表项的组成，描述其中的标志位有何作用？"><a href="#2-1-请列举-SV39-页表页表项的组成，描述其中的标志位有何作用？" class="headerlink" title="2.1 请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？"></a>2.1 请列举 <code>SV39</code> 页表页表项的组成，描述其中的标志位有何作用？</h2><p><img src="/../../../images/LearningOS/ch4-translate.png" alt="ch4-translate"></p><p>如上图所示, 每个页表项是<code>PPN</code> + <code>Flags</code>组成, <code>PPN</code>指向下一级页表的物理页地址, <code>Flags</code>为各种标志位:</p><ul><li><strong>V</strong>: 页表项是否有效</li><li><strong>R&#x2F;W&#x2F;X</strong>: 控制对应页是否具有读、写、执行权限。这些权限位为操作系统实现内存保护提供了机制。</li><li><strong>U</strong>: 控制页的访问级别，标明用户空间是否可以访问。</li><li><strong>G</strong>: 全局位用于性能优化，它允许某些页表项在多个上下文之间共享，减少TLB刷新。</li><li><strong>A&#x2F;D</strong>: 访问和脏位用于页面替换策略，帮助操作系统确定哪些页面是活跃的，哪些页面可以被换出内存。</li><li><strong>RSW</strong>: 保留位， 留给自定义的实现， 常用于实现<strong>COW</strong>写时复制，用于实现<code>fork</code>系统调用时的内存效率优化。</li></ul><h2 id="2-2-缺页"><a href="#2-2-缺页" class="headerlink" title="2.2 缺页"></a>2.2 <strong>缺页</strong></h2><p>缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断， 告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程</p><h3 id="2-2-1-请问哪些异常可能是缺页导致的？"><a href="#2-2-1-请问哪些异常可能是缺页导致的？" class="headerlink" title="2.2.1 请问哪些异常可能是缺页导致的？"></a>2.2.1 请问哪些异常可能是缺页导致的？</h3><ul><li>访问了一个没有映射的虚拟地址。</li><li>访问了映射了虚拟地址但尚未加载到物理内存的页面。</li><li>访问违反了权限的页面，如对只读页面进行写操作。</li></ul><h3 id="2-2-2-发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。"><a href="#2-2-2-发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。" class="headerlink" title="2.2.2 发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。"></a>2.2.2 发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。</h3><ul><li><strong>PC (Program Counter)</strong>: 保存发生异常指令的地址。</li><li><strong>stval&#x2F;utval (Store&#x2F;Trap Value Register)</strong>: 保存造成异常的虚拟地址。</li><li><strong>satp (Supervisor Address Translation and Protection Register)</strong>: 包含页表的基址和一些控制位，用于地址转换。</li></ul><h3 id="2-2-3-Lazy"><a href="#2-2-3-Lazy" class="headerlink" title="2.2.3 Lazy"></a>2.2.3 <code>Lazy</code></h3><p>缺页有两个常见的原因，其一是 <code>Lazy</code> 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 <code>os</code> 并不会马上这样做， 而是会保存 .<code>text</code> 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。<br>这样做有哪些好处？</p><ul><li>减少了初始化时的加载时间，加快了程序启动速度。</li><li>仅加载实际使用的内存页面，节省了物理内存资源。</li><li>避免了不必要的I&#x2F;O操作，提高了系统整体性能。</li></ul><h3 id="2-2-4-估算页表内存消耗"><a href="#2-2-4-估算页表内存消耗" class="headerlink" title="2.2.4 估算页表内存消耗"></a>2.2.4 估算页表内存消耗</h3><p>其实，我们的 <code>mmap</code> 也可以采取 <code>Lazy</code> 策略，比如：一个用户进程先后申请了 10G 的内存空间， 然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。<br>处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？</p><ol><li>每个页表项占用8字节，对于10G内存：</li><li>一级页表（PTEs）: <code>10G / 4K</code>（每页大小）&#x3D; <code>2560K</code> 页表项 &#x3D; <code>2560K * 8</code> 字节。</li><li>二级页表（PTEs）: <code>2560K / 512</code>（每级页表条目数）&#x3D; <code>5K</code> 页表项 &#x3D; <code>5K * 8</code> 字节。</li><li>三级页表（PTEs）: <code>5K / 512</code> &#x3D; <code>10</code> 页表项 &#x3D; <code>10 * 8</code> 字节。</li><li>总计约为<code>2560K * 8</code>字节 加上较小的二级和三级页表大小，数量级在几 M 字节。</li></ol><h3 id="2-2-5-实现Lazy"><a href="#2-2-5-实现Lazy" class="headerlink" title="2.2.5 实现Lazy"></a>2.2.5 实现<code>Lazy</code></h3><p>请简单思考如何才能实现 <code>Lazy</code> 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。</p><ul><li>在进程开始时，只为虚拟地址空间分配页表结构，不分配实际的物理页面。</li><li>页面第一次被访问时，通过缺页中断处理函数分配物理页面，并更新页表项。</li><li>缺页处理时，查找磁盘上相应的数据（如果之前已经映射），然后加载到内存中。</li></ul><h3 id="2-2-6-Swap"><a href="#2-2-6-Swap" class="headerlink" title="2.2.6 Swap"></a>2.2.6 <code>Swap</code></h3><p>缺页的另一个常见原因是 <code>swap</code> 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。<br>此时页面失效如何表现在页表项(PTE)上？</p><ul><li>有效位(<code>V</code>): 如果页面被换出到磁盘，页表项的有效位会被清除。</li><li>使用<code>RSW</code>位来存储额外的状态信息，区分真正的无效的页表项和被换到磁盘上的页表项</li></ul><h2 id="2-3-双页表与单页表"><a href="#2-3-双页表与单页表" class="headerlink" title="2.3 双页表与单页表"></a>2.3 双页表与单页表</h2><p>为了防范侧信道攻击，我们的 <code>o</code>s 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单&#x2F;双的说法仅为自创的通俗说法，并无这个名词概念，详情见 <a href="https://en.wikipedia.org/wiki/Kernel_page-table_isolation"><code>KPTI</code></a> )</p><ol><li><p>在单页表情况下，如何更换页表？<br>单页表不需要切换, 因为页表已经包含了用户空间和内核空间的映射。但是，当切换进程时，需要更换页表以加载新进程的地址空间。通过更新 <code>satp</code>寄存器来完成，这个寄存器包含了当前活动页表的物理地址。</p></li><li><p>单页表情况下，如何控制用户态无法访问内核页面？<br>内核页表的页表项不设置<code>U</code>位即可</p></li><li><p>单页表有何优势？<br>陷入内核时不需要切换页表, 同时仍然可以用硬件完成地址翻译, 效率更高</p></li><li><p>双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？</p><ol><li>双页表实现下，上下文切换和陷入内核都需要切换页表</li><li>单页表实现下, 切换不同的进程时才需要切换页表</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;练习实验书&lt;/strong&gt;: &lt;a href=&quot;https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter4/7exercise.html&quot;&gt;https://learningos.cn/rCore-Tu</summary>
      
    
    
    
    <category term="训练营笔记" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
    
    <category term="清华大学开源操作系统训练营2023" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A52023/"/>
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="riscv" scheme="http://example.com/tags/riscv/"/>
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>清华大学开源操作系统训练营: rCore chapter4笔记</title>
    <link href="http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/</id>
    <published>2024-02-20T13:22:29.000Z</published>
    <updated>2024-10-03T17:47:36.144Z</updated>
    
    <content type="html"><![CDATA[<p>本文不会将原本<code>rCore文档</code>的内容重复太多, 主要是补充学习过程中遇到的知识点, 因此还需结合原文使用, 原文在后面的链接中</p><p>这一章引入了页表和虚拟内存。回顾之前构建的<code>OS</code>, 其内核和应用是共用一份地址空间的。这也就意味着， 某个应用程序可以任意访问其他应用程序甚至内核的代码和数据， 这是不安全的， 并且， 编写应用程序的程序员还需要显式地指定链接的地址。因此， 虚拟内存应运而生。同时， 引入虚拟内存后， 还需要重新设计上下文切换和进程控制快, 因此这一章的代码相对复杂。</p><p>本章的内容包括:</p><ol><li>基于<code>SV39</code>引入虚拟内存和页表</li><li>重新设计进程控制块结构体</li><li>重新设计上下文切换</li></ol><p>完整版官方文档： <a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/index.html">https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/index.html</a></p><p>精简版文档： <a href="https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter4/index.html">https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter4/index.html</a></p><h1 id="1-引入虚拟内存"><a href="#1-引入虚拟内存" class="headerlink" title="1 引入虚拟内存"></a>1 引入虚拟内存</h1><h2 id="1-1-虚拟地址空间的概念"><a href="#1-1-虚拟地址空间的概念" class="headerlink" title="1.1 虚拟地址空间的概念"></a>1.1 虚拟地址空间的概念</h2><p>文档中对地址空间的介绍已经很完善了, 这里只做简要总结:</p><p><img src="/../../../images/LearningOS/ch4-address-space.png" alt="ch4-address-space"></p><p>上图摘自官方文档, 根据这个图简单介绍什么是地址空间</p><ol><li>为什么叫<strong>虚拟地址空间</strong>?<br>因为地址不是真正的物理内存地址, 而是需要经过一系列操作映射到物理地址。想象一下， 编写不同C语言程序时，我们的数据可以防止同样的地址中， 但这些不同的应用都可以同时运行，显然他们不是同一个物理地址</li><li>如何转化为<strong>物理地址</strong>？<br>通过硬件单元<code>MMU</code>进行转化, <code>MMU</code>会根据一个映射表查询虚拟地址对应的物理地址, 这个映射表就叫<strong>页表</strong>, 根页表的地址存放在指定的寄存器中, <code>riscv</code>中是<code>satp</code>寄存器</li><li>如何实现隔离<ol><li><code>U</code>表示用户态是否可以访问, <code>U</code>标记实现了内核和应用程序之间的隔离</li><li>每个应用程序有自己的页表, 并且页表项中的<code>V</code>标记位表示页表项是否有效, 不属于应用程序的地址没有设置<code>V</code>标记, 这实现了应用程序间的隔离</li></ol></li></ol><h2 id="1-2-分页管理"><a href="#1-2-分页管理" class="headerlink" title="1.2 分页管理"></a>1.2 分页管理</h2><p>由于地址的数量是近乎无限的, 不可能以每一个地址为粒度进行映射, 因此将<code>4096</code>个字节作为一个映射单位, 这就是<strong>分页</strong>的概念, 除了这个原因外, 分页还有一个好处就是<strong>方便在硬盘和内存之间加载和替换数据</strong>, 因为一次硬盘的<code>IO</code>是昂贵的, 因此一次硬盘的<code>IO</code>应当包含足够大的空间, 通常也就是一个扇区, 大小通常也是<code>4096</code>个字节。</p><blockquote><blockquote><p>目前的<code>rCore</code>没有文件系统, 因此虚拟内存的分页也没有在硬盘和内存中进行加载和替换的功能, 只是实现虚拟内存的抽象罢了</p></blockquote></blockquote><p>虚拟内存中的分页机制可以用一个贴近生活的比喻来理解：假设你有一本非常厚的书（这里的书就像是一个程序需要的内存空间），书架（物理内存）的空间有限，你不能同时把所有的书放在书架上。所以，你决定只把当前正在阅读的几页（活跃的内存页）放在书架上，而把其他的页暂时存放在一个大箱子里（硬盘上的交换空间）。当你想读书中的其他部分时，你会从箱子里取出你需要的页，并把不再需要的页放回箱子里。</p><p><strong>虚拟内存分页机制：</strong></p><ol><li><p><strong>分页的基本概念</strong>：<br>就像上面的比喻中，分页机制将虚拟内存分割成许多固定大小的块，每一块称为一个“页”或“页面”。同样地，物理内存也被分割成同样大小的块，称为“页帧”或“物理页”。</p></li><li><p><strong>页表映射</strong>：<br>为了追踪哪些虚拟页对应于物理内存中的哪些页帧，操作系统维护着一张映射表，这就是所谓的页表。当程序尝试访问其虚拟内存中的数据时，操作系统查看页表来找出那个虚拟页在物理内存中的位置。</p></li><li><p><strong>内存访问</strong>：<br>当程序访问一个虚拟地址时，这个地址被分成两部分：页号和页内偏移。页号用于在页表中查找对应的物理页帧，而页内偏移决定了在这个页帧内的具体位置。</p></li><li><p><strong>缺页中断</strong>：<br>如果程序需要访问的页当前不在物理内存中（也就是说，它在硬盘的交换空间里），这会触发一个叫做缺页中断（page fault）的事件。操作系统随后会选择一个物理页（如果需要，可能会将当前的内容保存到硬盘上），并从硬盘上加载所需的虚拟页到这个物理页中，然后更新页表，并重新开始执行刚才中断的指令。</p></li><li><p><strong>页替换算法</strong>：<br>当物理内存满了，而需要加载新的页时，操作系统必须决定哪些页将被移出物理内存以为新页腾出空间。这涉及到页替换算法，如最近最少使用（LRU）、先进先出（FIFO）等，用于选择被替换的页。</p></li></ol><p>通过这种分页机制，操作系统可以非常高效地管理内存，即使物理内存有限，程序也可以使用比物理内存大得多的地址空间。这样不仅提高了内存的使用效率，也简化了程序员的工作，因为他们不需要关心内存的物理限制，只需要关注于程序的逻辑结构。</p><p>最后贴上官方文档的图:</p><p><img src="/../../../images/LearningOS/ch4-page.png" alt="ch4-page"></p><p>页表中包含3个部分:</p><ol><li>映射的物理页号</li><li>页的操作权限</li></ol><blockquote><blockquote><p>图中的<code>FrameNumber</code>实际上在页表中是没有的</p></blockquote></blockquote><h2 id="1-3-SV39分页介绍"><a href="#1-3-SV39分页介绍" class="headerlink" title="1.3 SV39分页介绍"></a>1.3 <code>SV39</code>分页介绍</h2><p>这里介绍如何实现映射, 这里采用的是<code>riscv</code>的<code>SV39</code>分页机制:</p><p>首先看看虚拟地址和物理地址的格式:</p><p><img src="/../../../images/LearningOS/ch4-vaddr-paddr.png" alt="ch4-vaddr-paddr"></p><ol><li>虚拟地址被分为39位，意味着虚拟地址空间的大小可以达到2<sup>39</sup>字节，即512GB。其中低12位是页内的偏移量, 高27位可以分为3份, 每份9位, 表示的是在各级页表中的索引(如果看不懂就去看后面给出的地址翻译流程图)</li><li>物理地址的低12位表示一个页内的偏移, <code>12-55</code>位表示了页号</li></ol><p>下面是详细的<code>SV39分</code>页机制：</p><ol><li><p><strong>三级页表结构</strong>：在SV39分页模式下，地址翻译使用三级页表。这意味着虚拟地址被分为四部分：<code>VPN[2]、VPN[1]、VPN[0]</code>和页内偏移。这里的VPN代表虚拟页号（Virtual Page Number），不同级别的页表项（PTE）由不同的VPN部分索引。</p></li><li><p><strong>页大小</strong>：SV39通常使用4KB的页大小，这是最常见的页大小，但也支持大页，如2MB和1GB的大页。因为地址是8字节, 因此一个存放页表项的页就包含了<code>4096/1024</code>&#x3D;<code>512</code>个页表项</p></li><li><p><strong>地址转换</strong>：虚拟地址转换为物理地址的过程涉及查找三级页表。首先使用VPN[2]在一级页表中查找，得到二级页表的地址；然后使用VPN[1]在二级页表中查找，得到三级页表的地址；最后使用VPN[0]在三级页表中查找，得到物理页号（PPN）。页内偏移保持不变，直接用于定位物理页内的具体地址。</p></li><li><p><strong>地址翻译缓存（TLB）</strong>：由于地址翻译过程可能相当耗时，因为它涉及到多次内存访问，RISC-V处理器通常会使用<code>TLB</code>来缓存最近的地址翻译结果，来加快地址翻译速度。</p></li></ol><p>接下来是地址翻译的流程, 摘自<code>MIT6.S081</code>:</p><p><img src="/../../../images/LearningOS/ch4-translate.png" alt="ch4-translate"></p><ol><li><code>L2</code>是根页表的索引, 2<sup>9</sup> &#x3D; 512正好能表示所有的索引, 根页表的页表项记录了<code>L1</code>对应页表的物理页号<code>PPN</code></li><li>用之前拿到的物理页号<code>PPN</code>找到<code>L1</code>对应页表的物理页, 用同样的思路找到索引<code>L1</code>的页表项, 其记录了<code>L0</code>对应页表的物理页号<code>PPN</code></li><li>用之前的<code>PPN</code>, 结合索引<code>L0</code>拿到实际的数据页的页号<code>PPN</code></li><li>用最终得到的页号<code>PPN</code>找到数据页, 使用页内便宜<code>OffSet</code>就找到了最终的物理地址</li></ol><h2 id="1-4-SV39分页的代码实现"><a href="#1-4-SV39分页的代码实现" class="headerlink" title="1.4 SV39分页的代码实现"></a>1.4 <code>SV39</code>分页的代码实现</h2><p>文档中详细地介绍了页表和地址空间相关数据结构, 这里不详细展开了, 很多内容都是涉及页表号、地址之间的转化以及地址转货为结构体或切片的方法，比较繁琐。 这里只介绍我认为其中比较重要的代码</p><h3 id="1-4-1-页帧分配器"><a href="#1-4-1-页帧分配器" class="headerlink" title="1.4.1 页帧分配器"></a>1.4.1 页帧分配器</h3><p>这里管理内存既然是以页为单位的，自然需要一个页分配器，分配的页的单位称为页框：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    current: <span class="type">usize</span>,</span><br><span class="line">    end: <span class="type">usize</span>,</span><br><span class="line">    recycled: <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, l: PhysPageNum, r: PhysPageNum) &#123;</span><br><span class="line">        <span class="keyword">self</span>.current = l.<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.end = r.<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// trace!(&quot;last &#123;&#125; Physical Frames.&quot;, self.end - self.current);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的结构体中, 物理页号区间 <code>[ current , end )</code> 此前均 从未 被分配出去过，而容器 <code>recycled</code> 以后入先出的方式保存了被回收的物理页号,<br>具体分配和回收的方法如下:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">FrameAllocator</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">alloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;PhysPageNum&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">dealloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, ppn: PhysPageNum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FrameAllocator</span> <span class="keyword">for</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            current: <span class="number">0</span>,</span><br><span class="line">            end: <span class="number">0</span>,</span><br><span class="line">            recycled: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">alloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;PhysPageNum&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(ppn) = <span class="keyword">self</span>.recycled.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(ppn.<span class="title function_ invoke__">into</span>())</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">self</span>.current == <span class="keyword">self</span>.end &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.current += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>((<span class="keyword">self</span>.current - <span class="number">1</span>).<span class="title function_ invoke__">into</span>())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">dealloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, ppn: PhysPageNum) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ppn</span> = ppn.<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// validity check</span></span><br><span class="line">        <span class="keyword">if</span> ppn &gt;= <span class="keyword">self</span>.current || <span class="keyword">self</span>.recycled.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">any</span>(|&amp;v| v == ppn) &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Frame ppn=&#123;:#x&#125; has not been allocated!&quot;</span>, ppn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// recycle</span></span><br><span class="line">        <span class="keyword">self</span>.recycled.<span class="title function_ invoke__">push</span>(ppn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配和回收页帧逻辑都很简单:</p><ol><li>分配时优先从<code>recycled</code>中重复利用回收的页帧, 否则对<code>current</code>自增完成分配</li><li>回收时将其放入<code>recycled</code></li></ol><p>这里有一个很有意思的地方, 就是实际分配时是在前面的<code>StackFrameAllocator</code>基础上再再进行了一层封装:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Allocate a physical page frame in FrameTracker style</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">frame_alloc</span>() <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;FrameTracker&gt; &#123;</span><br><span class="line">    FRAME_ALLOCATOR</span><br><span class="line">        .<span class="title function_ invoke__">exclusive_access</span>()</span><br><span class="line">        .<span class="title function_ invoke__">alloc</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(FrameTracker::new)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Deallocate a physical page frame with a given ppn</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">frame_dealloc</span>(ppn: PhysPageNum) &#123;</span><br><span class="line">    FRAME_ALLOCATOR.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">dealloc</span>(ppn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="comment">/// physical page number</span></span><br><span class="line">    <span class="keyword">pub</span> ppn: PhysPageNum,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">frame_dealloc</span>(<span class="keyword">self</span>.ppn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还是熟悉的 <code>RAII</code> 的思想，将一个物理页帧的生命周期绑定到一个 <code>FrameTracker</code> 变量上，当其生命周期结束时, 使用自定义的<code>drop</code>方法将其回收到<code>StackFrameAllocator</code>的<code>recycle</code>容器中, 这种思想和方法以后还会看到</p><h3 id="1-4-2-页表的查询"><a href="#1-4-2-页表的查询" class="headerlink" title="1.4.2 页表的查询"></a>1.4.2 页表的查询</h3><p>页表的方法很多, 这里我只列出自己认为比较重要的方法, 首先就是查询页表的方法:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Find PageTableEntry by VirtPageNum, create a frame for a 4KB page table if not exist</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">find_pte_create</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">for</span> (i, idx) <span class="keyword">in</span> idxs.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = &amp;<span class="keyword">mut</span> ppn.<span class="title function_ invoke__">get_pte_array</span>()[*idx];</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">            result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(frame.ppn, PTEFlags::V);</span><br><span class="line">            <span class="keyword">self</span>.frames.<span class="title function_ invoke__">push</span>(frame);</span><br><span class="line">        &#125;</span><br><span class="line">        ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// Find PageTableEntry by VirtPageNum</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">find_pte</span>(&amp;<span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">for</span> (i, idx) <span class="keyword">in</span> idxs.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = &amp;<span class="keyword">mut</span> ppn.<span class="title function_ invoke__">get_pte_array</span>()[*idx];</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">            result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>find_pte_create</code>和<code>find_pte</code>逻辑类似, 都是实现了之前<code>MIT6.S081</code>中地址翻译的过程, 这里就不重复其过程了</p><h3 id="1-4-3-页表的创建与拆除"><a href="#1-4-3-页表的创建与拆除" class="headerlink" title="1.4.3 页表的创建与拆除"></a>1.4.3 页表的创建与拆除</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Create a new page table</span></span><br><span class="line">    <span class="comment">/// set the map between virtual page number and physical page number</span></span><br><span class="line">    <span class="meta">#[allow(unused)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte_create</span>(vpn).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">assert!</span>(!pte.<span class="title function_ invoke__">is_valid</span>(), <span class="string">&quot;vpn &#123;:?&#125; is mapped before mapping&quot;</span>, vpn);</span><br><span class="line">        *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(ppn, flags | PTEFlags::V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// remove the map between virtual page number and physical page number</span></span><br><span class="line">    <span class="meta">#[allow(unused)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte</span>(vpn).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">assert!</span>(pte.<span class="title function_ invoke__">is_valid</span>(), <span class="string">&quot;vpn &#123;:?&#125; is invalid before unmapping&quot;</span>, vpn);</span><br><span class="line">        *pte = PageTableEntry::<span class="title function_ invoke__">empty</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>页表的创建与拆除就是调用<code>find_pte_create</code>或<code>find_pte</code>, 然后设置页表项完成映射或拆除映射</p><h1 id="2-基于虚拟内存的地址空间"><a href="#2-基于虚拟内存的地址空间" class="headerlink" title="2 基于虚拟内存的地址空间"></a>2 基于虚拟内存的地址空间</h1><h2 id="2-1-地址空间结构体"><a href="#2-1-地址空间结构体" class="headerlink" title="2.1 地址空间结构体"></a>2.1 地址空间结构体</h2><p>完成了虚拟内存的实现后, 下一步是基于虚拟内存实现地址空间的抽象, 在<code>rCore</code>中, 地址空间被进一步划分为多个逻辑段:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MemorySet</span> &#123;</span><br><span class="line">    page_table: PageTable,</span><br><span class="line">    areas: <span class="type">Vec</span>&lt;MapArea&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里, <code>MemorySet</code>就是一个地址空间, 其中有多个逻辑段存放于一个容器<code>Vec</code>中, 这里也是<code>RAII</code>的思想</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MapArea</span> &#123;</span><br><span class="line">    vpn_range: VPNRange,</span><br><span class="line">    data_frames: BTreeMap&lt;VirtPageNum, FrameTracker&gt;,</span><br><span class="line">    map_type: MapType,</span><br><span class="line">    map_perm: MapPermission,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MapArea</code>的<code>vpn_range</code>表示虚拟页号的返回, <code>data_frames</code>同样是将<code>FrameTracker</code>的生命周期绑定到<code>BTreeMap</code>中</p><p>接下来, 只介绍<code>MemorySet</code>和<code>MapArea</code>中比较关键的方法, 因为所有的方法太繁杂了…</p><h2 id="2-2-新建和拆除MapArea映射"><a href="#2-2-新建和拆除MapArea映射" class="headerlink" title="2.2 新建和拆除MapArea映射"></a>2.2 新建和拆除<code>MapArea</code>映射</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map_one</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, vpn: VirtPageNum) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ppn</span>: PhysPageNum;</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.map_type &#123;</span><br><span class="line">        MapType::Identical =&gt; &#123;</span><br><span class="line">            ppn = <span class="title function_ invoke__">PhysPageNum</span>(vpn.<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MapType::Framed =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            ppn = frame.ppn;</span><br><span class="line">            <span class="keyword">self</span>.data_frames.<span class="title function_ invoke__">insert</span>(vpn, frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pte_flags</span> = PTEFlags::<span class="title function_ invoke__">from_bits</span>(<span class="keyword">self</span>.map_perm.bits).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    page_table.<span class="title function_ invoke__">map</span>(vpn, ppn, pte_flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[allow(unused)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmap_one</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, vpn: VirtPageNum) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.map_type == MapType::Framed &#123;</span><br><span class="line">        <span class="keyword">self</span>.data_frames.<span class="title function_ invoke__">remove</span>(&amp;vpn);</span><br><span class="line">    &#125;</span><br><span class="line">    page_table.<span class="title function_ invoke__">unmap</span>(vpn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map_one</code>的思路如下:</p><ol><li>新建一个虚拟页到物理页的映射<ol><li>如果映射类型是<code>MapType::Framed</code>: 从 <code>FRAME_ALLOCATOR</code> 处分配一个物理页<code>frame,</code> 并将 <code>vpn</code> 和 <code>frame</code> 插入到 <code>data_frames</code> 中</li><li>如果映射类型是<code>MapType::Identical</code>, <code>ppn</code>和<code>vpn</code>相等</li></ol></li><li>无论是那种类型, 都在<code>page_table</code>中插入 <code>vpn</code> 到 <code>ppn</code> 的映射</li></ol><p><code>unmap_one</code>也是调用<code>PageTable</code>的<code>unmap</code>方法, 思路类似</p><p>这里可以看到, <code>MapArea</code>只是逻辑上管理一个虚拟地址段的数据结构, 真正的映射实现还是通过外部提供的<code>PageTable</code>的<code>map</code>实现, 正因如此, <code>MapArea</code>需要被托管到上层的结构体进行管理</p><p>最后, <code>map_one</code>和<code>unmap_one</code>只是映射和拆除单一的虚拟页, 因此, 如果在地址空间的所有虚拟页中调用这2个方法, 就完成了整个地址空间的建立和拆除:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">vpn</span> <span class="keyword">in</span> <span class="keyword">self</span>.vpn_range &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">map_one</span>(page_table, vpn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[allow(unused)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">vpn</span> <span class="keyword">in</span> <span class="keyword">self</span>.vpn_range &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">unmap_one</span>(page_table, vpn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-内核地址空间"><a href="#2-3-内核地址空间" class="headerlink" title="2.3 内核地址空间"></a>2.3 内核地址空间</h2><h3 id="2-3-1-内核地址空间概述"><a href="#2-3-1-内核地址空间概述" class="headerlink" title="2.3.1 内核地址空间概述"></a>2.3.1 内核地址空间概述</h3><p><img src="/../../../images/LearningOS/ch4-kernel-space.png" alt="ch4-kernel-space"><img src="/../../../images/LearningOS/ch4-kernel-space-2.png" alt="ch4-kernel-space-2"></p><p>上图摘自官方文档, 第一张图是内核的高地址空间, 第二章图是内核的低地址空间, 和之前<code>ch3</code>类似, 不同的应用程序拥有自己的内核栈, 不同内核栈之间拥有保护页, 说到这里, 那之前<code>ch3</code>的没有引入虚拟内存的内核地址空间不是和现在没啥区别吗? 确实, 因为这里内核地址空间采用的是<strong>恒等映射</strong>, 也就是内核的虚拟地址和实际物理地址完全相同, 这样也便于内核精确地控制内存。</p><p>但区别还是有的，也就是跳板 <code>Trampoline</code>, 这会在后文中介绍</p><h3 id="2-3-2-应用地址空间概述"><a href="#2-3-2-应用地址空间概述" class="headerlink" title="2.3.2 应用地址空间概述"></a>2.3.2 应用地址空间概述</h3><p><img src="/../../../images/LearningOS/ch4-user-space.png" alt="ch4-user-space"><br>上图摘自官方文档, 和之前的内容相比, 现在的地址克难攻坚在顶层多了<code>Trampoline</code>和<code>TrapContext</code>, 这涉及到引入虚拟内存后的上下文切换, 后面会详细描述</p><blockquote><blockquote><p>其实地址空间这一部分, 最复杂的是解析<code>elf</code>的工作, 这一部分<code>rCore</code>目前直接使用了第三方库实现, 没有深入</p></blockquote></blockquote><h1 id="3-引入虚拟内存后的上下文切换"><a href="#3-引入虚拟内存后的上下文切换" class="headerlink" title="3 引入虚拟内存后的上下文切换"></a>3 引入虚拟内存后的上下文切换</h1><p>这一部分才是我们这一章节的最核心的内容</p><h2 id="3-1-思考和ch3的变化"><a href="#3-1-思考和ch3的变化" class="headerlink" title="3.1 思考和ch3的变化"></a>3.1 思考和<code>ch3</code>的变化</h2><p>回忆<code>ch3</code>的上下文切换, 其在<code>trap</code>中将不同任务的上下文信息保存在自己的内核栈中, 我们注意到在<code>trap.S</code>中有这样的汇编代码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__alltraps:</span><br><span class="line">    csrrw sp, sscratch, sp</span><br></pre></td></tr></table></figure><p>在陷入<code>trap</code>时, 应用程序将用户栈指针和内核栈指针交换, 然后将上下文信息存储在了内核栈上, 这在内核和用户公用一套地址空间时看起来是否自然, 但现在的问题是, 内核和用户的地址空间不一样, 换句话说就是<code>satp</code>中的根页表地址不一样。因此陷入内核时需要将内核地址空间的根页表地址(<code>token</code>)写入<code>satp</code>, 因此需要一个寄存器存储原来用户空间的<code>token</code>, 同时用户栈的指针也需要被存储, 但我们只有一个 <code>sscratch</code> 寄存器可用来进行周转。因此我们没有办法像原来一样将应用程序的上下文信息保存在内核栈中</p><h2 id="3-2-从新的trap-S分析TrapContext和Trampoline"><a href="#3-2-从新的trap-S分析TrapContext和Trampoline" class="headerlink" title="3.2 从新的trap.S分析TrapContext和Trampoline"></a>3.2 从新的<code>trap.S</code>分析<code>TrapContext</code>和<code>Trampoline</code></h2><p>先分析新的<code>trap.S</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">.altmacro</span><br><span class="line">.macro SAVE_GP n</span><br><span class="line">    sd x\n, \n*8(sp)</span><br><span class="line">.endm</span><br><span class="line">.macro LOAD_GP n</span><br><span class="line">    ld x\n, \n*8(sp)</span><br><span class="line">.endm</span><br><span class="line">    .section .text.trampoline</span><br><span class="line">    .globl __alltraps</span><br><span class="line">    .globl __restore</span><br><span class="line">    .align 2</span><br><span class="line">__alltraps:</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    <span class="comment"># now sp-&gt;*TrapContext in user space, sscratch-&gt;user stack</span></span><br><span class="line">    <span class="comment"># save other general purpose registers</span></span><br><span class="line">    sd x1, 1*8(sp)</span><br><span class="line">    <span class="comment"># skip sp(x2), we will save it later</span></span><br><span class="line">    sd x3, 3*8(sp)</span><br><span class="line">    <span class="comment"># skip tp(x4), application does not use it</span></span><br><span class="line">    <span class="comment"># save x5~x31</span></span><br><span class="line">    .<span class="built_in">set</span> n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        SAVE_GP %n</span><br><span class="line">        .<span class="built_in">set</span> n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    <span class="comment"># we can use t0/t1/t2 freely, because they have been saved in TrapContext</span></span><br><span class="line">    csrr t0, sstatus</span><br><span class="line">    csrr t1, sepc</span><br><span class="line">    sd t0, 32*8(sp)</span><br><span class="line">    sd t1, 33*8(sp)</span><br><span class="line">    <span class="comment"># read user stack from sscratch and save it in TrapContext</span></span><br><span class="line">    csrr t2, sscratch</span><br><span class="line">    sd t2, 2*8(sp)</span><br><span class="line">    <span class="comment"># load kernel_satp into t0</span></span><br><span class="line">    ld t0, 34*8(sp)</span><br><span class="line">    <span class="comment"># load trap_handler into t1</span></span><br><span class="line">    ld t1, 36*8(sp)</span><br><span class="line">    <span class="comment"># move to kernel_sp</span></span><br><span class="line">    ld sp, 35*8(sp)</span><br><span class="line">    <span class="comment"># switch to kernel space</span></span><br><span class="line">    csrw satp, t0</span><br><span class="line">    sfence.vma</span><br><span class="line">    <span class="comment"># jump to trap_handler</span></span><br><span class="line">    jr t1</span><br><span class="line"></span><br><span class="line">__restore:</span><br><span class="line">    <span class="comment"># a0: *TrapContext in user space(Constant); a1: user space token</span></span><br><span class="line">    <span class="comment"># switch to user space</span></span><br><span class="line">    csrw satp, a1</span><br><span class="line">    sfence.vma</span><br><span class="line">    csrw sscratch, a0</span><br><span class="line">    <span class="built_in">mv</span> sp, a0</span><br><span class="line">    <span class="comment"># now sp points to TrapContext in user space, start restoring based on it</span></span><br><span class="line">    <span class="comment"># restore sstatus/sepc</span></span><br><span class="line">    ld t0, 32*8(sp)</span><br><span class="line">    ld t1, 33*8(sp)</span><br><span class="line">    csrw sstatus, t0</span><br><span class="line">    csrw sepc, t1</span><br><span class="line">    <span class="comment"># restore general purpose registers except x0/sp/tp</span></span><br><span class="line">    ld x1, 1*8(sp)</span><br><span class="line">    ld x3, 3*8(sp)</span><br><span class="line">    .<span class="built_in">set</span> n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        LOAD_GP %n</span><br><span class="line">        .<span class="built_in">set</span> n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    <span class="comment"># back to user stack</span></span><br><span class="line">    ld sp, 2*8(sp)</span><br><span class="line">    sret</span><br></pre></td></tr></table></figure><p>这里先只分析<code>__alltraps</code>的代码:</p><p>通过注释我们看出, 此时的<code>sscratch</code>存储的是用户态下<code>TrapContext</code>的地址, 这里需要尤其注意, 尽管我们现在进入的内核模式(硬件会自动设置一些<code>csr</code>寄存器), 但是我们目前的地址空间还没有发送变化, 相关寄存器还是用户态时的内容, 也就是说, 此时我们是将上下文地址存储到了用户的地址空间中的一段连续的内存中, 这个区域也就是之前图中的<code>trapContext</code></p><p>存储完成后, 从<code>trapContext</code>的固定位置读取内核的<code>token</code>和内核栈的地址, 重新设置<code>sp</code>后并调用<code>sfence.vma</code>完成地址空间的切换, 这里的问题在于, 完成地址空间切换后, 我们的<code>pc</code>还是指向<code>__alltraps</code>的最后一句<code>jr t1</code>吗?</p><p>首先这是必要的, 不然操作系统就没法玩了。但由于地址空间发生了切换，要实现这一点，**<code>trap.S</code>中的代码在内核地址空间和用户地址空间必须是相同的映射吗, 这一块映射的地址段就是<code>Trampoline</code>**</p><p>接下来看看映射<code>Trampoline</code>的方法:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">map_trampoline</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.page_table.<span class="title function_ invoke__">map</span>(</span><br><span class="line">        VirtAddr::<span class="title function_ invoke__">from</span>(TRAMPOLINE).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        PhysAddr::<span class="title function_ invoke__">from</span>(strampoline <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        PTEFlags::R | PTEFlags::X,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是<code>map_trampoline</code>方法直接被一个地址空间映射, 不属于一个<code>MapArea</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new_kernel</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">memory_set</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">new_bare</span>();</span><br><span class="line">        <span class="comment">// map trampoline</span></span><br><span class="line">        memory_set.<span class="title function_ invoke__">map_trampoline</span>();</span><br><span class="line">        <span class="comment">// map kernel sections</span></span><br><span class="line">        info!(<span class="string">&quot;.text [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, stext <span class="keyword">as</span> <span class="type">usize</span>, etext <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        info!(<span class="string">&quot;.rodata [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, srodata <span class="keyword">as</span> <span class="type">usize</span>, erodata <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        info!(<span class="string">&quot;.data [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, sdata <span class="keyword">as</span> <span class="type">usize</span>, edata <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        info!(</span><br><span class="line">            <span class="string">&quot;.bss [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>,</span><br><span class="line">            sbss_with_stack <span class="keyword">as</span> <span class="type">usize</span>, ebss <span class="keyword">as</span> <span class="type">usize</span></span><br><span class="line">        );</span><br><span class="line">        info!(<span class="string">&quot;mapping .text section&quot;</span>);</span><br><span class="line">        memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">            MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">                (stext <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">                (etext <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">                MapType::Identical,</span><br><span class="line">                MapPermission::R | MapPermission::X,</span><br><span class="line">            ),</span><br><span class="line">            <span class="literal">None</span>,</span><br><span class="line">        );</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-引入虚拟内存后的任务控制"><a href="#4-引入虚拟内存后的任务控制" class="headerlink" title="4 引入虚拟内存后的任务控制"></a>4 引入虚拟内存后的任务控制</h1><h2 id="4-1-任务控制块"><a href="#4-1-任务控制块" class="headerlink" title="4.1 任务控制块"></a>4.1 任务控制块</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskControlBlock</span> &#123;</span><br><span class="line">    <span class="comment">/// Save task context</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Maintain the execution status of the current process</span></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Application address space</span></span><br><span class="line">    <span class="keyword">pub</span> memory_set: MemorySet,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The phys page number of trap context</span></span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The size(top addr) of program which is loaded from elf file</span></span><br><span class="line">    <span class="keyword">pub</span> base_size: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入虚拟内存后, 需要添加地址空间<code>MemorySet</code>的结构体以及每个任务的<code>trap context</code>的物理页号, 这样以来, 内核才可以在任务控制时获取其<code>trap</code>的上下文信息</p><h2 id="4-2-任务运行的实例"><a href="#4-2-任务运行的实例" class="headerlink" title="4.2 任务运行的实例"></a>4.2 任务运行的实例</h2><p>其实<code>TaskControlBlock</code>很多地方都尽量修改, 但在理解了上下文切换的变化和挑板页<code>Trampoline</code>的原理后, 看看官方文档很容易理解, 就不展开了</p><p>这里还是以一个我画的流程图的形式来总结引入虚拟内存的变化, 这里从运行第一个程序开始<br><img src="/../../../images/LearningOS/ch4-switch.png" alt="ch4-switch.png"></p><p>图例说明:</p><ol><li>红色表示内核函数</li><li>蓝色表示用户函数或用户地址空间的内存段</li><li>紫色表示跳板页的中间状态</li></ol><p>注意, 这里上下文切换时, <code>App0</code>的<code>TaskContext</code>有2次使用:</p><ol><li><code>__alltraps</code>时使用了<code>TaskContext</code>:<br>这里的目的是切换<code>App0</code>的用户上下文和内核上下文</li><li><code>App0</code>切换到<code>App1</code>的<code>__switch</code>时使用了<code>TaskContext</code>:<br>这里是保存<code>App0</code>在内核态时的寄存器和内核栈指针, 也就是切换的是<code>App0</code>的内核态上下文和<code>App1</code>的上下文, 在这里<code>App1</code>的上下文是用户上下文, 因为<code>APP1</code>也是第一次运行, 但之运行一段时间后的上下文切换则不一定, 可能切换到某个<code>App</code>之前让出<code>Cpu</code>时执行到<code>__switch</code>的内核上下文, 例如这里的<code>App0</code></li></ol><p>这里由于太拥挤了, 没有画出<code>App0</code>之后恢复执行的流程, 这里简单说明一下:</p><ol><li>某一时刻另外的<code>App</code>因执行结束或者让出<code>CPU</code>, 又进入了<code>run_next_task</code></li><li>这次<code>run_next_task</code>选择下一个<code>task</code>是<code>App0</code></li><li>由于<code>App0</code>的<code>TaskContext</code>保存了上一次其在内核中被切换的上下文: 执行<code>run_next_task</code>时的返回地址<code>ra</code>, <code>ra</code>被加载后将按照下面的路径返回:<code>__switch</code> -&gt; <code>run_next_task</code> -&gt; <code>suspend_current_and_run_next</code> -&gt; <code>trap_handler</code></li><li>此后执行: <code>trap_return</code> -&gt; <code>__restore</code> -&gt; <code>之前让出CPu的用户代码</code>, 这个过程中的最后一步中, 之前恢复的<code>sepc</code>会在<code>sret</code>返回时会被加载到<code>pc</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文不会将原本&lt;code&gt;rCore文档&lt;/code&gt;的内容重复太多, 主要是补充学习过程中遇到的知识点, 因此还需结合原文使用, 原文在后面的链接中&lt;/p&gt;
&lt;p&gt;这一章引入了页表和虚拟内存。回顾之前构建的&lt;code&gt;OS&lt;/code&gt;, 其内核和应用是共用一份地址空间的</summary>
      
    
    
    
    <category term="训练营笔记" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
    
    <category term="清华大学开源操作系统训练营2023" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A52023/"/>
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="riscv" scheme="http://example.com/tags/riscv/"/>
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>清华大学开源操作系统训练营: rCore chapter3笔记</title>
    <link href="http://example.com/2024/02/15/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch3%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/02/15/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch3%E7%AC%94%E8%AE%B0/</id>
    <published>2024-02-15T00:18:24.000Z</published>
    <updated>2024-02-21T16:16:04.678Z</updated>
    
    <content type="html"><![CDATA[<p>本文不会将原本<code>rCore文档</code>的内容重复太多, 主要是补充学习过程中遇到的知识点, 因此还需结合原文使用, 原文在后面的链接中</p><p>这一章在之前的章节中更进一步, 实现了任务调度的功能, 也就是任务不再是之前的批处理系统那样一个接一个地运行, 而是受到<code>OS</code>的调度。为了实现这一目标， 本章实现了下面的功能或机制：</p><ol><li>将应用程序加载到不同的内存位置， 并且同时存在于内存中</li><li>内核添加上下文相关的数据结构，存储应用调度时的上下文信息，基于这些数据结构实现上下文切换函数</li><li>通过时钟中断实现抢占式调度</li></ol><p>完整版官方文档： <a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter3/index.html">https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter3/index.html</a></p><p>精简版文档： <a href="https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter3/index.html">https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter3/index.html</a></p><h1 id="1-应用程序数据结构"><a href="#1-应用程序数据结构" class="headerlink" title="1 应用程序数据结构"></a>1 应用程序数据结构</h1><h2 id="1-1-应用程序加载位置"><a href="#1-1-应用程序加载位置" class="headerlink" title="1.1 应用程序加载位置"></a>1.1 应用程序加载位置</h2><p>这一过程相比之前的章节变化很小，就是将不同的应用程序链接到了操作系统的不同的位置，应用程序加载的位置是一个基址加上指定的偏移量。</p><h2 id="1-2-应用程序的栈"><a href="#1-2-应用程序的栈" class="headerlink" title="1.2 应用程序的栈"></a>1.2 应用程序的栈</h2><p>这一由于我们需要实现任务的切换，应用程序运行的<strong>上下文</strong>包括了各种寄存器、函数调用栈等， 这些应用程序在应用程序被切换时需要被保存好，保存的位置通常是应用程序的内核栈，因此应用程序需要在上一章的基础上添加内核栈。</p><p>项目代码中，内核栈的初始化是咋<code>init_app_cx</code>中完成的:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/loader.rs</span></span><br><span class="line"><span class="keyword">static</span> KERNEL_STACK: [KernelStack; MAX_APP_NUM] = [KernelStack &#123;</span><br><span class="line">    data: [<span class="number">0</span>; KERNEL_STACK_SIZE],</span><br><span class="line">&#125;; MAX_APP_NUM];</span><br><span class="line"><span class="keyword">static</span> USER_STACK: [UserStack; MAX_APP_NUM] = [UserStack &#123;</span><br><span class="line">    data: [<span class="number">0</span>; USER_STACK_SIZE],</span><br><span class="line">&#125;; MAX_APP_NUM];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init_app_cx</span>(app_id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    KERNEL_STACK[app_id].<span class="title function_ invoke__">push_context</span>(TrapContext::<span class="title function_ invoke__">app_init_context</span>(</span><br><span class="line">        <span class="title function_ invoke__">get_base_i</span>(app_id),</span><br><span class="line">        USER_STACK[app_id].<span class="title function_ invoke__">get_sp</span>(),</span><br><span class="line">    ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, 每个程序有一个自己的<strong>内核栈和用户栈</strong>, 其内存空间就是一个全局变量数组的与<code>app</code>序号相同的索引处, 在初始化栈时, 每个应用程序的栈顶存放了其上下文信息(后面的章节会介绍)和用户栈指针。</p><h1 id="2-上下文切换"><a href="#2-上下文切换" class="headerlink" title="2 上下文切换"></a>2 上下文切换</h1><p>这一部分是非常重要的概念，其思想几乎适用于所有的操作系统而不仅仅是<code>rCore</code></p><h2 id="2-1-什么是上下文切换"><a href="#2-1-什么是上下文切换" class="headerlink" title="2.1 什么是上下文切换?"></a>2.1 什么是上下文切换?</h2><p><strong>上下文</strong>指的是一个进程或线程(这里我们还没有实现进程或者线程, 但是我们的应用程序可以类比进程)可以执行所需的所有信息的集合, 包括CPU寄存器的值、程序计数器（PC），堆栈指针以及操作系统为该进程或线程维护的内存分配信息等。</p><p>当操作系统执行任务切换（<code>context switch</code>）时，它会保存当前任务的上下文，并加载另一个任务的上下文，以便恢复该任务的执行, 这一过程称为<strong>上下文切换</strong>, 步骤包括:</p><ol><li><strong>保存CPU状态</strong>：保存当前执行任务的所有CPU寄存器，包括程序计数器和堆栈指针。</li><li><strong>保存进程状态</strong>：将当前进程的其他状态信息（如打开的文件描述符、进程的权限、记账信息等）保存到进程控制块（PCB）。</li><li><strong>加载新的进程状态</strong>：从另一个进程的PCB中读取其CPU寄存器和其他状态信息，并将其恢复到CPU和内存中。</li><li><strong>恢复执行</strong>：开始或恢复执行选定的新进程。</li></ol><h2 id="2-2-什么时候会上下文切换"><a href="#2-2-什么时候会上下文切换" class="headerlink" title="2.2 什么时候会上下文切换?"></a>2.2 什么时候会上下文切换?</h2><p>上面介绍了上下文切换, 但实际上我们的上下文切换是何时发生的呢? 其发生的原因在本章实现的<code>OS</code>中有2中:</p><ol><li>应用程序主动通过<code>yield</code>让出<code>CPU</code></li><li>应用程序运行了过长的时间, 被操作系统抢占(后面章节会介绍)</li></ol><h2 id="2-3-上下文切换的实现"><a href="#2-3-上下文切换的实现" class="headerlink" title="2.3 上下文切换的实现"></a>2.3 上下文切换的实现</h2><h3 id="2-3-1-数据结构"><a href="#2-3-1-数据结构" class="headerlink" title="2.3.1 数据结构"></a>2.3.1 数据结构</h3><p>直接先贴代码:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/context.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskContext</span> &#123;</span><br><span class="line">    <span class="comment">/// Ret position after task switching</span></span><br><span class="line">    ra: <span class="type">usize</span>,</span><br><span class="line">    <span class="comment">/// Stack pointer</span></span><br><span class="line">    sp: <span class="type">usize</span>,</span><br><span class="line">    <span class="comment">/// s0-11 register, callee saved</span></span><br><span class="line">    s: [<span class="type">usize</span>; <span class="number">12</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TaskContext</span> &#123;</span><br><span class="line">    <span class="comment">/// Create a new empty task context</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">zero_init</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            ra: <span class="number">0</span>,</span><br><span class="line">            sp: <span class="number">0</span>,</span><br><span class="line">            s: [<span class="number">0</span>; <span class="number">12</span>],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Create a new task context with a trap return addr and a kernel stack pointer</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">goto_restore</span>(kstack_ptr: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">__restore</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            ra: __restore <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">            sp: kstack_ptr,</span><br><span class="line">            s: [<span class="number">0</span>; <span class="number">12</span>],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TaskContext</code>这个结构体就是保存上下文的结构体, 保存的结构体包括<code>s0-s11</code>寄存器, 栈指针<code>sp</code>, 返回地址<code>ra</code>。<br>另外需要注意的是， 程序还没运行时，其上下文信息中的<code>ra</code>是上一章介绍的从<code>trap</code>恢复的<code>__restore</code>, 这和之前的逻辑是一样的</p><h3 id="2-3-2-switch函数"><a href="#2-3-2-switch函数" class="headerlink" title="2.3.2 __switch函数"></a>2.3.2 <code>__switch</code>函数</h3><p><code>__switch</code>函数完成了上下文切换, 其是由汇编代码编写的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.altmacro</span><br><span class="line">.macro SAVE_SN n</span><br><span class="line">    sd s\n, (\n+2)*8(a0)</span><br><span class="line">.endm</span><br><span class="line">.macro LOAD_SN n</span><br><span class="line">    ld s\n, (\n+2)*8(a1)</span><br><span class="line">.endm</span><br><span class="line">    .section .text</span><br><span class="line">    .globl __switch</span><br><span class="line">__switch:</span><br><span class="line">    <span class="comment"># __switch(</span></span><br><span class="line">    <span class="comment">#     current_task_cx_ptr: *mut TaskContext,</span></span><br><span class="line">    <span class="comment">#     next_task_cx_ptr: *const TaskContext</span></span><br><span class="line">    <span class="comment"># )</span></span><br><span class="line">    <span class="comment"># save kernel stack of current task</span></span><br><span class="line">    sd sp, 8(a0)</span><br><span class="line">    <span class="comment"># save ra &amp; s0~s11 of current execution</span></span><br><span class="line">    sd ra, 0(a0)</span><br><span class="line">    .<span class="built_in">set</span> n, 0</span><br><span class="line">    .rept 12</span><br><span class="line">        SAVE_SN %n</span><br><span class="line">        .<span class="built_in">set</span> n, n + 1</span><br><span class="line">    .endr</span><br><span class="line">    <span class="comment"># restore ra &amp; s0~s11 of next execution</span></span><br><span class="line">    ld ra, 0(a1)</span><br><span class="line">    .<span class="built_in">set</span> n, 0</span><br><span class="line">    .rept 12</span><br><span class="line">        LOAD_SN %n</span><br><span class="line">        .<span class="built_in">set</span> n, n + 1</span><br><span class="line">    .endr</span><br><span class="line">    <span class="comment"># restore kernel stack of next task</span></span><br><span class="line">    ld sp, 8(a1)</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>这段汇编代码的<code>a0</code> 和 <code>a1</code> 是函数参数寄存器，在<code>RISC-V</code>调用约定中用来传递第一个和第二个参数。在<code>__switch</code>函数中，它们分别代表<code>current_task_cx_ptr</code>（当前任务上下文指针）和<code>next_task_cx_ptr</code>（下一个任务上下文指针）。</p><ul><li><p><code>sd sp, 8(a0)</code>：存储当前任务的堆栈指针（<code>sp</code>）到<code>current_task_cx_ptr</code>所指向的结构体的第二个位置（假设结构体的起始位置为0，每个存储单元为8字节，栈指针保存在偏移量为8字节的位置）。</p></li><li><p><code>sd ra, 0(a0)</code>：存储当前任务的返回地址（<code>ra</code>）到<code>current_task_cx_ptr</code>所指向的结构体的起始位置。</p></li><li><p><code>.set n, 0</code> 和 <code>.rept 12</code> 循环：这是一个宏循环，它重复执行12次，用于保存寄存器<code>s0</code>到<code>s11</code>的值。<code>SAVE_SN</code>是一个宏，用于保存寄存器<code>s0</code>到<code>s11</code>到<code>current_task_cx_ptr</code>所指向的结构体中，对应的偏移量从16字节开始，每次增加8字节。</p></li><li><p><code>ld ra, 0(a1)</code>：加载下一个任务的返回地址到<code>ra</code>寄存器，这个地址来自<code>next_task_cx_ptr</code>所指向的结构体的起始位置。</p></li><li><p><code>.set n, 0</code> 和 <code>.rept 12</code> 循环：这是另一个宏循环，用于从<code>next_task_cx_ptr</code>所指向的结构体中恢复寄存器<code>s0</code>到<code>s11</code>的值。<code>LOAD_SN</code>宏执行相应的加载操作。</p></li><li><p><code>ld sp, 8(a1)</code>：加载下一个任务的堆栈指针到<code>sp</code>寄存器，这个堆栈指针来自<code>next_task_cx_ptr</code>所指向的结构体的第二个位置。</p></li><li><p><code>ret</code>：返回指令，它会跳转到<code>ra</code>寄存器中的地址，这里是下一个任务的继续执行点。</p></li></ul><p>这段汇编代码的主要任务是保存当前执行环境的关键状态（堆栈指针和寄存器），然后恢复下一个任务的状态，从而实现任务之间的切换。</p><h1 id="3-任务调度"><a href="#3-任务调度" class="headerlink" title="3 任务调度"></a>3 任务调度</h1><h2 id="3-1-数据结构"><a href="#3-1-数据结构" class="headerlink" title="3.1 数据结构"></a>3.1 数据结构</h2><p>本章引入了<code>TASK_MANAGER</code>这个全局变量来实现任务的调度, 其结构体为:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskManager</span> &#123;</span><br><span class="line">    num_app: <span class="type">usize</span>,</span><br><span class="line">    inner: UPSafeCell&lt;TaskManagerInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskManagerInner</span> &#123;</span><br><span class="line">    tasks: [TaskControlBlock; MAX_APP_NUM],</span><br><span class="line">    current_task: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其使用<code>current_task</code>标记当前运行的结构体</p><p>每个任务用<code>TaskControlBlock</code>标记:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskControlBlock</span> &#123;</span><br><span class="line">    <span class="comment">/// The task status in it&#x27;s lifecycle</span></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line">    <span class="comment">/// The task context</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// The status of a task</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, PartialEq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">TaskStatus</span> &#123;</span><br><span class="line">    <span class="comment">/// uninitialized</span></span><br><span class="line">    UnInit,</span><br><span class="line">    <span class="comment">/// ready to run</span></span><br><span class="line">    Ready,</span><br><span class="line">    <span class="comment">/// running</span></span><br><span class="line">    Running,</span><br><span class="line">    <span class="comment">/// exited</span></span><br><span class="line">    Exited,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一部分很同意理解, 就是将任务的状态和上下文记录在一起, 以便于任务调度</p><h2 id="3-2-任务调度"><a href="#3-2-任务调度" class="headerlink" title="3.2 任务调度"></a>3.2 任务调度</h2><p>调度任务的过程就是找到当前任务的上下文(或者第一个任务运行时的初始化的上下文)和下一个任务的上下文, 将其作为参数传递给<code>__switch</code>函数, 其发生场景有3种:</p><ol><li><p>第一次运行程序:</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/mod.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">run_first_task</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task0</span> = &amp;<span class="keyword">mut</span> inner.tasks[<span class="number">0</span>];</span><br><span class="line">    task0.task_status = TaskStatus::Running;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">next_task_cx_ptr</span> = &amp;task0.task_cx <span class="keyword">as</span> *<span class="keyword">const</span> TaskContext;</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(inner);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">_unused</span> = TaskContext::<span class="title function_ invoke__">zero_init</span>();</span><br><span class="line">    <span class="comment">// before this, we should drop local variables that must be dropped manually</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __switch(&amp;<span class="keyword">mut</span> _unused <span class="keyword">as</span> *<span class="keyword">mut</span> TaskContext, next_task_cx_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;unreachable in run_first_task!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里是选择序号为0的程序运行</p></li><li><p>程序主动让出<code>CPU</code>或被抢占</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/mod.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">suspend_current_and_run_next</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">mark_current_suspended</span>();</span><br><span class="line">    <span class="title function_ invoke__">run_next_task</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// Change the status of current `Running` task into `Ready`.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">mark_current_suspended</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">current</span> = inner.current_task;</span><br><span class="line">    inner.tasks[current].task_status = TaskStatus::Ready;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>程序运行结束</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// os/src/task/mod.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exit_current_and_run_next</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">mark_current_exited</span>();</span><br><span class="line">    <span class="title function_ invoke__">run_next_task</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// Change the status of current `Running` task into `Exited`.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">mark_current_exited</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">current</span> = inner.current_task;</span><br><span class="line">    inner.tasks[current].task_status = TaskStatus::Exited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>其中<code>run_next_task</code>最终会调用下面的函数<code>run_next_task</code>方法:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">run_next_task</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(next) = <span class="keyword">self</span>.<span class="title function_ invoke__">find_next_task</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">current</span> = inner.current_task;</span><br><span class="line">        inner.tasks[next].task_status = TaskStatus::Running;</span><br><span class="line">        inner.current_task = next;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">current_task_cx_ptr</span> = &amp;<span class="keyword">mut</span> inner.tasks[current].task_cx <span class="keyword">as</span> *<span class="keyword">mut</span> TaskContext;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">next_task_cx_ptr</span> = &amp;inner.tasks[next].task_cx <span class="keyword">as</span> *<span class="keyword">const</span> TaskContext;</span><br><span class="line">        <span class="title function_ invoke__">drop</span>(inner);</span><br><span class="line">        <span class="comment">// before this, we should drop local variables that must be dropped manually</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            __switch(current_task_cx_ptr, next_task_cx_ptr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// go back to user mode</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;All applications completed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其过程包括:</p><ol><li><code>find_next_task</code>选择一个就绪的任务</li><li>标记这个就绪的任务为<code>TaskStatus::Running</code></li><li>传递2个任务的上下文结构体给<code>__switch</code>完成上下文切换</li></ol><h1 id="4-抢占"><a href="#4-抢占" class="headerlink" title="4 抢占"></a>4 抢占</h1><p>截止到目前, 大部分多任务调度的机制已经实现, 但还缺少抢占的机制实现</p><h2 id="4-1-时钟中断"><a href="#4-1-时钟中断" class="headerlink" title="4.1 时钟中断"></a>4.1 时钟中断</h2><p>时钟中断是操作系统实现抢占式多任务处理的关键机制。它允许操作系统定期从当前执行的任务（或线程）中断开，以便操作系统的调度器可以决定是否继续执行当前任务或切换到另一个任务。这种机制确保了所有任务都有机会在处理器上运行，进而使得操作系统能够提供一个看似同时运行多个任务的环境, 并且避免了一个应用程序运行时间过长的场景。中断的主要作用有：</p><ol><li><strong>公平的CPU时间分配</strong>：确保所有任务都有公平的机会使用CPU，根据它们的优先级和CPU时间需求进行调度。</li><li><strong>响应性</strong>：即使一个任务在执行一个长时间的操作，时钟中断也确保系统保持响应，因为操作系统可以在两个连续的时钟中断之间切换到其他任务。</li><li><strong>多任务处理</strong>：允许多个任务看似同时进行，提高了系统的利用率和吞吐量。</li></ol><h2 id="4-2-时钟中断的工作原理"><a href="#4-2-时钟中断的工作原理" class="headerlink" title="4.2 时钟中断的工作原理"></a>4.2 时钟中断的工作原理</h2><ol><li><p><strong>硬件时钟</strong>：硬件时钟（通常是一个定时器设备）被配置为在固定的时间间隔发出信号。这个时间间隔可以是毫秒级别，具体取决于操作系统的设计和配置。</p></li><li><p><strong>中断信号</strong>：当硬件时钟达到预设的时间间隔时，它会向处理器发送一个中断信号。这个信号提示处理器当前正在执行的指令流应该被暂时中断。在我们的代码中， 我们进行了如下设置：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Set the next timer interrupt</span></span><br><span class="line"> <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_next_trigger</span>() &#123;</span><br><span class="line">     <span class="title function_ invoke__">set_timer</span>(<span class="title function_ invoke__">get_time</span>() + CLOCK_FREQ / TICKS_PER_SEC);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> <code>set_timer</code>是<code>rustsbi</code>提供的中断设置接口, 其可以实则指定时间的中断</p></li><li><p><strong>中断服务例程（ISR）</strong>：处理器接收到中断信号后，会跳转执行一个特定的中断服务例程。这个ISR是由操作系统提供的，并且在中断向量表中有一个特定的入口。在许多处理器架构和操作系统中，<strong>中断服务例程（ISR）和异常处理程序通常通过一个统一的入口点处理，这个入口点被称为陷阱（trap）处理程序，也就是在我们的项目中存储在<code>stvec</code>中的<code>__alltraps</code></strong>, 我们可以在<code>os/src/trap/mod.rs</code>中看到下面的初始化:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>() &#123;</span><br><span class="line">     <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">         <span class="keyword">fn</span> <span class="title function_">__alltraps</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">unsafe</span> &#123;</span><br><span class="line">         stvec::<span class="title function_ invoke__">write</span>(__alltraps <span class="keyword">as</span> <span class="type">usize</span>, TrapMode::Direct);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 换句话说</p></li><li><p><strong>中断异常处理</strong>：在<code>ISR</code>中，操作系统的调度器可以检测当前运行的任务是否应该继续运行，或者是另一个任务的运行优先级更高。如果决定进行任务切换，操作系统会保存当前任务的状态（上下文切换），然后加载下一个任务的状态并开始执行它。目前我们的中断是时钟中断, 实际上还有更多类型的中断, 不是每一个中断都和上下文切换相关, 比如有的中断只是外设鼠标或键盘的硬件中断</p></li><li><p><strong>返回正常执行</strong>：完成调度决策和任何必要的任务切换后，<code>ISR</code>结束，并指示处理器恢复到中断前的状态，继续执行被中断的任务或开始执行新的任务。</p></li></ol><h2 id="4-3-引入中断后的任务调度"><a href="#4-3-引入中断后的任务调度" class="headerlink" title="4.3 引入中断后的任务调度"></a>4.3 引入中断后的任务调度</h2><h3 id="4-3-1-中断机制的初始化"><a href="#4-3-1-中断机制的初始化" class="headerlink" title="4.3.1 中断机制的初始化"></a>4.3.1 中断机制的初始化</h3><p>中断相关的初始化很简单, 就是在<code>rust_main</code>中调用<code>set_next_trigger</code>设置一次中断时间。</p><h3 id="4-3-2-任务调度"><a href="#4-3-2-任务调度" class="headerlink" title="4.3.2 任务调度"></a>4.3.2 任务调度</h3><p>由于中断使用的入口就是<code>__alltraps</code>，因此我们只需要关注<code>__alltraps</code>调用的<code>trap_handler</code>即可:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">trap_handler</span>(cx: &amp;<span class="keyword">mut</span> TrapContext) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> TrapContext &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scause</span> = scause::<span class="title function_ invoke__">read</span>(); <span class="comment">// get trap cause</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stval</span> = stval::<span class="title function_ invoke__">read</span>(); <span class="comment">// get extra value</span></span><br><span class="line">                               <span class="comment">// trace!(&quot;into &#123;:?&#125;&quot;, scause.cause());</span></span><br><span class="line">    <span class="keyword">match</span> scause.<span class="title function_ invoke__">cause</span>() &#123;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::UserEnvCall) =&gt; &#123;</span><br><span class="line">            <span class="comment">// jump to next instruction anyway</span></span><br><span class="line">            cx.sepc += <span class="number">4</span>;</span><br><span class="line">            <span class="comment">// get system call return value</span></span><br><span class="line">            cx.x[<span class="number">10</span>] = <span class="title function_ invoke__">syscall</span>(cx.x[<span class="number">17</span>], [cx.x[<span class="number">10</span>], cx.x[<span class="number">11</span>], cx.x[<span class="number">12</span>]]) <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::StoreFault) | Trap::<span class="title function_ invoke__">Exception</span>(Exception::StorePageFault) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] PageFault in application, bad addr = &#123;:#x&#125;, bad instruction = &#123;:#x&#125;, kernel killed it.&quot;</span>, stval, cx.sepc);</span><br><span class="line">            <span class="title function_ invoke__">exit_current_and_run_next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::IllegalInstruction) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] IllegalInstruction in application, kernel killed it.&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">exit_current_and_run_next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Interrupt</span>(Interrupt::SupervisorTimer) =&gt; &#123;</span><br><span class="line">            <span class="title function_ invoke__">set_next_trigger</span>();</span><br><span class="line">            <span class="title function_ invoke__">suspend_current_and_run_next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Unsupported trap &#123;:?&#125;, stval = &#123;:#x&#125;!&quot;</span>,</span><br><span class="line">                scause.<span class="title function_ invoke__">cause</span>(),</span><br><span class="line">                stval</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, <code>match</code>多了一个<code>SupervisorTimer</code>分支, 处理方式就是简单地再次设置下一次中断时间, 并且挂起当前任务, 找下一个任务运行</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>之前说了这么多, 可能思路还是比较乱, 比如<code>trap</code>和中断之前的处理调用逻可能不清楚, 这里我梳理了下面的流程图:</p><p><img src="/../../../images/LearningOS/ch3-switch.png" alt="ch3-switch"></p><p>可以看到, <code>task0</code>第一次主动让出CPU, 通过<code>ecall</code>简介调用了<code>_switch</code>, 调用的序号为10, 后来在序号19时, <code>task0</code>又从<code>_switch</code>中返回, <strong>这也是<code>_switch</code>的一个核心性质: 调用时和返回时可能经历了多个控制流(不同的线程或进程)</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文不会将原本&lt;code&gt;rCore文档&lt;/code&gt;的内容重复太多, 主要是补充学习过程中遇到的知识点, 因此还需结合原文使用, 原文在后面的链接中&lt;/p&gt;
&lt;p&gt;这一章在之前的章节中更进一步, 实现了任务调度的功能, 也就是任务不再是之前的批处理系统那样一个接一个地运行</summary>
      
    
    
    
    <category term="训练营笔记" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
    
    <category term="清华大学开源操作系统训练营2023" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A52023/"/>
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="riscv" scheme="http://example.com/tags/riscv/"/>
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>清华大学开源操作系统训练营: rCore chapter2笔记</title>
    <link href="http://example.com/2024/02/12/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch2%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/02/12/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch2%E7%AC%94%E8%AE%B0/</id>
    <published>2024-02-12T09:28:26.000Z</published>
    <updated>2024-02-21T16:16:04.678Z</updated>
    
    <content type="html"><![CDATA[<p>本文不会将原本<code>rCore文档</code>的内容重复太多, 主要是补充学习过程中遇到的知识点, 因此还需结合原文使用, 原文在后面的链接中</p><p>之前的章节仅仅是一个裸机运行的应用程序, 这一章节通过特权级的引入实现了S态下的<code>OS</code>和U态下的<code>app</code>, <code>app</code>通过系统调用访问<code>OS</code>, <code>OS</code>通过<code>SBI</code>提供的服务完成系统调用, 不过这一章节没有实现进程或线程切换, 而是将程序一个接一个地运行直到结束。</p><p>完整版官方文档： <a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/index.html">https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/index.html</a></p><p>精简版文档： <a href="https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter2/index.html">https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter2/index.html</a></p><h1 id="1-整体流程"><a href="#1-整体流程" class="headerlink" title="1 整体流程"></a>1 整体流程</h1><p>本章的目的是实现批处理系统，文档中称为<code>邓氏鱼OS</code>, 其内容包括:</p><ol><li>编写<code>Rust应用程序</code>, 并使用链接脚本调整内存布局</li><li>为<code>OS</code>实现系统调用</li><li>将应用程序从<code>efl</code>转化为<code>binary</code>, 和<code>OS</code>的代码链接到一起</li><li>实现批处理的任务调度</li><li>引入用户栈和内核栈</li></ol><h1 id="2-特权级"><a href="#2-特权级" class="headerlink" title="2 特权级"></a>2 特权级</h1><h2 id="2-1-特权级的概念"><a href="#2-1-特权级的概念" class="headerlink" title="2.1 特权级的概念"></a>2.1 特权级的概念</h2><p>下面这摘自官方文档张图展示了<code>riscv</code>中不同的特权级:</p><p><img src="/../../../images/LearningOS/ch2-PrivilegeStack.png" alt="PrivilegeStack"></p><p>RISC-V 定义了以下四个特权级别：</p><ol><li><p><strong>用户级别（User-Level or U-Mode）</strong>:<br>就是图中的<code>App</code>所在的级别, 用户级别是最低的特权级别，普通的应用程序在这个级别上运行。在这个级别上，程序不能直接访问硬件资源，如控制I&#x2F;O和管理内存等。用户级别的代码需要通过<strong>系统调用</strong>（<code>syscalls</code>）与更高特权级别的软件交互来请求服务。而<code>syscalls</code>就是应用程序二进制接口, 图中的<code>ABI</code>。程序在用户级别也称为用户态</p></li><li><p><strong>监督者级别（Supervisor-Level or S-Mode）</strong>:<br>监督者级别是操作系统内核通常运行的特权级别。它允许直接控制和管理硬件资源，包括内存管理单元（MMU）、中断处理等。大多数操作系统的内核，如<code>Linux</code>，会在<code>S-Mode</code>下运行。程序在用户级别也称为内核态。操作系统在态下其实也需要想&#x3D;向更低一级的机器模式提出函数请求，这就是<strong>SBI</strong>所做的事情</p></li><li><p><strong>机器级别（Machine-Level or M-Mode）</strong>:<br>机器级别是最高的特权级别，提供对RISC-V硬件的完全控制。它用于引导系统、处理最底层的中断和异常，以及配置系统的安全和保护设置。固件和监控程序，如我们使用的<code>RustSBI</code>（通常在M-Mode下运行。</p></li><li><p><strong>超级用户级别（Hypervisor-Level or H-Mode）</strong>:<br>超级用户级别是为虚拟化环境设计的特权级别，在<code>RISC-V</code>体系结构中是一个可选的特权级别。它允许运行一个超级监控器（<code>hypervisor</code>），在单个物理硬件平台上虚拟化和管理多个独立的操作系统实例。<code>rCore</code>中不涉及这个级别</p></li></ol><h2 id="2-2-特权级的切换"><a href="#2-2-特权级的切换" class="headerlink" title="2.2 特权级的切换"></a>2.2 特权级的切换</h2><p>官网中的这张图清晰地说明了应用程序如何进行特权级切换:</p><p><img src="/../../../images/LearningOS/ch2-EnvironmentCallFlow.png" alt="EnvironmentCallFlow"></p><p>这张图其实还揭示了另一个细节: 不同特权级的内存空间通常是不一样的, 这就和我们常说的用户栈和内核栈联系起来了</p><h2 id="2-3-特权级切换指令和寄存器"><a href="#2-3-特权级切换指令和寄存器" class="headerlink" title="2.3 特权级切换指令和寄存器"></a>2.3 特权级切换指令和寄存器</h2><h3 id="2-3-1-什么时候会发生特权级切换"><a href="#2-3-1-什么时候会发生特权级切换" class="headerlink" title="2.3.1 什么时候会发生特权级切换?"></a>2.3.1 什么时候会发生特权级切换?</h3><p>在RISC-V中，特权级切换通常在以下场景中发生：</p><ol><li><p><strong>系统调用（System Calls）</strong>：当用户程序需要操作系统提供的服务时，如文件操作、内存分配等，它会执行一个<code>ecall</code>指令来触发一个异常，导致处理器从用户模式（U-Mode）切换到监督者模式（S-Mode）或机器模式（<code>M-Mode</code>），这样操作系统可以安全地提供这些服务。</p></li><li><p><strong>中断（Interrupts）</strong>：当外部设备需要处理器的注意时，它会发送一个中断信号。处理器响应中断信号也会导致特权级切换，通常是从较低的特权级别切换到机器模式（<code>M-Mode</code>），以便中断服务程序可以运行并处理中断。</p></li><li><p><strong>异常（Exceptions）</strong>：当程序执行非法操作（如除以零、访问无权限的内存区域）时，或者出现硬件错误，就会发生异常。这将导致从当前特权级别切换到更高的特权级别，以便异常处理程序可以被执行来处理这些问题。</p></li><li><p><strong>特权级返回（Return from Trap）</strong>：当中断或异常处理完成后，通过执行<code>mret</code>、<code>sret</code>或<code>uret</code>指令返回到发生中断或异常之前的特权级别。如果异常无法被正常处理, 则可能退出不会返回用户态, 而是在更高的特权级中尽显处理(<em>关机蓝屏等就是这些更改特权级处理异常的方式</em>)</p></li></ol><p>通过上述情形可以我们可以看出, 异常控制流(区别与一般的函数控制)和特权级切换有下面的好处:</p><ol><li>保护系统和硬件不收错误的程序的损坏</li><li>提供一层抽象, 便于开发</li></ol><h3 id="2-3-2-特权级切换指令和寄存器"><a href="#2-3-2-特权级切换指令和寄存器" class="headerlink" title="2.3.2 特权级切换指令和寄存器"></a>2.3.2 特权级切换指令和寄存器</h3><ol><li><p>特权级切换指令</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td><strong><code>ecall</code></strong></td><td><strong>从用户态或监督者态触发一个环境调用异常，请求操作系统服务</strong></td></tr><tr><td><code>ebreak</code></td><td>触发一个断点异常，用于调试</td></tr><tr><td><code>mret</code></td><td>从机器模式退出中断或异常处理程序并返回到之前的特权级别</td></tr><tr><td><strong><code>sret</code></strong></td><td><strong>从监督者模式退出中断或异常处理程序并返回到之前的特权级别</strong></td></tr><tr><td><code>uret</code></td><td>从用户模式退出中断或异常处理程序并返回到之前的特权级别</td></tr></tbody></table></li><li><p>特权级切换相关寄存器</p><table><thead><tr><th>寄存器</th><th>描述</th></tr></thead><tbody><tr><td><code>mstatus</code></td><td>保存机器模式的全局状态，包括全局中断使能位和特权级切换的状态</td></tr><tr><td><code>ustatus</code></td><td><code>mstatus</code> 的子集，用于保存用户模式的状态信息</td></tr><tr><td><code>mtvec</code></td><td>保存中断和异常处理例程的基地址（机器模式）</td></tr><tr><td><code>utvec</code></td><td>保存用户模式下中断和异常处理例程的基地址</td></tr><tr><td><code>mepc</code></td><td>保存发生异常时的程序计数器值（机器模式）</td></tr><tr><td><code>uepc</code></td><td>保存用户模式下发生异常时的程序计数器值</td></tr><tr><td><code>mcause</code></td><td>保存最后一次异常或中断的原因（机器模式）</td></tr><tr><td><code>ucause</code></td><td>保存用户模式下最后一次异常或中断的原因</td></tr><tr><td><strong><code>sstatus</code></strong></td><td><strong><code>mstatus</code> 的子集，用于保存监督者模式的状态信息</strong></td></tr><tr><td><strong><code>scause</code></strong></td><td><strong>保存监督者模式下最后一次异常或中断的原因</strong></td></tr><tr><td><strong><code>sepc</code></strong></td><td><strong>保存监督者模式下发生异常时的程序计数器值</strong></td></tr><tr><td><strong><code>stval</code></strong></td><td><strong>给出 <code>Trap</code> 附加信息</strong></td></tr><tr><td><strong><code>stvec</code></strong></td><td><strong>保存监督者模式下中断和异常处理例程的基地址</strong></td></tr></tbody></table></li></ol><h1 id="3-特权级切换"><a href="#3-特权级切换" class="headerlink" title="3 特权级切换"></a>3 特权级切换</h1><h2 id="3-1-系统调用"><a href="#3-1-系统调用" class="headerlink" title="3.1 系统调用"></a>3.1 系统调用</h2><p><code>riscv</code>中的系统调用很简单, 相关的代码我们之前也已经见到过:</p><ol><li>把系统调用的参数按照顺序放在<code>a0~a6</code>寄存器后</li><li>把系统调用号放在<code>a7</code>寄存器</li><li>调用<code>ecall</code>触发系统调用</li><li>在<code>a0</code>处获得系统调用的返回值</li></ol><p>系统调用可以使用<code>Rust</code>内联汇编实现:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::arch::asm;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">syscall</span>(id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>: <span class="type">isize</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(</span><br><span class="line">            <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">inlateout</span>(<span class="string">&quot;x10&quot;</span>) args[<span class="number">0</span>] =&gt; ret,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x11&quot;</span>) args[<span class="number">1</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x12&quot;</span>) args[<span class="number">2</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x17&quot;</span>) id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述汇编代码看不懂, 可以看我的上一篇<code>rCode</code>的笔记中关于内联汇编的介绍</p><h2 id="3-2-特权级切换"><a href="#3-2-特权级切换" class="headerlink" title="3.2 特权级切换"></a>3.2 特权级切换</h2><p>系统调用会发生特权级切换, 特权级切换由于执行环境发生了变化, 要求我们在恢复原来的特权级时(例如从内核态返回用户态), 恢复执行环境的上下文。</p><p>发生特权级切换(执行<code>ecall</code>), 此处以陷入<code>S</code>态为例, 时硬件会帮我们做如下工作:</p><ol><li><code>sstatus</code> 的 <code>SPP</code> 字段会被修改为 <code>CPU</code> 当前的特权级</li><li><code>sepc</code> 会被修改为 <code>Trap</code> 处理完成后默认会执行的下一条指令的地址。</li><li><code>scause</code>&#x2F;<code>stval</code> 分别会被修改成这次 <code>Trap</code> 的原因以及相关的附加信息。</li><li><code>CPU</code> 会跳转到 <code>stvec</code> 所设置的 <code>Trap</code> 处理入口地址，并将当前特权级设置为 <code>S</code> ，然后从<code>Trap</code> 处理入口地址处开始执行。</li></ol><p>上述是硬件自动完成的, 如果有其他的寄存器由于陷入内核态后会被使用, 需要提前被保存, 通常会手动保存在栈里, 这些工作可能是<code>stvec</code>一开始就执行的工作</p><p>当使用<code>sret</code>返回用户态时, 系统会帮我们做下面的工作:</p><ol><li><code>CPU</code> 会将当前的特权级按照 <code>sstatus</code> 的 <code>SPP</code> 字段设置为 <code>U</code> 或者 <code>S</code> ；</li><li><code>CPU</code> 会跳转到 <code>sepc</code> 寄存器指向的那条指令，然后继续执行。</li></ol><p>这里特别说明一下<code>sstatus</code> 的 <code>SPP</code>字段如何设置:</p><ol><li><p>调用 <code>ecall</code> 时：</p><ul><li>当从用户模式（U模式）执行 <code>ecall</code> 并陷入到监督者模式（S模式）时，<code>sstatus</code> 寄存器的 <code>SPP</code> 字段会被设置为 0，表示异常发生前处于用户模式。</li><li>如果是从其他特权级别执行 <code>ecall</code>（例如，在 RISC-V 中还有机器模式 M），<code>SPP</code> 字段会被设置为对应于那个特权级别的值。</li></ul></li><li><p>调用 <code>sret</code> 时：</p><ul><li><code>sret</code> 指令用于从监督者模式（S模式）返回到之前的特权级别。在执行 <code>sret</code> 指令时，<code>SPP</code> 字段的值会被用来决定返回到哪个特权级别（U模式或S模式），并且执行 <code>sret</code> 之后，<code>SPP</code> 字段会被清零。</li><li>如果 <code>SPP</code> 是 0，则在执行 <code>sret</code> 后 CPU 返回到用户模式（U模式）。</li><li>如果 <code>SPP</code> 是 1，则在执行 <code>sret</code> 后 CPU 返回到监督者模式（S模式）。</li></ul></li></ol><h1 id="4-用户代码"><a href="#4-用户代码" class="headerlink" title="4 用户代码"></a>4 用户代码</h1><h2 id="4-1-用户代码概览"><a href="#4-1-用户代码概览" class="headerlink" title="4.1 用户代码概览"></a>4.1 用户代码概览</h2><p>用户代码很简单, 项目源码中有4个用户程序:</p><ol><li><p><code>ch2b_bad_address.rs</code></p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> user_lib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 由于 rustsbi 的问题，该程序无法正确退出</span></span><br><span class="line"><span class="comment">/// &gt; rustsbi 0.2.0-alpha.1 已经修复，可以正常退出</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="meta">#[allow(clippy::zero_ptr)]</span></span><br><span class="line">        (<span class="number">0x0</span> <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>).<span class="title function_ invoke__">write_volatile</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;FAIL: T.T\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 该程序向0地址处写入, 预期会触发<code>page fault</code>并退出</p></li><li><p><code>ch2b_bad_instructions.rs</code></p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> user_lib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 由于 rustsbi 的问题，该程序无法正确退出</span></span><br><span class="line"><span class="comment">/// &gt; rustsbi 0.2.0-alpha.1 已经修复，可以正常退出</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        core::arch::asm!(<span class="string">&quot;sret&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;FAIL: T.T\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 该程序在<code>U模式</code>下使用<code>sret</code>, 应当是非法指令</p></li><li><p><code>ch2b_bad_register.rs</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> user_lib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 由于 rustsbi 的问题，该程序无法正确退出</span></span><br><span class="line"><span class="comment">/// &gt; rustsbi 0.2.0-alpha.1 已经修复，可以正常退出</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sstatus</span>: <span class="type">usize</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        core::arch::asm!(<span class="string">&quot;csrr &#123;&#125;, sstatus&quot;</span>, <span class="title function_ invoke__">out</span>(reg) sstatus);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;(-_-) I get sstatus:&#123;:x&#125;\nFAIL: T.T\n&quot;</span>, sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 该程序在<code>U模式</code>下访问<code>csr</code>寄存器<code>sstatus</code>, 应当也是非法指令</p></li><li><p><code>ch2b_hello_world.rs</code></p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> user_lib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 正确输出：</span></span><br><span class="line"><span class="comment">/// Hello world from user mode program!</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Hello, world from user mode program!&quot;</span>);</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 该程序是唯一正常输出的程序</p></li></ol><h2 id="4-2-用户库user-lib"><a href="#4-2-用户库user-lib" class="headerlink" title="4.2 用户库user_lib"></a>4.2 用户库<code>user_lib</code></h2><p>上述的代码都使用了<code>user_lib</code>库, 也就是<code>user/src</code>下的<code>rust</code>项目, 其作用就是封装了了多个系统调用函数, 每个系统调用都使用对应的系统调用号、参数或地址调用<a href="#3-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><strong>3 系统调用</strong></a>中的<code>syscall</code>函数, 例如:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_exit</span>(exit_code: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_EXIT, [exit_code <span class="keyword">as</span> <span class="type">usize</span>, <span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;sys_exit never returns!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_sleep</span>(sleep_ms: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_SLEEP, [sleep_ms, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_yield</span>() <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_YIELD, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="5-内核代码"><a href="#5-内核代码" class="headerlink" title="5 内核代码"></a>5 内核代码</h1><h2 id="5-1-内核代码和用户代码的链接"><a href="#5-1-内核代码和用户代码的链接" class="headerlink" title="5.1 内核代码和用户代码的链接"></a>5.1 内核代码和用户代码的链接</h2><p>这章的内核系统是和用户代码链接到一起的, 也就是说不存在从文件系统加载<code>elf</code>文件这样的步骤, 毕竟在学习<code>OS</code>的起步阶段, 文件系统离我们还挺遥远的, 具体而言, <code>os/src/main.rs</code>中的这句代码实现了用户代码的链接:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;link_app.S&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><blockquote><p><code>link_app.S</code>是构建脚本<code>build.rs</code>生成的, 其将用户仓库的编译文件夹<code>bin</code>目录下的二进制文件整整合到一起, 名创建各个<code>app</code>的符号</p></blockquote></blockquote><h2 id="5-2-内核的调度"><a href="#5-2-内核的调度" class="headerlink" title="5.2 内核的调度"></a>5.2 内核的调度</h2><h3 id="5-2-1-调度器的数据结构"><a href="#5-2-1-调度器的数据结构" class="headerlink" title="5.2.1 调度器的数据结构"></a>5.2.1 调度器的数据结构</h3><p>内核调度是按照顺序一个接一个地调用用户应用, 其主要数据结构为:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AppManager</span> &#123;</span><br><span class="line">    num_app: <span class="type">usize</span>,</span><br><span class="line">    current_app: <span class="type">usize</span>,</span><br><span class="line">    app_start: [<span class="type">usize</span>; MAX_APP_NUM + <span class="number">1</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文档中还介绍了<code>Rust</code>相关的语法知识, 后面的章节会整理出来</p><h3 id="5-2-2-加载程序"><a href="#5-2-2-加载程序" class="headerlink" title="5.2.2 加载程序"></a>5.2.2 加载程序</h3><p>最重要的调度函数是<code>load_app</code>, 其功能就是加载程序, 实际上并不是从文件系统加载, 而是从内核的某一个区段进行复制:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">load_app</span>(&amp;<span class="keyword">self</span>, app_id: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> app_id &gt;= <span class="keyword">self</span>.num_app &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;All applications completed!&quot;</span>);</span><br><span class="line">        <span class="keyword">use</span> crate::board::QEMUExit;</span><br><span class="line">        crate::board::QEMU_EXIT_HANDLE.<span class="title function_ invoke__">exit_success</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;[kernel] Loading app_&#123;&#125;&quot;</span>, app_id);</span><br><span class="line">    <span class="comment">// clear app area</span></span><br><span class="line">    core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, APP_SIZE_LIMIT).<span class="title function_ invoke__">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">app_src</span> = core::slice::<span class="title function_ invoke__">from_raw_parts</span>(</span><br><span class="line">        <span class="keyword">self</span>.app_start[app_id] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>,</span><br><span class="line">        <span class="keyword">self</span>.app_start[app_id + <span class="number">1</span>] - <span class="keyword">self</span>.app_start[app_id],</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">app_dst</span> = core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, app_src.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    app_dst.<span class="title function_ invoke__">copy_from_slice</span>(app_src);</span><br><span class="line">    <span class="comment">// Memory fence about fetching the instruction memory</span></span><br><span class="line">    <span class="comment">// It is guaranteed that a subsequent instruction fetch must</span></span><br><span class="line">    <span class="comment">// observes all previous writes to the instruction memory.</span></span><br><span class="line">    <span class="comment">// Therefore, fence.i must be executed after we have loaded</span></span><br><span class="line">    <span class="comment">// the code of the next app into the instruction memory.</span></span><br><span class="line">    <span class="comment">// See also: riscv non-priv spec chapter 3, &#x27;Zifencei&#x27; extension.</span></span><br><span class="line">    asm!(<span class="string">&quot;fence.i&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以从代码看出, 所有的<code>app</code>都是在<code>APP_BASE_ADDRESS</code>地址处运行的, <strong>每个<code>app</code>运行前都需要将其从其二进制代码的地址处复制到<code>APP_BASE_ADDRESS</code>地址处</strong>, 这也是<code>load_app</code>的核心工作</p><h2 id="5-3-Trap上下文切换"><a href="#5-3-Trap上下文切换" class="headerlink" title="5.3 Trap上下文切换"></a>5.3 <code>Trap</code>上下文切换</h2><h3 id="5-3-1-用户栈和内核栈"><a href="#5-3-1-用户栈和内核栈" class="headerlink" title="5.3.1 用户栈和内核栈"></a>5.3.1 用户栈和内核栈</h3><p>正如之前的<a href="#32-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%88%87%E6%8D%A2">3 特权级切换</a>中说明, 特权级切换时需要用栈来保存上下文信息, 因此需要定义内核栈和用户栈:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/batch.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> USER_STACK_SIZE: <span class="type">usize</span> = <span class="number">4096</span> * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> KERNEL_STACK_SIZE: <span class="type">usize</span> = <span class="number">4096</span> * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(align(4096))]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">KernelStack</span> &#123;</span><br><span class="line">    data: [<span class="type">u8</span>; KERNEL_STACK_SIZE],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(align(4096))]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UserStack</span> &#123;</span><br><span class="line">    data: [<span class="type">u8</span>; USER_STACK_SIZE],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> KERNEL_STACK: KernelStack = KernelStack &#123; data: [<span class="number">0</span>; KERNEL_STACK_SIZE] &#125;;</span><br><span class="line"><span class="keyword">static</span> USER_STACK: UserStack = UserStack &#123; data: [<span class="number">0</span>; USER_STACK_SIZE] &#125;;</span><br></pre></td></tr></table></figure><h3 id="5-3-2-上下文信息"><a href="#5-3-2-上下文信息" class="headerlink" title="5.3.2 上下文信息"></a>5.3.2 上下文信息</h3><p>本来不打算分析代码, 但这里的代码贯穿了整个<code>OS</code>, 所以特别介绍一下:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> riscv::register::sstatus::&#123;<span class="keyword">self</span>, Sstatus, SPP&#125;;</span><br><span class="line"><span class="comment">/// Trap Context</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TrapContext</span> &#123;</span><br><span class="line">    <span class="comment">/// general regs[0..31]</span></span><br><span class="line">    <span class="keyword">pub</span> x: [<span class="type">usize</span>; <span class="number">32</span>],</span><br><span class="line">    <span class="comment">/// CSR sstatus      </span></span><br><span class="line">    <span class="keyword">pub</span> sstatus: Sstatus,</span><br><span class="line">    <span class="comment">/// CSR sepc</span></span><br><span class="line">    <span class="keyword">pub</span> sepc: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TrapContext</span> &#123;</span><br><span class="line">    <span class="comment">/// set stack pointer to x_2 reg (sp)</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_sp</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, sp: <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x[<span class="number">2</span>] = sp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// init app context</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">app_init_context</span>(entry: <span class="type">usize</span>, sp: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sstatus</span> = sstatus::<span class="title function_ invoke__">read</span>(); <span class="comment">// CSR sstatus</span></span><br><span class="line">        sstatus.<span class="title function_ invoke__">set_spp</span>(SPP::User); <span class="comment">//previous privilege mode: user mode</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cx</span> = <span class="keyword">Self</span> &#123;</span><br><span class="line">            x: [<span class="number">0</span>; <span class="number">32</span>],</span><br><span class="line">            sstatus,</span><br><span class="line">            sepc: entry, <span class="comment">// entry point of app</span></span><br><span class="line">        &#125;;</span><br><span class="line">        cx.<span class="title function_ invoke__">set_sp</span>(sp); <span class="comment">// app&#x27;s user stack pointer</span></span><br><span class="line">        cx <span class="comment">// return initial Trap Context of app</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段 <code>Rust</code> 代码定义了<code>TrapContext</code> 的结构体，它用于保存程序的上下文，即在发生异常或中断时需要保存的状态信息，以便之后能够恢复执行, 包括通用寄存器、特殊控制状态寄存器（如 <code>sstatus</code> 和 <code>sepc</code>）等。同时实现了每个<code>app</code>的上下文初始化方法</p><h3 id="5-3-3-app调度"><a href="#5-3-3-app调度" class="headerlink" title="5.3.3 app调度"></a>5.3.3 <code>app</code>调度</h3><p>上面的上下文在什么时候回被访问呢? 首先看看调度<code>app</code>的函数:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run_next_app</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">app_manager</span> = APP_MANAGER.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">current_app</span> = app_manager.<span class="title function_ invoke__">get_current_app</span>();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        app_manager.<span class="title function_ invoke__">load_app</span>(current_app);</span><br><span class="line">    &#125;</span><br><span class="line">    app_manager.<span class="title function_ invoke__">move_to_next_app</span>();</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(app_manager);</span><br><span class="line">    <span class="comment">// before this we have to drop local variables related to resources manually</span></span><br><span class="line">    <span class="comment">// and release the resources</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">__restore</span>(cx_addr: <span class="type">usize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __restore(KERNEL_STACK.<span class="title function_ invoke__">push_context</span>(TrapContext::<span class="title function_ invoke__">app_init_context</span>(</span><br><span class="line">            APP_BASE_ADDRESS,</span><br><span class="line">            USER_STACK.<span class="title function_ invoke__">get_sp</span>(),</span><br><span class="line">        )) <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Unreachable in batch::run_current_app!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, <code>load_app</code>已经通过<code>load_app</code>将指定的内容加载到了内存的固定位置, 然后运行这个程序调用的是<code>__restore</code>, 这是什么? 这是<code>trap.S</code>中用汇编代码写的上下文切换时的保存和回复寄存器的函数, 接下来将仔细解读</p><h3 id="5-3-4-Trap恢复上下文"><a href="#5-3-4-Trap恢复上下文" class="headerlink" title="5.3.4 Trap恢复上下文"></a>5.3.4 <code>Trap</code>恢复上下文</h3><p>首先, 还是贴出<code>trap.S</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">.altmacro</span><br><span class="line">.macro SAVE_GP n</span><br><span class="line">    sd x\n, \n*8(sp)</span><br><span class="line">.endm</span><br><span class="line">.macro LOAD_GP n</span><br><span class="line">    ld x\n, \n*8(sp)</span><br><span class="line">.endm</span><br><span class="line">    .section .text</span><br><span class="line">    .globl __alltraps</span><br><span class="line">    .globl __restore</span><br><span class="line">    .align 2</span><br><span class="line">__alltraps:</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    <span class="comment"># now sp-&gt;kernel stack, sscratch-&gt;user stack</span></span><br><span class="line">    <span class="comment"># allocate a TrapContext on kernel stack</span></span><br><span class="line">    addi sp, sp, -34*8</span><br><span class="line">    <span class="comment"># save general-purpose registers</span></span><br><span class="line">    sd x1, 1*8(sp)</span><br><span class="line">    <span class="comment"># skip sp(x2), we will save it later</span></span><br><span class="line">    sd x3, 3*8(sp)</span><br><span class="line">    <span class="comment"># skip tp(x4), application does not use it</span></span><br><span class="line">    <span class="comment"># save x5~x31</span></span><br><span class="line">    .<span class="built_in">set</span> n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        SAVE_GP %n</span><br><span class="line">        .<span class="built_in">set</span> n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    <span class="comment"># we can use t0/t1/t2 freely, because they were saved on kernel stack</span></span><br><span class="line">    csrr t0, sstatus</span><br><span class="line">    csrr t1, sepc</span><br><span class="line">    sd t0, 32*8(sp)</span><br><span class="line">    sd t1, 33*8(sp)</span><br><span class="line">    <span class="comment"># read user stack from sscratch and save it on the kernel stack</span></span><br><span class="line">    csrr t2, sscratch</span><br><span class="line">    sd t2, 2*8(sp)</span><br><span class="line">    <span class="comment"># set input argument of trap_handler(cx: &amp;mut TrapContext)</span></span><br><span class="line">    <span class="built_in">mv</span> a0, sp</span><br><span class="line">    call trap_handler</span><br><span class="line"></span><br><span class="line">__restore:</span><br><span class="line">    <span class="comment"># case1: start running app by __restore</span></span><br><span class="line">    <span class="comment"># case2: back to U after handling trap</span></span><br><span class="line">    <span class="built_in">mv</span> sp, a0</span><br><span class="line">    <span class="comment"># now sp-&gt;kernel stack(after allocated), sscratch-&gt;user stack</span></span><br><span class="line">    <span class="comment"># restore sstatus/sepc</span></span><br><span class="line">    ld t0, 32*8(sp)</span><br><span class="line">    ld t1, 33*8(sp)</span><br><span class="line">    ld t2, 2*8(sp)</span><br><span class="line">    csrw sstatus, t0</span><br><span class="line">    csrw sepc, t1</span><br><span class="line">    csrw sscratch, t2</span><br><span class="line">    <span class="comment"># restore general-purpuse registers except sp/tp</span></span><br><span class="line">    ld x1, 1*8(sp)</span><br><span class="line">    ld x3, 3*8(sp)</span><br><span class="line">    .<span class="built_in">set</span> n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        LOAD_GP %n</span><br><span class="line">        .<span class="built_in">set</span> n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    <span class="comment"># release TrapContext on kernel stack</span></span><br><span class="line">    addi sp, sp, 34*8</span><br><span class="line">    <span class="comment"># now sp-&gt;kernel stack, sscratch-&gt;user stack</span></span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    sret</span><br></pre></td></tr></table></figure><p>该 <code>trap.S</code>用于处理中断和异常。代码中定义了两个全局入口点：<code>__alltraps</code> 用于在中断或异常发生时保存上下文，<code>__restore</code> 用于恢复上下文并返回到用户态或继续执行应用程序。</p><ol><li><p><code>__alltraps</code> 入口点</p><ol><li><code>csrrw sp, sscratch, sp</code>：交换 <code>sscratch</code> 和 <code>sp</code> 的值。<code>sscratch</code> 通常用来暂存用户栈指针，在发生异常时切换到内核栈。</li><li><code>addi sp, sp, -34*8</code>：在内核栈上分配 <code>TrapContext</code> 结构体所需的空间。</li><li>保存通用寄存器到内核栈上。跳过 <code>sp</code>（x2）和 <code>tp</code>（x4），因为 <code>sp</code> 会在后面单独保存，而 <code>tp</code>（线程指针）可能不被应用使用。</li><li>使用 <code>csrr</code> 指令读取 <code>sstatus</code> 和 <code>sepc</code> 寄存器的值，并保存到栈上。</li><li>从 <code>sscratch</code> 寄存器读取用户栈指针，保存到内核栈上。</li><li>将栈指针 <code>sp</code> 的值移到 <code>a0</code> 寄存器，作为 <code>trap_handler</code> 函数的参数（<code>cx: &amp;mut TrapContext</code>）。</li><li>调用 <code>trap_handler</code> 函数处理异常。</li></ol></li><li><p><code>__restore</code> 入口点</p><ol><li><code>mv sp, a0</code>：恢复 <code>sp</code> 寄存器的值，<code>a0</code> 中包含了指向 <code>TrapContext</code> 的指针。</li><li>从内核栈上加载 <code>sstatus</code>、<code>sepc</code> 和用户栈指针到临时寄存器 <code>t0</code>、<code>t1</code> 和 <code>t2</code>。</li><li>使用 <code>csrw</code> 指令恢复 <code>sstatus</code>、<code>sepc</code> 和 <code>sscratch</code> 寄存器的值。</li><li>从内核栈上恢复其他通用寄存器的值（除了 <code>sp</code> 和 <code>tp</code>）。</li><li><code>addi sp, sp, 34*8</code>：释放在内核栈上分配的 <code>TrapContext</code> 空间。</li><li>再次交换 <code>sscratch</code> 和 <code>sp</code> 的值，恢复用户栈指针到 <code>sp</code>。</li><li>执行 <code>sret</code> 指令返回到用户态或应用程序。</li></ol></li></ol><p>另一个值得注意的点是, <code>__restore</code> 在两种情况下被使用，它既是异常处理完毕后恢复应用程序状态的入口点，也是应用程序第一次开始执行时的入口点。在应用程序第一次开始执行时，<code>__restore</code> 这一步并不是在 “恢复” 任何先前的状态，因为此时还没有任何状态可以恢复。相反，它是在初始化应用程序的执行环境, 具体而言需要再栈中压入构造的<code>Trap Context</code>。在这种情况下，栈上加载的内容（如 <code>sstatus</code>、<code>sepc</code> 和 <code>sscratch</code>）是由操作系统预先设定好的，而不是由之前的应用程序执行状态保存的。这些值会设置为允许应用程序在用户模式下执行的正确状态，并确保了程序计数器（<code>sepc</code>）指向应用程序的入口点。</p><h2 id="5-4-Trap-Handler"><a href="#5-4-Trap-Handler" class="headerlink" title="5.4 Trap Handler"></a>5.4 <code>Trap Handler</code></h2><p>还是先贴出代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/trap/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">trap_handler</span>(cx: &amp;<span class="keyword">mut</span> TrapContext) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> TrapContext &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scause</span> = scause::<span class="title function_ invoke__">read</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stval</span> = stval::<span class="title function_ invoke__">read</span>();</span><br><span class="line">    <span class="keyword">match</span> scause.<span class="title function_ invoke__">cause</span>() &#123;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::UserEnvCall) =&gt; &#123;</span><br><span class="line">            cx.sepc += <span class="number">4</span>;</span><br><span class="line">            cx.x[<span class="number">10</span>] = <span class="title function_ invoke__">syscall</span>(cx.x[<span class="number">17</span>], [cx.x[<span class="number">10</span>], cx.x[<span class="number">11</span>], cx.x[<span class="number">12</span>]]) <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::StoreFault) |</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::StorePageFault) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] PageFault in application, kernel killed it.&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">run_next_app</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::IllegalInstruction) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] IllegalInstruction in application, kernel killed it.&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">run_next_app</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Unsupported trap &#123;:?&#125;, stval = &#123;:#x&#125;!&quot;</span>, scause.<span class="title function_ invoke__">cause</span>(), stval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>trap handler</code>根据<code>scause</code>分类处理, 目前实现了:</p><ol><li>系统调用陷入<code>S</code>态时执行系统调用</li><li>非法指令和页错误直接运行下一个程序</li><li>其余情况直接<code>panic</code></li></ol><p>分发的系统调用目前实现还比较简单, 因为此时还没有页表, 我们的地址都是物理地址, 因此不需要地址转换, 所以没啥好说的, 看项目代码就是了</p><h2 id="5-5-流程图"><a href="#5-5-流程图" class="headerlink" title="5.5 流程图"></a>5.5 流程图</h2><p>下面是我整理的一个示意图, 展示了特权级切换的流程:</p><p><img src="/../../../images/LearningOS/ch2-batchOS.png" alt="switch-process"></p><p>红色表示<code>S</code>态的函数, 蓝色表示<code>U</code>态的函数</p><h1 id="6-补充知识"><a href="#6-补充知识" class="headerlink" title="6 补充知识"></a>6 补充知识</h1><h2 id="6-1-Rust补充知识"><a href="#6-1-Rust补充知识" class="headerlink" title="6.1 Rust补充知识"></a>6.1 <code>Rust</code>补充知识</h2><h3 id="6-1-1-RefCell"><a href="#6-1-1-RefCell" class="headerlink" title="6.1.1 RefCell"></a>6.1.1 <code>RefCell</code></h3><p>在项目代码中, 我们封装了<code>RefCell</code>形成了<code>UPSafeCell</code>, 那么<code>RefCell</code>是什么?</p><p>官方的描述是: <code>RefCell&lt;T&gt;</code> 提供了内部可变性。这意味着即使在 <code>RefCell&lt;T&gt;</code> 的引用是不可变的情况下，也可以改变它所包含的值。这违反了 Rust 的借用规则——即通常情况下，不能同时拥有可变和不可变引用，以及不可变引用不能用来改变值。</p><p>简单来说，就是<code>Rust</code>的编译器检查太严格了, 当我们编写底层代码时, 编译时想绕过不可变借用的检查就可以使用<code>RefCell</code>。尤其是这样一个场景： <strong>当需要在一个不可变的引用上修改数据时</strong>。</p><p>不过绕过编译器检查还有运行期检查， <code>RefCell&lt;T&gt;</code> 使用运行时检查来确保借用规则，这是与编译时检查相对的（如通过 <code>&amp;</code> 和 <code>&amp;mut</code> 引用实现的）。从 <code>RefCell&lt;T&gt;</code> 中借用值时，如果违反了借用规则（例如，尝试进行两个可变借用或同时进行一个可变借用和任意数量的不可变借用），它会导致程序在运行时 <code>panic</code>。</p><p>下面是 <code>RefCell&lt;T&gt;</code> 的一个简单例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过value.borrow_mut()来借用可变引用。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">value_borrow_mut</span> = value.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">    *value_borrow_mut += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这时，value已经被可变地借用，所以尝试再次借用会导致panic！</span></span><br><span class="line">    <span class="comment">// 下面的行如果取消注释，将会在运行时产生panic。</span></span><br><span class="line">    <span class="comment">// let value_borrow_mut2 = value.borrow_mut();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;value: &#123;&#125;&quot;</span>, value_borrow_mut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个可变引用离开作用域，所以可以再次借用。</span></span><br><span class="line">    <span class="title function_ invoke__">drop</span>(value_borrow_mut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在可以再次借用，因为之前的可变引用已经结束。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value_borrow</span> = value.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;value: &#123;&#125;&quot;</span>, value_borrow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-2-bitflags"><a href="#6-1-2-bitflags" class="headerlink" title="6.1.2 bitflags"></a>6.1.2 <code>bitflags</code></h3><p>我们看到项目代码中使用<code>bitflags!</code>宏来创建各种掩码并进行掩码操作，官方地说就是创建一个或多个位标志的集合。这些位标志通常用于表示一组开关或状态，每个开关或状态可以独立开启或关闭，通常用于配置选项或权限设置等场景。&#96;</p><p><code>bitflags</code>是社区包，需要在<code>Cargo.toml</code>文件中添加<code>bitflags crate</code>作为依赖。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">bitflags</span> = <span class="string">&quot;1.0&quot;</span></span><br></pre></td></tr></table></figure><p>下面是一个标志位使用的案例:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入`bitflags`宏</span></span><br><span class="line"><span class="keyword">use</span> bitflags::bitflags;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用`bitflags!`宏定义一个名为`Flags`的位标志类型</span></span><br><span class="line"><span class="built_in">bitflags!</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Flags</span>: <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> FLAG_A = <span class="number">0b00000001</span>;</span><br><span class="line">        <span class="keyword">const</span> FLAG_B = <span class="number">0b00000010</span>;</span><br><span class="line">        <span class="keyword">const</span> FLAG_C = <span class="number">0b00000100</span>;</span><br><span class="line">        <span class="keyword">const</span> FLAG_D = <span class="number">0b00001000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个新的Flags实例，初始没有任何标志设置</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">flags</span> = Flags::<span class="title function_ invoke__">empty</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置FLAG_A和FLAG_C</span></span><br><span class="line">    flags.<span class="title function_ invoke__">insert</span>(Flags::FLAG_A | Flags::FLAG_C);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查FLAG_B是否被设置</span></span><br><span class="line">    <span class="keyword">if</span> flags.<span class="title function_ invoke__">contains</span>(Flags::FLAG_B) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Flag B is set.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Flag B is not set.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除FLAG_A</span></span><br><span class="line">    flags.<span class="title function_ invoke__">remove</span>(Flags::FLAG_A);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换FLAG_D的状态</span></span><br><span class="line">    flags.<span class="title function_ invoke__">toggle</span>(Flags::FLAG_D);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有设置的标志</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Current flags: &#123;:?&#125;&quot;</span>, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>Flags</code>是一个包含四个位标志的新类型：<code>FLAG_A</code>、<code>FLAG_B</code>、<code>FLAG_C</code>和<code>FLAG_D</code>。</li><li>每个标志都赋予了不同的位模式，使得它们可以独立设置和清除。</li><li><code>Flags::empty()</code>创建了一个没有任何标志设置的<code>Flags</code>实例。</li><li><code>insert</code>方法用来设置特定的标志。</li><li><code>contains</code>方法用来检查特定的标志是否已经设置。</li><li><code>remove</code>方法用来清除特定的标志。</li><li><code>toggle</code>方法用来切换特定标志的状态。</li></ul><h3 id="6-1-3-lazy-static"><a href="#6-1-3-lazy-static" class="headerlink" title="6.1.3 lazy_static"></a>6.1.3 <code>lazy_static</code></h3><p><code>lazy_static</code>主要用于这样的需求: 想要创建一个全局变量, 但其初始化的值在编写代码时还不知道, 需要稍后初始化。在<code>Rust</code>中, 如果创建全局变量后再初始化会很繁琐, <code>lazy_static</code>简化了以上需求的操作难度</p><p>使用 <code>lazy_static</code> 创建的静态变量是线程安全的，并且保证只初始化一次。初始化发生在变量首次被访问的时候，并且如果初始化过程中发生了 <code>panic</code>，后续尝试访问该变量将会导致 <code>panic</code>。</p><p>下面是一个 <code>lazy_static</code> 的简单例子：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">lazy_static</span> = <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> lazy_static;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> MY_MAP: HashMap&lt;<span class="type">u32</span>, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">m</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        m.<span class="title function_ invoke__">insert</span>(<span class="number">0</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        m.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        m</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The entry for `0` is \&quot;&#123;&#125;\&quot;.&quot;</span>, MY_MAP.<span class="title function_ invoke__">get</span>(&amp;<span class="number">0</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>MY_MAP</code> 是一个 <code>HashMap</code>，它在首次被 <code>main</code> 函数中的 <code>println!</code> 宏访问时被创建和初始化。由于 <code>lazy_static</code> 保证了线程安全和只初始化一次，<code>MY_MAP</code> 可以在程序的任何地方安全地使用，就像其他静态变量一样。</p><h3 id="6-1-4-drain"><a href="#6-1-4-drain" class="headerlink" title="6.1.4 drain"></a>6.1.4 <code>drain</code></h3><p><code>drain</code>是<code>String</code>类型的方法，用来移除并遍历字符串的一部分内容。<code>drain</code> 方法会在原地修改 <code>String</code>，并返回一个迭代器，该迭代器提供被移除部分的字符。</p><p>使用 <code>drain</code> 方法时，需要指定一个范围来表明想要从字符串中移除哪些字符。范围是采用字节索引而非字符索引，这意味着必须确保范围的边界落在有效的<code>UTF-8字</code>符边界上，否则程序会在运行时<code>panic</code></p><p>以下是一个使用 <code>drain</code> 方法的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="comment">// 移除字符串中的 &quot;world&quot; 部分</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">drained</span>: <span class="type">String</span> = s.<span class="title function_ invoke__">drain</span>(<span class="number">7</span>..<span class="number">12</span>).<span class="title function_ invoke__">collect</span>(); <span class="comment">// world</span></span><br><span class="line">    <span class="comment">// 输出被移除的部分</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Drained part: &#123;&#125;&quot;</span>, drained);</span><br><span class="line">    <span class="comment">// 输出修改后的字符串</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Remaining string: &#123;&#125;&quot;</span>, s); <span class="comment">// &quot;Hello, !</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-5-项目代码中使用过的宏"><a href="#6-1-5-项目代码中使用过的宏" class="headerlink" title="6.1.5 项目代码中使用过的宏"></a>6.1.5 项目代码中使用过的宏</h3><p>下面是我整理的项目代码中使用的<code>rust</code>宏的含义, 这些宏大概了解其作用就可以, 在需要用时知道查什么关键字即可:<br>以下是对所提供的 Rust 属性和宏的解释，整理成 Markdown 表格的形式：</p><table><thead><tr><th>宏&#x2F;属性</th><th>解释</th></tr></thead><tbody><tr><td><code>#[repr(align(4096))]</code></td><td>设置结构体或枚举的内存对齐方式为 4096 字节。</td></tr><tr><td><code>#![feature(panic_info_message)]</code></td><td>允许使用实验性的 <code>panic_info_message</code> 功能，此功能允许访问 panic 信息中的消息内容。</td></tr><tr><td><code>#[macro_use]</code></td><td>允许在当前作用域中使用外部 <code>crate</code> 中定义的宏。</td></tr><tr><td><code>use core::arch::global_asm;</code></td><td>引入 <code>global_asm!</code> 宏，允许在 <code>Rust</code> 代码中嵌入全局汇编指令。</td></tr><tr><td><code>#[path = &quot;boards/qemu.rs&quot;]</code> <code>mod board</code>;</td><td>指定模块文件的路径，这里是将模块文件定位到 <code>boards/qemu.rs</code>。</td></tr><tr><td><code>#[no_mangle]</code></td><td>禁用名称修饰，确保编译器生成的函数名称与在 <code>Rust</code> 中声明的名称相同。</td></tr><tr><td><code>#[inline(always)]</code></td><td>告诉编译器总是内联一个函数，无论编译器优化策略如何。</td></tr><tr><td><code>#[linkage = &quot;weak&quot;]</code></td><td>指定符号的链接强度为弱链接，允许在多个对象文件中定义相同的全局符号而不会导致链接错误，链接器将选择其中一个定义。</td></tr><tr><td><code>#[link_section = &quot;.text.entry&quot;]</code></td><td>指定函数或静态变量应该放置在特定的链接段中，在这个例子中是一个名为 <code>.text.entry</code> 的段。</td></tr><tr><td><code>#[repr(C)]</code></td><td>设置结构体或枚举的内存布局为 C 语言风格，这在与 C 代码交互时非常有用，因为它能保证字段在内存中的布局与 C 结构体相同。</td></tr><tr><td><code>#![feature(linkage)]</code></td><td>允许使用实验性的 <code>linkage</code> 属性，这个属性用于控制符号的链接方式。</td></tr><tr><td><code>#![feature(alloc_error_handler)]</code></td><td>允许自定义全局内存分配错误处理器。</td></tr><tr><td><code>#![no_std]</code></td><td>表明当前的程序或库不会链接到 <code>Rust</code> 的标准库 <code>std</code>，通常用于裸机或嵌入式编程中，其中资源受限，只能依赖核心库 <code>core</code>。</td></tr><tr><td><code>#![no_main]</code></td><td>禁用 <code>Rust</code> 默认的入口点，这通常用在裸机或操作系统开发中，因为在这些情况下开发者需要自定义入口点。</td></tr></tbody></table><h3 id="6-1-6-build-rs构建脚本"><a href="#6-1-6-build-rs构建脚本" class="headerlink" title="6.1.6 build.rs构建脚本"></a>6.1.6 <code>build.rs</code>构建脚本</h3><p><code>Rust</code> 中，<code>build.rs</code> 是一个特殊的脚本，被称为”构建脚本”（build script）。它在项目构建过程的开始阶段被 <code>Cargo</code>执行。构建脚本通常用于编译时计算或生成代码、构建或链接非 <code>Rust</code> 代码（例如 C 库），或自动生成 <code>Rust</code> 代码之前的某些配置。</p><ol><li>构建脚本是可选的，只有当项目需要在编译前执行特定的任务时才会使用到。这个脚本必须是一个有效的 <code>Rust</code> 程序，<code>Cargo</code> 会将其编译并执行。</li><li>当运行 <code>cargo build</code> 或相关的 <code>Cargo</code> 构建命令时，<code>Cargo</code> 会在编译项目的其余部分之前运行 <code>build.rs</code> 脚本。如果构建脚本执行成功，它可能会通过创建一个 <code>OUT_DIR</code> 环境变量来生成文件，Rust 代码可以在编译时通过 <code>include!</code> 或其他宏来访问这些文件。</li><li>如果 <code>build.rs</code> 脚本生成了编译器指令，它们将作为标准输出打印，并被 Cargo 捕获。这些指令可以包括链接库、设置环境变量、传递编译器标志等。</li></ol><p>在本项目中, <code>build.rs</code>用于生成<code>link_app.S</code>汇编文件, 将<code>user</code>项目编译的二进制文件引入进来：</p><h2 id="6-2-riscv汇编代码补充知识"><a href="#6-2-riscv汇编代码补充知识" class="headerlink" title="6.2 riscv汇编代码补充知识"></a>6.2 riscv汇编代码补充知识</h2><h3 id="6-2-1-变量声明与二进制文件嵌入"><a href="#6-2-1-变量声明与二进制文件嵌入" class="headerlink" title="6.2.1 变量声明与二进制文件嵌入"></a>6.2.1 变量声明与二进制文件嵌入</h3><p>这次新增的<code>riscv</code>汇编代码主要是<code>link_app.S</code>这个文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">    .align 3</span><br><span class="line">    .section .data</span><br><span class="line">    .global _num_app</span><br><span class="line">_num_app:</span><br><span class="line">    .quad 7</span><br><span class="line">    .quad app_0_start</span><br><span class="line">    .quad app_1_start</span><br><span class="line">    .quad app_2_start</span><br><span class="line">    .quad app_3_start</span><br><span class="line">    .quad app_4_start</span><br><span class="line">    .quad app_5_start</span><br><span class="line">    .quad app_6_start</span><br><span class="line">    .quad app_6_end</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_0_start</span><br><span class="line">    .global app_0_end</span><br><span class="line">app_0_start:</span><br><span class="line">    .incbin <span class="string">&quot;../user/build/bin/ch2b_bad_address.bin&quot;</span></span><br><span class="line">app_0_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_1_start</span><br><span class="line">    .global app_1_end</span><br><span class="line">app_1_start:</span><br><span class="line">    .incbin <span class="string">&quot;../user/build/bin/ch2b_bad_instructions.bin&quot;</span></span><br><span class="line">app_1_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_2_start</span><br><span class="line">    .global app_2_end</span><br><span class="line">app_2_start:</span><br><span class="line">    .incbin <span class="string">&quot;../user/build/bin/ch2b_bad_register.bin&quot;</span></span><br><span class="line">app_2_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_3_start</span><br><span class="line">    .global app_3_end</span><br><span class="line">app_3_start:</span><br><span class="line">    .incbin <span class="string">&quot;../user/build/bin/ch2b_hello_world.bin&quot;</span></span><br><span class="line">app_3_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_4_start</span><br><span class="line">    .global app_4_end</span><br><span class="line">app_4_start:</span><br><span class="line">    .incbin <span class="string">&quot;../user/build/bin/ch2b_power_3.bin&quot;</span></span><br><span class="line">app_4_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_5_start</span><br><span class="line">    .global app_5_end</span><br><span class="line">app_5_start:</span><br><span class="line">    .incbin <span class="string">&quot;../user/build/bin/ch2b_power_5.bin&quot;</span></span><br><span class="line">app_5_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_6_start</span><br><span class="line">    .global app_6_end</span><br><span class="line">app_6_start:</span><br><span class="line">    .incbin <span class="string">&quot;../user/build/bin/ch2b_power_7.bin&quot;</span></span><br><span class="line">app_6_end:</span><br></pre></td></tr></table></figure><p>上述汇编代码定义类每一个<code>app</code>的起始位置的符号, 设计的新的语法如下:</p><ol><li><code>.quad</code><br>用于定义一个或多个8字节大小的数据元素。每个<code>.quad</code> 表示一个64位（即8字节）的值。这个指令常被用于分配内存空间，并初始化数据段中的常量值。这段代码中,<code>_num_app</code>位置后的<code>quad</code>记录了这7个<code>app</code>的开始位置</li><li><code>.incbin</code><br>直接在当前位置包含（嵌入）一个二进制文件的内容。还可以指定文件中的位置和长度, 例如: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.incbin <span class="string">&quot;data.bin&quot;</span>, 100, 50</span><br></pre></td></tr></table></figure> 这句的含义是: 包含 <code>data.bin</code> 文件从第 100 个字节开始的接下来的 50 个字节</li></ol><h2 id="6-2-2-宏定义"><a href="#6-2-2-宏定义" class="headerlink" title="6.2.2 宏定义"></a>6.2.2 宏定义</h2><p>我们在<code>trap.S</code>中看到了下面的宏定义代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.altmacro</span><br><span class="line">.macro SAVE_GP n</span><br><span class="line">    sd x\n, \n*8(sp)</span><br><span class="line">.endm</span><br><span class="line">.macro LOAD_GP n</span><br><span class="line">    ld x\n, \n*8(sp)</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure><p><code>.altmacro</code> 指令用于开启或关闭“替代宏语法模式”（alternate macro syntax mode）当<code>altmacro</code> 指令出现在文件中时，它会切换当前的宏处理模式。如果在 <code>.altmacro</code> 出现之前是标准宏模式，那么之后就会切换到替代宏模式；反之亦然。</p><p>在替代宏模式下，可以使用 <code>\()</code> 来对参数进行求值，允许宏内部对参数进行算术运算。此外，还可以使用更复杂的字符串处理功能，比如连接字符串或使用条件表达式。</p><p>在这里，<code>.altmacro</code> 可能是用来确保宏定义中的 <code>\n</code> 参数可以正常地被替换和计算。在 <code>.altmacro</code> 模式下，宏 <code>SAVE_GP</code> 和 <code>LOAD_GP</code> 中的 <code>\n</code> 会在宏展开时被实际传递的参数值所替换，并计算出正确的偏移量。</p><p>例如，如果使用 <code>SAVE_GP 2</code>，替代宏模式会确保宏展开为 <code>sd x2, 16(sp)</code>，这会将 <code>x2</code> 寄存器的内容保存到栈指针（<code>sp</code>）地址加上 16 字节处的内存位置（因为 <code>2 * 8 = 16</code>）。同理，<code>LOAD_GP</code> 宏则用于从相同的内存位置将数据加载回 <code>x2</code> 寄存器。</p><h2 id="6-3-stvec的模式"><a href="#6-3-stvec的模式" class="headerlink" title="6.3 stvec的模式"></a>6.3 <code>stvec</code>的模式</h2><p><code>stvec</code> 存储处理器在发生异常或中断时跳转到的异常处理基地址（<code>trap handler</code>的入口地址）。<code>stvec</code> 寄存器有两种模式：</p><ol><li><code>Direct Mode</code> (直接模式)<br>在直接模式下，当异常发生时，处理器会跳转到 <code>stvec</code> 寄存器中设置的地址开始执行异常处理程序。所有的异常和中断都会导致处理器跳转到这个单一的入口点，然后由异常处理程序根据异常原因码来处理不同的情况。</li><li><code>Vectored Mode</code> (向量模式)<br>在向量模式下，<code>stvec</code> 寄存器中的地址是中断向量表的基地址。当异常发生时，处理器会根据异常类型的不同来计算跳转地址。每种异常类型有一个固定的偏移量，处理器会将这个偏移量加到基地址上，计算得到对应的异常处理程序的地址，并跳转到该地址执行。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文不会将原本&lt;code&gt;rCore文档&lt;/code&gt;的内容重复太多, 主要是补充学习过程中遇到的知识点, 因此还需结合原文使用, 原文在后面的链接中&lt;/p&gt;
&lt;p&gt;之前的章节仅仅是一个裸机运行的应用程序, 这一章节通过特权级的引入实现了S态下的&lt;code&gt;OS&lt;/code</summary>
      
    
    
    
    <category term="训练营笔记" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
    
    <category term="清华大学开源操作系统训练营2023" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A52023/"/>
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="riscv" scheme="http://example.com/tags/riscv/"/>
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>CMU15445 2022 project1: 缓存池(可扩展哈希+LRU-K)</title>
    <link href="http://example.com/2024/02/12/CMU15445/proj1/"/>
    <id>http://example.com/2024/02/12/CMU15445/proj1/</id>
    <published>2024-02-12T06:51:11.000Z</published>
    <updated>2024-02-21T16:16:04.637Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍第一个<code>project: buffer poll</code>的实现思路<br>由于课程老师不允许放出自己的代码实现, 因此我只会涉及大概的实现思路, 而不涉及代码细节</p><p>官方<code>project</code>文档: <a href="https://15445.courses.cs.cmu.edu/fall2022/project1/">https://15445.courses.cs.cmu.edu/fall2022/project1/</a></p><h1 id="1-项目目标"><a href="#1-项目目标" class="headerlink" title="1 项目目标"></a>1 项目目标</h1><p>本项目要实现的缓存池结构如下:</p><ol><li>实现一个可扩展哈希表, 将数据库中的一个<code>page</code>从磁盘缓存到内存中, 并且维持从<code>page_id</code>到<code>page</code>得到映射关系</li><li>当<code>page</code>的大小超出容量时, 使用<code>lru-k</code>进行替换</li></ol><h1 id="2-可扩展哈希"><a href="#2-可扩展哈希" class="headerlink" title="2 可扩展哈希"></a>2 可扩展哈希</h1><h2 id="2-1-整体介绍"><a href="#2-1-整体介绍" class="headerlink" title="2.1 整体介绍"></a>2.1 整体介绍</h2><p>可扩展哈希（Extendible Hashing）是一种动态哈希技术，适用于数据库和文件系统中的索引结构，特别是在处理大量增减变化的数据集时。可扩展哈希表的主要特点是能根据数据量的变化动态地调整其大小，这样可以维持较均匀的访问性能，无论数据量的多少。</p><h2 id="2-2-工作原理"><a href="#2-2-工作原理" class="headerlink" title="2.2 工作原理"></a>2.2 工作原理</h2><ol><li><p><strong>哈希函数</strong>：<br>可扩展哈希表使用哈希函数对键值进行哈希，生成固定长度的位模式。通常，这个哈希函数产生的位数要比实际使用的位数多，以便表可以在未来扩展。</p></li><li><p><strong>目录结构</strong>：<br>该算法使用一个称为“目录”(<code>directory</code>)的结构，它包含指向数据桶（<code>buckets</code>）的指针。目录的大小取决于当前使用的哈希键的位数，初始时通常很小。</p></li><li><p><strong>桶</strong>：<br> 存储实际数据项（例如键值对）的基本单元。每个桶可以存储一个或多个数据项，其容量通常是预先定义的。</p></li><li><p><strong>桶分裂</strong>：<br>当一个桶满时（即达到预设的装载因子），系统会进行桶分裂（<code>bucket splitting</code>）。分裂时，桶中的数据会根据新的哈希键位重新分配到两个新桶中。</p></li><li><p><strong>目录扩展</strong>：<br>如果所有数据项都使用了当前哈希键的全部位数，且某个桶满了需要分裂，则目录也需要扩展。目录扩展是通过增加哈希键的位数并复制当前目录项来实现的。</p></li><li><p><strong>局部性原理</strong>：<br>可扩展哈希表的一个关键特性是局部性原理，即桶分裂只影响某个特定桶中的记录，而不会影响到整个哈希表。</p></li></ol><h2 id="2-3-插入流程"><a href="#2-3-插入流程" class="headerlink" title="2.3 插入流程"></a>2.3 插入流程</h2><h3 id="2-3-1-流程概述"><a href="#2-3-1-流程概述" class="headerlink" title="2.3.1 流程概述"></a>2.3.1 流程概述</h3><p>整体流程如下:<br>可扩展哈希的插入流程涉及将新的数据项（键值对）添加到哈希表中。以下是插入过程的步骤：</p><ol><li><p><strong>哈希函数计算</strong>：<br>对插入项的键使用哈希函数，得到一个哈希值。这个哈希值包含足够多的位，以支持未来的目录扩展。</p></li><li><p><strong>确定目标桶</strong>：<br>使用哈希值的前几位（称为“全局深度”）来确定目标桶。全局深度是指目录中用于索引的位数。如果哈希表的目录大小是 $2^d$，那么全局深度就是 <code>d</code>。</p></li><li><p><strong>将数据插入桶</strong>：</p><ol><li>如果目标桶没有满，即其包含的数据项少于桶的最大容量，则直接将数据项插入到该桶中。</li><li><strong>处理桶溢出</strong>：<br>如果目标桶已经满了，需要进行桶分裂。桶分裂的基本流程如下：<ol><li><strong>分裂桶</strong>：<br>创建一个新的空桶。将原来的桶中的所有数据项和新插入的数据项根据哈希值的下一位重新分配到这两个桶中。这通常意味着原桶和新桶会根据哈希值的那一位（原本相同的位）分别收集0和1的记录。</li><li><strong>更新目录</strong>：<br>更新目录以反映新的桶分配。这可能需要增加目录的“全局深度”（即索引的位数）。如果分裂的桶的“局部深度”（该桶对应的哈希值的位数）已经等于全局深度，那么在分裂之前，目录需要加倍，即复制一遍，以增加一个位的索引深度。</li><li><strong>重新指向桶指针</strong>：<br>将目录中与原桶相关的指针（那些仅在分裂位上有差异的指针）更新，使一部分指向原桶，另一部分指向新桶。</li><li><strong>重复分裂（如有必要）</strong>：<br>如果在分裂后新插入的项还是无法被放入桶中（因为原桶中其他项与它有相同的新哈希值），则需要重复分裂过程。</li><li><strong>完成插入</strong>：<br>当桶分裂和目录更新完成后，确保所有的数据项都被正确地放入桶中，包括新插入的数据项。</li></ol></li></ol></li></ol><p>这个过程确保了可扩展哈希表可以根据数据量的变化动态调整，同时保持常数时间的平均插入性能。由于目录的深度和桶指针的更新是有限的，所以插入过程通常很高效。</p><h3 id="2-3-2-图解插入"><a href="#2-3-2-图解插入" class="headerlink" title="2.3.2 图解插入"></a>2.3.2 图解插入</h3><p>接下来结合插入的图例解释其工作原理:</p><p><img src="/../../images/CMU15445/Extendible-Hash-Table.png"></p><p>通过上图我们可以明显看到可扩展哈希的下面几个特点:</p><ol><li>不同目录项可以指向相同的<code>bucket</code></li><li>每次超出<code>bucket</code>容量时, 只有超出<code>bucket</code>容量的那一个<code>bucket</code>需要<code>rehash</code>, 其余<code>bucket</code>保持不变</li><li>每一个<code>bucket</code>有自己的深度, 全局的深度等于所有<code>bucket</code>的深度的最大值</li><li><code>global_depth &lt;&lt; 1== len(directory)</code></li></ol><p><strong>此处详细说明图中<code>IndexOf</code>的含义:</strong><br><code>IndexOf</code>就是寻找<code>bucket</code>的序号, 将<code>key</code>进行<code>hash</code>后取<code>某几个低位</code>得到<code>bucket</code>的序号, <code>某几个低位</code>正是通过全局的<code>global_depth</code>确定的, <code>global_depth</code>就是指定了低位的数量, 以最后一次插入的<code>(5, &quot;e&quot;)</code>为例:</p><ol><li><code>hash(5) = 5</code>;</li><li>5的二进制表示是<code>0b101</code>, 此时的<code>global_depth</code>为2, 所以取低2为<code>0b01</code>, 目标<code>bucket</code>的序号为1</li><li>向1号<code>bucket</code>插入<code>(5, &quot;e&quot;)</code>, 容量足够, 插入成功</li></ol><h2 id="2-4-删除流程"><a href="#2-4-删除流程" class="headerlink" title="2.4 删除流程"></a>2.4 删除流程</h2><p>由于本项目不需要实现哈希的收缩, 因此删除流程只需要将指定<code>bucket</code>中的元素删除即可</p><h1 id="3-LRU-K替换策略"><a href="#3-LRU-K替换策略" class="headerlink" title="3 LRU-K替换策略"></a>3 <code>LRU-K</code>替换策略</h1><h2 id="3-1-LRU-K工作原理"><a href="#3-1-LRU-K工作原理" class="headerlink" title="3.1 LRU-K工作原理"></a>3.1 <code>LRU-K</code>工作原理</h2><p><code>LRU-K</code> 是传统的最近最少使用（<code>LRU</code>）算法的扩展。在 <code>LRU</code> 算法中，当需要替换一个页面时，选择最长时间未被访问的页面进行替换。而 <code>LRU-K</code> 算法则进一步利用了页面的访问历史信息，不仅考虑最后一次访问时间，还考虑到最后 <code>K</code> 次的访问时间。</p><p><code>LRU-K</code> 跟踪并记录每个页面最后 K 次被访问的时间。它使用这些历史访问数据来预测每个页面未来被访问的可能性。</p><p>具体而言, <code>LRU-K</code>按照下面的规则来移除元素:</p><ol><li><p><strong>寻找访问次数低于 K 次的页面</strong>：首先检查是否有页面的访问次数低于 <code>K</code> 次。如果有，这些页面是候选被替换的对象，因为它们相对来说是最不常用的。在这些页面中，选取最新访问时间戳最旧的页面进行替换。</p></li><li><p><strong>寻找访问次数达到 K 次的页面</strong>：如果所有的页面访问次数都达到了 <code>K</code> 次，则从这些页面中选择最新的第 <code>K</code> 次访问时间戳最旧的页面进行替换。这表示即使页面被频繁访问，但如果它的“第 <code>K</code> 次”访问已经很久远了，那么它可能在未来一段时间内不会再次被访问，因此成为了替换的目标。</p></li></ol><h2 id="3-2-实现思路"><a href="#3-2-实现思路" class="headerlink" title="3.2 实现思路"></a>3.2 实现思路</h2><h3 id="3-2-1-数据结构"><a href="#3-2-1-数据结构" class="headerlink" title="3.2.1 数据结构"></a>3.2.1 数据结构</h3><p>可以看到, 传统的<code>LRU</code>直接移除时间戳最久的一个元素, 但<code>LRU-K</code>需要分为<code>访问次数低于 K 次</code>和<code>访问次数达到 K 次</code>2中情况, 在这2种情况下, 其移除的思路和传统的<code>LRU</code>是一样的。</p><p>由于我们的<code>LRU-K</code>是作为缓存池的一部分使用的，其更新、删除、读取都有时间复杂度的要求，查询最容易想到哈希表， 而插入和删除最容易想到的是链表， 因此可以结合这2个数据结构实现，由于2个情况都可以看做是传统<code>LRU</code>的实现, 因此可以用如下的数据结构实现:</p><ol><li>低于 <code>K</code> 次的页面记录数据结构<ol><li>双向链表: <code>list_less_k</code>: 按照最新访问顺序记录页面<code>id</code></li><li>哈希表: <code>map_less_k</code>: 记录页面在<code>list_less_k</code>中的位置(也就是迭代器), 以便快速删除</li></ol></li><li>达到 <code>K</code> 次的页面记录数据结构<ol><li>双向链表: <code>list_reach_k</code>: 按照最新访问顺序记录页面<code>id</code></li><li>哈希表: <code>map_reach_k</code>: 记录页面在<code>list_reach_k</code>中的位置(也就是迭代器), 以便快速删除</li></ol></li><li>全局计数器<code>map_count</code>: 记录每个页面<code>id</code>的访问次数, 控制页面从<code>list_less_k</code>&#x2F;<code>map_less_k</code>转移到<code>list_reach_k</code>&#x2F;<code>map_reach_k</code></li></ol><h3 id="3-2-2-记录和删除"><a href="#3-2-2-记录和删除" class="headerlink" title="3.2.2 记录和删除"></a>3.2.2 记录和删除</h3><h4 id="3-2-2-1-新增访问记录"><a href="#3-2-2-1-新增访问记录" class="headerlink" title="3.2.2.1 新增访问记录"></a>3.2.2.1 新增访问记录</h4><p>记访问记录的页面为<code>id</code></p><ol><li>从<code>map_count</code>中查看<code>id</code>的访问次数</li><li>如果访问次数达到了<code>k</code>次<ol><li>将<code>id</code>的记录从<code>list_reach_k</code>和<code>map_reach_k</code>中删除</li><li>将<code>id</code>重新插入<code>list_reach_k</code>, 并更新这个新的头部或者尾部位置(取决于链表的排序是从新到旧还是从旧到新)的迭代器到<code>map_reach_k</code></li><li>更新<code>map_count</code>计数</li></ol></li><li>如果访问次数不到<code>k</code>次<ol><li>如果访问次数是<code>k-1</code>次<ol><li>由于这次更新后就达到了<code>k</code>次, 需要将<code>id</code>从<code>list_less_k</code>和<code>map_less_k</code>中删除</li><li>将<code>id</code>插入<code>list_reach_k</code>, 并更新这个新的头部或者尾部位置(取决于链表的排序是从新到旧还是从旧到新)的迭代器到<code>map_reach_k</code></li><li>更新<code>map_count</code>计数</li></ol></li><li>如果访问次数小于<code>k-1</code>次<ol><li>将<code>id</code>从<code>list_less_k</code>和<code>map_less_k</code>中删除</li><li>将<code>id</code>重新插入<code>list_less_k</code>, 并更新这个新的头部或者尾部位置(取决于链表的排序是从新到旧还是从旧到新)的迭代器到<code>map_less_k</code></li><li>更新<code>map_count</code>计数</li></ol></li></ol></li></ol><h4 id="3-2-2-2-替换策略"><a href="#3-2-2-2-替换策略" class="headerlink" title="3.2.2.2 替换策略"></a>3.2.2.2 替换策略</h4><ol><li>如果<code>list_less_k</code>不为空<ol><li>移除<code>list_less_k</code>头部或尾部的最旧页面号, 同时移除对应的<code>map_less_k</code></li><li>更新对应<code>map_count</code>计数为0, 表示没有在缓存池中</li></ol></li><li>如果<code>list_less_k</code>为空<ol><li>移除<code>list_reach_k</code>头部或尾部的最旧页面号, 同时移除对应的<code>map_reach_k</code></li><li>更新对应<code>map_count</code>计数为0, 表示没有在缓存池中</li></ol></li></ol><blockquote><blockquote><p>以上的新增和替换思路没有考虑到页面在逻辑上是否可以移除, 因为一个页面尽管长时间没有被访问, 但其数据和加载到内存时发生了变化, 还没有刷入磁盘, 因此不能被移除。在项目代码中， 还需要增加相应的判断，不过这个判断很简单，就没有写到上面的流程里了</p></blockquote></blockquote><h1 id="4-Buffer-Pool"><a href="#4-Buffer-Pool" class="headerlink" title="4 Buffer Pool"></a>4 Buffer Pool</h1><p>之前我们只是一股脑地实现了可扩展哈希和<code>LRU-K</code>, 但实际上却不知道或者不完全知道这些东西和最后实现的缓存池有什么联系, 做完这一小节后这一切都有了答案</p><h2 id="4-1-Buffer-Pool-数据结构"><a href="#4-1-Buffer-Pool-数据结构" class="headerlink" title="4.1 Buffer Pool 数据结构"></a>4.1 Buffer Pool 数据结构</h2><p>首先需要说明<code>Buffer Pool</code>的数据结构:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Number of pages in the buffer pool. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> pool_size_;</span><br><span class="line"><span class="comment">/** The next page id to be allocated  */</span></span><br><span class="line">std::atomic&lt;<span class="type">page_id_t</span>&gt; next_page_id_ = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** Bucket size for the extendible hash table */</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> bucket_size_ = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Array of buffer pool pages. */</span></span><br><span class="line">Page *pages_;</span><br><span class="line"><span class="comment">/** Pointer to the disk manager. */</span></span><br><span class="line">DiskManager *disk_manager_ __attribute__((__unused__));</span><br><span class="line"><span class="comment">/** Pointer to the log manager. Please ignore this for P1. */</span></span><br><span class="line">LogManager *log_manager_ __attribute__((__unused__));</span><br><span class="line"><span class="comment">/** Page table for keeping track of buffer pool pages. */</span></span><br><span class="line">ExtendibleHashTable&lt;<span class="type">page_id_t</span>, <span class="type">frame_id_t</span>&gt; *page_table_;</span><br><span class="line"><span class="comment">/** Replacer to find unpinned pages for replacement. */</span></span><br><span class="line">LRUKReplacer *replacer_;</span><br><span class="line"><span class="comment">/** List of free frames that don&#x27;t have any pages on them. */</span></span><br><span class="line">std::list&lt;<span class="type">frame_id_t</span>&gt; free_list_;</span><br><span class="line"><span class="comment">/** This latch protects shared data structures. We recommend updating this comment to describe what it protects. */</span></span><br><span class="line">std::mutex latch_;</span><br></pre></td></tr></table></figure><p>上面这些都是<code>src/include/buffer/buffer_pool_manager_instance.h</code>中定义的类成员变量, 对其中主要的成员变量说明如下:</p><ol><li><code>pool_size_</code>: 缓存池的容量, 也是之前的<code>LRU-K</code>中的<code>num_frames</code></li><li><code>bucket_size_</code>: 之前的可扩展哈希的桶的容量</li><li><code>pages_</code>: 实际缓存池的页的内容, 是一个数组</li><li><code>disk_manager_</code>: 官方已经实现的从硬盘加载页面的类的实例, 相关函数的作用可以去看头文件</li><li><code>page_table_</code>: 之前实现的可扩展哈希表, 用于快速查找指定的<code>page_id_t</code>在<code>pages_</code>数组中的位置</li><li><code>replacer_</code>: 之前实现的替换类, 用于记录读写记录并在缓存池满时进行替换</li><li><code>free_list_</code>: 空闲链表, 记录的是空闲的页的索引, 也就是在 <code>pages_</code>数组中的下标</li></ol><p>通过上面的分析, 我们对之前实现的可扩展哈希表和<code>LRU-K</code>的作用就已经很明白了, 而且在实现了可扩展哈希表和<code>LRU-K</code>后, 最后这一部分的任务已经很简单了, 简单阅读一下<code>proj</code>文档, 应该就能试着写出来了</p><h2 id="4-2-实现思路"><a href="#4-2-实现思路" class="headerlink" title="4.2 实现思路"></a>4.2 实现思路</h2><h3 id="4-2-1-NewPgImp"><a href="#4-2-1-NewPgImp" class="headerlink" title="4.2.1 NewPgImp"></a>4.2.1 <code>NewPgImp</code></h3><p>要求在缓存池中创建一个新页, 逻辑如下:</p><ol><li>如果<code>pages_</code>中的所有页都不能被替换(<code>GetPinCount() &gt; 0</code>), 返回空指针</li><li>此时创建新页, 如下获取一个新页<ol><li>如果空闲列表<code>free_list_</code>不为空, 从中取一个页</li><li>否则用替换类<code>replacer_</code>驱逐一个页<ol><li>如果驱逐页是脏页, 还需要用<code>disk_manager_</code>写回磁盘</li><li>缓存池哈希表<code>page_table_</code>移除驱逐页</li></ol></li></ol></li><li>在缓存池哈希表<code>page_table_</code>记录新页位置</li><li>更新页的<code>pin_count_</code>和页号</li><li>用替换类<code>replacer_</code>更新新页的访问记录, 并设置其不可驱逐(马上要被使用)</li></ol><h3 id="4-2-2-FetchPgImp"><a href="#4-2-2-FetchPgImp" class="headerlink" title="4.2.2 FetchPgImp"></a>4.2.2 <code>FetchPgImp</code></h3><p>要求从缓存池取出指定页号的页面, 如果页面不存在于缓存池但缓存池没有可以驱逐的页面, 返回空指针, 逻辑如下:</p><ol><li>如果哈希表中存在映射, 说明页存在:<ol><li>自增其<code>pin_count_</code></li><li>用替换类<code>replacer_</code>更新页的访问记录, 并设置其不可驱逐(马上要被使用)</li><li>返回</li></ol></li><li>不存在映射, 需要驱逐<ol><li>如果<code>pages_</code>中的所有页都不能被替换(<code>GetPinCount() &gt; 0</code>), 返回空指针</li><li>分配新页<ol><li>如果空闲列表<code>free_list_</code>不为空, 从中取一个页</li><li>否则用替换类<code>replacer_</code>驱逐一个页<ol><li>如果驱逐页是脏页, 还需要用<code>disk_manager_</code>写回磁盘</li><li>缓存池哈希表<code>page_table_</code>移除驱逐页</li></ol></li></ol></li></ol></li><li>更新新页的<code>pin_count_</code>和页号</li><li>用替换类<code>replacer_</code>更新新页的访问记录, 并设置其不可驱逐(马上要被使用)</li><li>调用<code>disk_manager_</code>的相关方法从硬盘上读取指定页的内容到这个新页</li></ol><h3 id="4-2-3-DeletePgImp"><a href="#4-2-3-DeletePgImp" class="headerlink" title="4.2.3 DeletePgImp"></a>4.2.3 <code>DeletePgImp</code></h3><p>要求在缓存池删除指定页号的页, 逻辑如下:</p><ol><li>如果该页不存在于缓存池, 返回<code>true</code>表示删除成功</li><li>如果该页被占用(<code>GetPinCount() &gt; 0</code>), 返回<code>false</code>表示删除失败</li><li>删除该页<ol><li>从哈希表从移除</li><li>从替换类<code>replacer_</code>中移除</li><li>更新删除页的页号为<code>INVALID_PAGE_ID</code>, 更新<code>pin_count_ = 0</code>, 标记<code>is_dirty_ = false</code></li><li>将该页的索引号放回空闲列表</li><li>返回<code>true</code>表示删除成功</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将介绍第一个&lt;code&gt;project: buffer poll&lt;/code&gt;的实现思路&lt;br&gt;由于课程老师不允许放出自己的代码实现, 因此我只会涉及大概的实现思路, 而不涉及代码细节&lt;/p&gt;
&lt;p&gt;官方&lt;code&gt;project&lt;/code&gt;文档: &lt;a href=&quot;</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CMU15445" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/CMU15445/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="lru-k" scheme="http://example.com/tags/lru-k/"/>
    
    <category term="可扩展哈希" scheme="http://example.com/tags/%E5%8F%AF%E6%89%A9%E5%B1%95%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>Postgresql学习笔记0: 源码安装、gdb调试与VSCode智能提示设置</title>
    <link href="http://example.com/2024/02/12/%E6%95%B0%E6%8D%AE%E5%BA%93/postgres%E5%AD%A6%E4%B9%A0/0-%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/"/>
    <id>http://example.com/2024/02/12/%E6%95%B0%E6%8D%AE%E5%BA%93/postgres%E5%AD%A6%E4%B9%A0/0-%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/</id>
    <published>2024-02-12T01:55:30.000Z</published>
    <updated>2024-02-21T16:16:04.675Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容包括:</p><ol><li>如何从源码安装<code>postgresql-14</code>, 更多信息请参考官方文档: <a href="https://www.postgresql.org/docs/current/">https://www.postgresql.org/docs/current/</a></li><li>如何使用<code>gdb</code>调试<code>postgresql</code></li><li>如何在<code>VSCode</code>中开启<code>postgresql</code>代码的智能提示</li></ol><h1 id="1-编译源码"><a href="#1-编译源码" class="headerlink" title="1 编译源码"></a>1 编译源码</h1><h2 id="1-1-安装依赖"><a href="#1-1-安装依赖" class="headerlink" title="1.1 安装依赖"></a>1.1 安装依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libreadline-dev</span><br></pre></td></tr></table></figure><h2 id="1-2-克隆仓库并编译"><a href="#1-2-克隆仓库并编译" class="headerlink" title="1.2 克隆仓库并编译"></a>1.2 克隆仓库并编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://git.postgresql.org/git/postgresql.git <span class="comment"># 克隆完整仓库</span></span><br><span class="line">git checkout REL_14_STABLE <span class="comment"># 切换到14分支</span></span><br></pre></td></tr></table></figure><p>由于我们源码安装的目的是为了查看源码调试, 所以我们不需要安装到默认的<code>/usr/local/</code>路径, 需要在<code>configure</code>中指定编译安装目录, 同时需要开启一些额外的选项允许后续的<code>gdb</code>调试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /home/toni/pgBuild</span><br><span class="line">./configure --prefix=/home/toni/pgBuild/ --enable-debug --enable-depend --enable-cassert CFLAGS=-O0</span><br></pre></td></tr></table></figure><ol><li><code>--enable-debug</code>: 编译程序时包含额外的调试信息</li><li><code>--enable-depend</code>: 用于生成依赖关系。它使得编译过程中会自动生成 <code>.depend</code> 文件，这些文件包含了源文件之间的依赖信息。这对于开发者在修改代码后只重新编译改变了的部分非常有用。</li><li><code>--enable-cassert</code>: 用于开启断言（assertions）。通常用于开发和调试。它会编译进一些额外的检查，这些检查在标准运行中通常是关闭的，因为它们可能会降低性能。但是在开发过程中，这些检查可以帮助捕捉到代码中的错误。</li><li><code>CFLAGS=-O0</code>: 环境变量设置，用于控制 C 编译器的优化级别。<code>-O0</code> 表示不进行优化，确保了编译器不会改变代码结构，从而使得调试时的代码行为更接近源码。</li></ol><p>然后正常编译即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="1-3-额外编译选项"><a href="#1-3-额外编译选项" class="headerlink" title="1.3 额外编译选项"></a>1.3 额外编译选项</h2><ol><li>编译后测试<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make check</span><br></pre></td></tr></table></figure></li><li>安装额外模块<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make world</span><br></pre></td></tr></table></figure></li></ol><h1 id="2-基本配置"><a href="#2-基本配置" class="headerlink" title="2 基本配置"></a>2 基本配置</h1><h2 id="2-1-配置环境变量"><a href="#2-1-配置环境变量" class="headerlink" title="2.1 配置环境变量"></a>2.1 配置环境变量</h2><p>将安装目录的四个文件夹添加到环境变量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.bashrc</span></span><br><span class="line">PATH=<span class="variable">$PATH</span>:/home/toni/pgBuild/bin</span><br><span class="line">PATH=<span class="variable">$PATH</span>:/home/toni/pgBuild/include</span><br><span class="line">PATH=<span class="variable">$PATH</span>:/home/toni/pgBuild/lib</span><br><span class="line">PATH=<span class="variable">$PATH</span>:/home/toni/pgBuild/share</span><br></pre></td></tr></table></figure><h2 id="2-2-初始化数据库"><a href="#2-2-初始化数据库" class="headerlink" title="2.2 初始化数据库"></a>2.2 初始化数据库</h2><p>新建一个数据库目录并初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p pgData</span><br><span class="line">initdb -D pgData</span><br></pre></td></tr></table></figure><h2 id="2-3-启动数据库并登录"><a href="#2-3-启动数据库并登录" class="headerlink" title="2.3 启动数据库并登录"></a>2.3 启动数据库并登录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pg_ctl -D pgData/ start</span><br></pre></td></tr></table></figure><p>从<code>psql</code>连接数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql postgres</span><br></pre></td></tr></table></figure><p>查看当前登录信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres<span class="operator">=</span># \c</span><br><span class="line">You <span class="keyword">are</span> now connected <span class="keyword">to</span> database &quot;postgres&quot; <span class="keyword">as</span> <span class="keyword">user</span> &quot;toni&quot;.</span><br></pre></td></tr></table></figure><p>可以看到, 初始化数据库目录后, 自动创建了名为<code>postgres</code>的数据库和安装时的用户<code>toni</code></p><h1 id="3-启用gdb调试"><a href="#3-启用gdb调试" class="headerlink" title="3 启用gdb调试"></a>3 启用gdb调试</h1><h2 id="3-1-调试pg-ctl"><a href="#3-1-调试pg-ctl" class="headerlink" title="3.1 调试pg_ctl"></a>3.1 调试<code>pg_ctl</code></h2><p>进入<code>pg_ctl</code>所在的目录, 执行如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb pg_ctl</span><br><span class="line">(gdb) layout src</span><br><span class="line">(gdb) set args -D /home/toni/pgData/ start</span><br><span class="line">(gdb) b main</span><br><span class="line">(gdb) run</span><br></pre></td></tr></table></figure><p>如果成功, 则会看到下图的内容:</p><p><img src="/../../../images/DB/postgresql/gdb-postgres.png" alt="gdb-postgres"></p><h2 id="3-2-postgres主程序的启动"><a href="#3-2-postgres主程序的启动" class="headerlink" title="3.2 postgres主程序的启动"></a>3.2 postgres主程序的启动</h2><p>我们单步调试<code>pg_ctl</code>, 终于发现了程序在这个位置启动主程序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">void</span>) <span class="built_in">execl</span>(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmd, (<span class="type">char</span> *) <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>但是返现其是由<code>exec</code>执行<code>sh</code>后再启动的, 这就不方便我们进行调试了, 不过我们可以通过获取<code>pid</code>后<code>attach</code>的方式进行调试</p><h2 id="3-3-postgresql的进程"><a href="#3-3-postgresql的进程" class="headerlink" title="3.3 postgresql的进程"></a>3.3 <code>postgresql</code>的进程</h2><p>使用<code>pg_ctl</code>启动后, 我们发现<code>potgresql</code>有如下几个进程:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep postgres</span><br><span class="line">toni       38492     355  0 11:18 ?        00:00:00 /home/toni/pgBuild/bin/postgres -D ../pgData</span><br><span class="line">toni       38494   38492  0 11:18 ?        00:00:00 postgres: checkpointer</span><br><span class="line">toni       38495   38492  0 11:18 ?        00:00:00 postgres: background writer</span><br><span class="line">toni       38496   38492  0 11:18 ?        00:00:00 postgres: walwriter</span><br><span class="line">toni       38497   38492  0 11:18 ?        00:00:00 postgres: autovacuum launcher</span><br><span class="line">toni       38498   38492  0 11:18 ?        00:00:00 postgres: stats collector</span><br><span class="line">toni       38499   38492  0 11:18 ?        00:00:00 postgres: logical replication launcher</span><br></pre></td></tr></table></figure><ol><li><p><code>/home/toni/pgBuild/bin/postgres -D ../pgData</code> (<code>PID 38492</code>):<br>这是 PostgreSQL 的主进程（称为 <code>postmaster</code>）。它负责管理数据库系统的整体运行，包括处理客户端连接请求、启动新的子进程来处理这些连接，以及监控所有的子进程。参数 <code>-D ../pgData</code> 指定了数据库的数据目录。</p></li><li><p><code>postgres: checkpointer</code> (<code>PID 38494</code>):<br>检查点进程（checkpointer）负责创建检查点，这是数据库的一个稳定状态，用于数据恢复。检查点包括将缓冲区中的所有脏页（已修改但尚未写入磁盘的数据页）刷新到磁盘中。检查点有助于减少崩溃恢复的时间。</p></li><li><p><code>postgres: background writer</code> (<code>PID 38495</code>):<br>后台写入程序（background writer）进程负责将脏页从缓冲区定期写入磁盘。它可以减轻前端数据库进程的 <code>I/O </code>负载，并且可以平滑 <code>I/O</code> 峰值。</p></li><li><p><code>postgres: walwriter</code> (<code>PID 38496</code>):<br>写前日志（<code>Write-Ahead Logging, WAL</code>）写入器进程负责将 <code>WAL</code> 缓冲区中的记录刷新到磁盘上的 <code>WAL</code> 文件中。<code>WAL</code> 是 <code>PostgreSQL</code> 实现事务持久性和崩溃恢复的关键组成部分。</p></li><li><p><code>postgres: autovacuum launcher</code> (<code>PID 38497</code>):<br>自动清理启动器（autovacuum launcher）进程负责启动自动清理工作进程，这些工作进程负责清理数据库中的“死”元组（即不再可达的数据），并且帮助回收空间、更新统计信息以及防止事务 ID 耗尽。</p></li><li><p><code>postgres: stats collector</code> (<code>PID 38498</code>):<br>统计信息收集器（stats collector）进程负责收集数据库活动的统计信息，比如对于每个表和索引的访问频率等。这些信息对于查询优化器的决策非常重要。</p></li><li><p><code>postgres: logical replication launcher</code> (<code>PID 38499</code>):<br>逻辑复制启动器（logical replication launcher）进程负责管理逻辑复制和订阅功能。它监控逻辑复制工作进程，并在需要时启动新的工作进程以处理逻辑复制任务。</p></li></ol><h2 id="3-4-psql后调试后端进程"><a href="#3-4-psql后调试后端进程" class="headerlink" title="3.4 psql后调试后端进程"></a>3.4 <code>psql</code>后调试后端进程</h2><ol><li><p><strong>获取后端进程<code>pid</code></strong><br>要使用 <code>gdb</code> 调试已经连接到 <code>postmaster</code> 的 <code>psql</code> 会话，需要找到该 <code>psql</code> 会话对应的后端进程 ID, 这可以通过<code>sql</code>语句实现:</p><p> <img src="/../../../images/DB/postgresql/psql-pg_backend_pid.png" alt="pg_backend_pid"></p><p>我得到的进程<code>pid</code>是<code>44765</code>, 此时在另一个终端再次运行<code>ps -ef | grep postgres</code>, 发现多了一个<code>44765</code>的进程, 这个后端进程是响应客户端请求的进程，每个客户端连接都会有一个对应的后端进程。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">toni       38492     355  0 11:18 ?        00:00:00 /home/toni/pgBuild/bin/postgres -D ../pgData</span><br><span class="line">toni       38494   38492  0 11:18 ?        00:00:00 postgres: checkpointer</span><br><span class="line">toni       38495   38492  0 11:18 ?        00:00:00 postgres: background writer</span><br><span class="line">toni       38496   38492  0 11:18 ?        00:00:00 postgres: walwriter</span><br><span class="line">toni       38497   38492  0 11:18 ?        00:00:00 postgres: autovacuum launcher</span><br><span class="line">toni       38498   38492  0 11:18 ?        00:00:00 postgres: stats collector</span><br><span class="line">toni       38499   38492  0 11:18 ?        00:00:00 postgres: logical replication launcher</span><br><span class="line">toni       44765   38492  0 11:42 ?        00:00:00 postgres: toni toni [<span class="built_in">local</span>] idle</span><br></pre></td></tr></table></figure></li><li><p><strong>附加 <code>gdb</code> 到进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gdb -p 44765</span><br></pre></td></tr></table></figure><p>结果如下:<br><img src="/../../../images/DB/postgresql/attach-44765.png" alt="attach-44765"></p><p>这将启动 <code>gdb</code> 并附加到具有指定进程 ID 的进程。</p><p>此时进程在系统调用<code>epoll_wait</code>中, 因此没有源码调试文件</p></li><li><p><code>backtrace</code>追踪调用栈信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(gdb) backtrace</span><br><span class="line"> <span class="comment">#0  0x00007fe42671ffda in epoll_wait (epfd=4, events=0x5615a6ee7c48,</span></span><br><span class="line">     maxevents=1, <span class="built_in">timeout</span>=-1) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30</span><br><span class="line"> <span class="comment">#1  0x00005615a6904d70 in WaitEventSetWaitBlock (set=0x5615a6ee7bd0,</span></span><br><span class="line">     cur_timeout=-1, occurred_events=0x7fffacc2e940, nevents=1) at latch.c:1471</span><br><span class="line"> <span class="comment">#2  0x00005615a6904bd7 in WaitEventSetWait (set=0x5615a6ee7bd0, timeout=-1,</span></span><br><span class="line">     occurred_events=0x7fffacc2e940, nevents=1, wait_event_info=100663296)</span><br><span class="line">     at latch.c:1417</span><br><span class="line"> <span class="comment">#3  0x00005615a673fde1 in secure_read (port=0x5615a6f0e3f0,</span></span><br><span class="line">     ptr=0x5615a6e5b260 &lt;PqRecvBuffer&gt;, len=8192) at be-secure.c:186</span><br><span class="line"> <span class="comment">#4  0x00005615a674b86c in pq_recvbuf () at pqcomm.c:959</span></span><br><span class="line"> <span class="comment">#5  0x00005615a674b951 in pq_getbyte () at pqcomm.c:1005</span></span><br><span class="line"> <span class="comment">#6  0x00005615a693cfd2 in SocketBackend (inBuf=0x7fffacc2eaa0) at postgres.c:352</span></span><br><span class="line"> <span class="comment">#7  0x00005615a693d24f in ReadCommand (inBuf=0x7fffacc2eaa0) at postgres.c:475</span></span><br><span class="line"> <span class="comment">#8  0x00005615a6942bd4 in PostgresMain (argc=1, argv=0x7fffacc2ebd0,</span></span><br><span class="line">     dbname=0x5615a6f18758 <span class="string">&quot;toni&quot;</span>, username=0x5615a6f18738 <span class="string">&quot;toni&quot;</span>)</span><br><span class="line">     at postgres.c:4445</span><br><span class="line"> <span class="comment">#9  0x00005615a6865e1e in BackendRun (port=0x5615a6f0e3f0) at postmaster.c:4540</span></span><br><span class="line"> <span class="comment">#10 0x00005615a6865679 in BackendStartup (port=0x5615a6f0e3f0)</span></span><br><span class="line">     at postmaster.c:4262</span><br><span class="line"> <span class="comment">#11 0x00005615a6861402 in ServerLoop () at postmaster.c:1748</span></span><br><span class="line"> <span class="comment">#12 0x00005615a6860b5f in PostmasterMain (argc=3, argv=0x5615a6ee5d20)</span></span><br><span class="line">     at postmaster.c:1420</span><br><span class="line"> <span class="comment">#13 0x00005615a674f089 in main (argc=3, argv=0x5615a6ee5d20) at main.c:209</span></span><br></pre></td></tr></table></figure><ul><li><p><code>#0</code> - 这是当前停止点，即 <code>epoll_wait</code> 系统调用。这个函数是 <code>Linux</code> 内核提供的，用于等待多个文件描述符上的事件。这里的参数表示正在等待文件描述符 <code>4</code> 上的事件，最多等待 <code>1</code> 个事件，且超时时间设置为 <code>-1</code>，表示无限等待直到有事件发生。</p></li><li><p><code>#1</code> - <code>WaitEventSetWaitBlock</code> 函数是 <code>PostgreSQL</code> 内部的函数。它是封装 <code>epoll_wait</code> 的部分，用于等待一组事件中的任何一个发生。</p></li><li><p><code>#2</code> - <code>WaitEventSetWait</code> 函数是 <code>PostgreSQL</code> 的另一个内部函数，它负责等待事件集合中指定的事件。</p></li><li><p><code>#3</code> - <code>secure_read</code> 函数尝试从安全连接中读取数据。</p></li><li><p><code>#4</code> - <code>pq_recvbuf</code> 函数是 <code>PostgreSQL</code> 的内部通信函数，从客户端接收数据缓冲区。</p></li><li><p><code>#5</code> - <code>pq_getbyte</code> 函数是用于从 <code>PostgreSQL</code> 后端接收单个字节的函数。</p></li><li><p><code>#6</code> - <code>SocketBackend</code> 函数处理 <code>PostgreSQL</code> 后端进程中的套接字通信。</p></li><li><p><code>#7</code> - <code>ReadCommand</code> 函数读取从客户端发来的命令。</p></li><li><p><code>#8</code> - <code>PostgresMain</code> 是 <code>PostgreSQL</code> 后端主函数，处理每个数据库会话的生命周期。</p></li><li><p><code>#9</code> - <code>BackendRun</code> 是在 <code>PostgreSQL</code> 后端进程启动后执行的函数。</p></li><li><p><code>#10</code> - <code>BackendStartup</code> 函数负责在系统启动后初始化后端进程。</p></li><li><p><code>#11</code> - <code>ServerLoop</code> 函数是 <code>PostgreSQL</code> 主进程的主循环，负责接受新的连接并启动新的后端进程。</p></li><li><p><code>#12</code> - <code>PostmasterMain</code> 是 <code>PostgreSQL</code> 的主守护进程主函数，管理数据库服务器的整体运行。</p></li><li><p><code>#13</code> - <code>main</code> 是 <code>PostgreSQL</code> 的入口点。</p></li></ul><p>从 <code>backtrace</code> 可以看出，<code>PostgreSQL</code> 后端进程正在等待来自客户端的新的网络活动。这是数据库服务器正常运行时的典型状态。</p></li><li><p>调试<code>SocketBackend</code><br><code>SocketBackend</code>接受客户端链接,因此可以在次数打断点, 先使用<code>ctrl c</code>暂停进程, 然后:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b SocketBackend</span><br><span class="line">c</span><br></pre></td></tr></table></figure><p>此时在<code>psql</code>连接客户端一侧, 使用<code>\l</code>命令使后端进行继续执行, 结果如下:<br><img src="/../../../images/DB/postgresql/gdb-SocketBackend.png" alt="gdb-SocketBackend"></p><p> 此时我们就已经正常进入了<code>postgresql</code>的业务代码, 并附带了源码调试信息, 大功告成</p></li></ol><h1 id="4-VSCode智能提示设置"><a href="#4-VSCode智能提示设置" class="headerlink" title="4 VSCode智能提示设置"></a>4 VSCode智能提示设置</h1><p>当我们完成上述操作后发现，如果我们在<code>VSCode</code>中直接打开项目文件夹, 是没有代码只能提示和补全的, 经过查阅得知, 智能跳转通常需要一个编译数据库（<code>compile_commands.json</code>）。这个文件包含了编译器在编译项目时使用的命令，它允许代码分析工具理解代码是如何被编译的，从而提供准确的智能感知。</p><p><code>compile_commands.json</code>可以如下得到:</p><h2 id="4-1-安装bear"><a href="#4-1-安装bear" class="headerlink" title="4.1 安装bear"></a>4.1 安装<code>bear</code></h2><p><code>bear</code> 用于在运行构建过程的同时拦截编译命令，生成 <code>compile_commands.json</code> 文件，这个文件可以被很多编辑器和工具用来提供代码索引和自动完成等功能。</p><p>我使用<code>Ubuntu</code>的<code>apt</code>安装<code>bear</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install bear</span><br></pre></td></tr></table></figure><h2 id="4-2-bear拦截编译命令"><a href="#4-2-bear拦截编译命令" class="headerlink" title="4.2 bear拦截编译命令"></a>4.2 <code>bear</code>拦截编译命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">bear -- make</span><br></pre></td></tr></table></figure><p>在这个命令中，<code>--</code> 表示后面的参数都将传递给实际的构建系统（在这个例子中是 <code>make</code>），而不是被 <code>bear</code> 解析。这样，<code>bear</code> 就会监听 <code>make</code> 命令的执行，捕获它的编译命令，并生成 <code>compile_commands.json</code> 文件。</p><p>需要注意的是, 首先要<code>make clean</code>清理之前的编译结果, 否则如果<code>make</code>什么也没做, 那么<code>bear</code>就什么也没拦截到, 构建的<code>compile_commands.json</code> 文件就是空的。</p><h2 id="4-3-VSCode设置compile-commands-json"><a href="#4-3-VSCode设置compile-commands-json" class="headerlink" title="4.3 VSCode设置compile_commands.json"></a>4.3 VSCode设置<code>compile_commands.json</code></h2><ol><li><code>VSCode</code>安装<code>clangd</code>插件</li><li>添加<code>compile_commands.json</code><br>在工作区的 <code>.vscode</code> 文件夹中创建或编辑 <code>settings.json</code> 文件，并添加以下内容：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;C_Cpp.default.compileCommands&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/compile_commands.json&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p>之后重启<code>VSCode</code>, 发现C文件已经有了智能提示和跳转了</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.postgresql.org/docs/">https://www.postgresql.org/docs/</a><br><a href="https://www.zhihu.com/column/c_1624079542120914944">https://www.zhihu.com/column/c_1624079542120914944</a><br><a href="https://blog.csdn.net/weixin_43997331/article/details/120662533">https://blog.csdn.net/weixin_43997331/article/details/120662533</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文内容包括:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何从源码安装&lt;code&gt;postgresql-14&lt;/code&gt;, 更多信息请参考官方文档: &lt;a href=&quot;https://www.postgresql.org/docs/current/&quot;&gt;https://www.postg</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Postgresql学习" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Postgresql%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Postgresql" scheme="http://example.com/tags/Postgresql/"/>
    
  </entry>
  
  <entry>
    <title>Google Test 简单使用</title>
    <link href="http://example.com/2024/02/10/C++/GoogleTest%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2024/02/10/C++/GoogleTest%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2024-02-10T02:38:15.000Z</published>
    <updated>2024-10-03T17:47:36.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Google-Test简介"><a href="#1-Google-Test简介" class="headerlink" title="1 Google Test简介"></a>1 Google Test简介</h1><p><code>Google Test</code>（<code>gtest</code>）是一个由<code>Google</code>提供的<code>C++</code>测试框架, 提供了丰富的断言类型和辅助函数，使得编写C++测试用例变得简单而又直观。<code>Google Test</code>旨在与<code>CMake</code>和其他构建系统无缝集成，而且与各种平台和测试工具兼容。下面是一些<code>Google Test</code>的核心特性：</p><h1 id="2-Google-Test基础语法"><a href="#2-Google-Test基础语法" class="headerlink" title="2 Google Test基础语法"></a>2 Google Test基础语法</h1><h2 id="2-1-断言"><a href="#2-1-断言" class="headerlink" title="2.1 断言"></a>2.1 断言</h2><p><code>Google Test</code>提供了一系列的断言宏来检查条件是否满足。如果断言失败，测试用例被认为失败。断言分为两大类：<code>ASSERT_*</code> 和 <code>EXPECT_*</code>。</p><ul><li><code>ASSERT_*</code> 版本在断言失败时会产生一个致命错误，并终止当前函数的执行。包括<code>ASSERT_TRUE</code>,<code>ASSERT_FALSE</code>, <code>ASSERT_EQ</code>等</li><li><code>EXPECT_*</code> 版本在断言失败时会产生一个非致命错误，当前函数会继续执行，这允许测试多个条件。包括<code>EXPECT_TRUE</code>,<code>EXPECT_FALSE</code>, <code>EXPECT_EQ</code>等</li></ul><h2 id="2-2-测试用例和测试套件"><a href="#2-2-测试用例和测试套件" class="headerlink" title="2.2 测试用例和测试套件"></a>2.2 测试用例和测试套件</h2><h3 id="2-2-1-测试用例"><a href="#2-2-1-测试用例" class="headerlink" title="2.2.1 测试用例"></a>2.2.1 测试用例</h3><p><strong>测试用例（Test Case）</strong>：是指一组相关测试的集合。在<code>Google Test</code>中，使用 <code>TEST()</code> 宏来定义一个不需要额外的设置或清理过程的简单测试用例。使用 <code>TEST</code> 时，只需提供测试案例名称和测试名称，然后编写测试代码块。案例如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(RbTreeTest, InsertTEST) &#123;</span><br><span class="line">  <span class="comment">// 测试代码在这里</span></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 一个示例断言</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>TEST</code>宏后的2个参数唯一标记了一个测试用例, 第一个参数可以重复, 但2个参数不能同时重复。<br>使用 <code>TEST</code>，每个测试是独立的，测试之间不共享任何状态。这个宏适合于无状态的测试，或者不需要为多个测试维护一个共同的环境时。</p><h3 id="2-2-2-测试套件"><a href="#2-2-2-测试套件" class="headerlink" title="2.2.2 测试套件"></a>2.2.2 测试套件</h3><p><strong>测试套件（Test Suite）</strong>：在更早的<code>Google Test</code>版本中，测试套件是指具有相同前缀的一组测试用例的集合。在新版本中，使用 <code>TEST_F()</code> 宏来定义测试套件，并且需要定义一个测试固件（<code>Fixture</code>）类。</p><p><code>TEST_F</code> 宏在有一个测试固件时使用，测试固件是一种用来重用相同的设置和清理代码为多个测试服务的方法。测试固件通过一个从 <code>::testing::Test</code> 派生的类来定义。然后，可以重写 <code>SetUp</code> 和 <code>TearDown</code> 方法来初始化和清理测试环境。</p><p>下面是一个使用 <code>TEST_F</code> 的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义测试固件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTestFixture</span> : <span class="keyword">public</span> ::testing::Test &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetUp</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置测试环境的代码</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">TearDown</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清理测试环境的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 TEST_F 编写使用测试固件的测试</span></span><br><span class="line"><span class="built_in">TEST_F</span>(MyTestFixture, 测试名称) &#123;</span><br><span class="line">  <span class="comment">// 可以使用设置好的环境的测试代码</span></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 一个示例断言</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>TEST_F</code>，同一个固件内的每个测试按照它们定义的顺序运行，但<code>Google Test</code>确保每个测试是隔离的；也就是说，在每个测试之前，环境都会重置为通过 <code>SetUp</code> 建立的初始状态。这样，一个测试所做的改变不会影响到另一个测试。</p><h1 id="3-案例-CMake下使用gtest"><a href="#3-案例-CMake下使用gtest" class="headerlink" title="3 案例: CMake下使用gtest"></a>3 案例: <code>CMake</code>下使用<code>gtest</code></h1><p>这个案例中, 我用自己之前学习过程中用<code>C++</code>手写常见数据结构的项目来介绍<code>CMake</code>中<code>gtest</code>的使用, 仓库在: <a href="https://github.com/ToniXWD/cppDataStructure">https://github.com/ToniXWD/cppDataStructure</a></p><h2 id="3-1-简单测试用例"><a href="#3-1-简单测试用例" class="headerlink" title="3.1 简单测试用例"></a>3.1 简单测试用例</h2><h3 id="3-1-1-官方指导的CMake编写"><a href="#3-1-1-官方指导的CMake编写" class="headerlink" title="3.1.1 官方指导的CMake编写"></a>3.1.1 官方指导的<code>CMake</code>编写</h3><p>在<code>CMake</code>中使用<code>gtest</code>不需要自行下载源码, 只需在<code>CMakeLists.txt</code>中如下编写:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.14</span>)</span><br><span class="line"><span class="keyword">project</span>(my_project)</span><br><span class="line"></span><br><span class="line"><span class="comment"># GoogleTest requires at least C++14</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(</span><br><span class="line">  googletest</span><br><span class="line">  URL https://github.com/google/googletest/archive/<span class="number">03597</span>a01ee50ed33e9dfd640b249b4be3799d395.zip</span><br><span class="line">)</span><br><span class="line"><span class="comment"># For Windows: Prevent overriding the parent project&#x27;s compiler/linker settings</span></span><br><span class="line"><span class="keyword">set</span>(gtest_force_shared_crt <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line">FetchContent_MakeAvailable(googletest)</span><br></pre></td></tr></table></figure><p>然后就可以如下编写一个单元测试:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./tests/rbTree_test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/rbTree.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Demonstrate some basic assertions.</span></span><br><span class="line"><span class="built_in">TEST</span>(RbTreeTest, InsertTEST) &#123;</span><br><span class="line">  <span class="comment">// 创建 RedBlackTree 对象</span></span><br><span class="line">  RedBlackTree&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(mySet.<span class="built_in">empty</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入元素</span></span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">42</span>);</span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">21</span>);</span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">63</span>);</span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">36</span>);</span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">92</span>);</span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">75</span>);</span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">87</span>);</span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">58</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(mySet.<span class="built_in">len</span>() == mySet.<span class="built_in">getSizeByTranverse</span>());</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(mySet.<span class="built_in">isBlackLenLegal</span>());</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(mySet.<span class="built_in">isNoDoubleRed</span>());</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(mySet.<span class="built_in">len</span>(), <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">58</span>);</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(mySet.<span class="built_in">len</span>() == mySet.<span class="built_in">getSizeByTranverse</span>());</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(mySet.<span class="built_in">isBlackLenLegal</span>());</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(mySet.<span class="built_in">isNoDoubleRed</span>());</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(mySet.<span class="built_in">len</span>(), <span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line">...<span class="comment">//省略更多的测例</span></span><br></pre></td></tr></table></figure><p>编写完测试的<code>cpp</code>文件后, 还需要在<code>CMake</code>中进行下面的设置:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># rbTree_test</span></span><br><span class="line"><span class="keyword">add_executable</span>(</span><br><span class="line">  rbTree_test</span><br><span class="line">  tests/rbTree_test.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">  rbTree_test</span><br><span class="line">  GTest::gtest_main</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(GoogleTest)</span><br><span class="line">gtest_discover_tests(rbTree_test)</span><br></pre></td></tr></table></figure><p>这段<code>CMake</code>是为了设置并运行名为<code>rbTree_test</code>的测试用例:</p><ol><li><p><code>enable_testing()</code>用于启用当前目录和以下目录中的测试功能, 使用这个命令后就可以用<code>make test</code>来运行测试。</p></li><li><p><code>add_executable(rbTree_test tests/rbTree_test.cpp)</code><br>编译测试文件为可执行文件, 没啥好说的</p></li><li><p><code>target_link_libraries(rbTree_test GTest::gtest_main)</code><br>将测试可执行文件链接到<code>gtest</code>的<code>gtest_main</code>库</p></li><li><p><code>gtest_discover_tests(rbTree_test)</code><br> 告诉<code>CMake</code>去自动发现在<code>rbTree_test</code>可执行文件中定义的所有测试用例，并创建<code>CTest</code>测试案</p></li></ol><p>然后再命令行中执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> build/</span><br><span class="line">$ <span class="built_in">cd</span> build/ &amp;&amp; cmake ..</span><br><span class="line">$ make</span><br><span class="line">$ make <span class="built_in">test</span></span><br><span class="line">Running tests...</span><br><span class="line">Test project /home/xwd/cppDataStructure/build</span><br><span class="line">    Start 1: DequeTest.Basic1</span><br><span class="line">1/9 Test <span class="comment">#1: DequeTest.Basic1 ..................................   Passed    0.00 sec</span></span><br><span class="line">    Start 2: ListTest.Basic1</span><br><span class="line">2/9 Test <span class="comment">#2: ListTest.Basic1 ...................................   Passed    0.00 sec</span></span><br><span class="line">    Start 3: RbTreeTest.InsertTEST</span><br><span class="line">3/9 Test <span class="comment">#3: RbTreeTest.InsertTEST .............................   Passed    0.00 sec</span></span><br><span class="line">    Start 4: RbTreeTest.RemoveTest1</span><br><span class="line">4/9 Test <span class="comment">#4: RbTreeTest.RemoveTest1 ............................   Passed    0.00 sec</span></span><br><span class="line">    Start 5: RbTreeTest.RemoveTest2</span><br><span class="line">5/9 Test <span class="comment">#5: RbTreeTest.RemoveTest2 ............................   Passed    0.00 sec</span></span><br><span class="line">    Start 6: RbTreeTest.RemoveRoot</span><br><span class="line">6/9 Test <span class="comment">#6: RbTreeTest.RemoveRoot .............................   Passed    0.00 sec</span></span><br><span class="line">    Start 7: RbTreeTest.DoubleBlackTest</span><br><span class="line">7/9 Test <span class="comment">#7: RbTreeTest.DoubleBlackTest ........................   Passed    0.00 sec</span></span><br><span class="line">    Start 8: RbTreeTest.RemoveWithSiblingHasTwoBlackChildren</span><br><span class="line">8/9 Test <span class="comment">#8: RbTreeTest.RemoveWithSiblingHasTwoBlackChildren ...   Passed    0.00 sec</span></span><br><span class="line">    Start 9: RbTreeTest.RandomOperation</span><br><span class="line">9/9 Test <span class="comment">#9: RbTreeTest.RandomOperation ........................   Passed    0.01 sec</span></span><br><span class="line"></span><br><span class="line">100% tests passed, 0 tests failed out of 9</span><br><span class="line"></span><br><span class="line">Total Test time (real) =   0.03 sec</span><br></pre></td></tr></table></figure><h3 id="3-1-2-自动通过CMake注册单元测试"><a href="#3-1-2-自动通过CMake注册单元测试" class="headerlink" title="3.1.2 自动通过CMake注册单元测试"></a>3.1.2 自动通过<code>CMake</code>注册单元测试</h3><p>之前的内容可以看出, 每个单元测试都要单独地在<code>CMakeLists.txt</code>中指定链接库等, 很繁琐, 实际上我们可以借助<code>CMake</code>的语法自动注册单元测试:<br>首先假设所有的单元测试都在<code>test</code>文件夹下, 且形如<code>*_test.cpp</code>, 因此可以在<code>test</code>文件夹下编写<code>CMake</code>模块:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(</span><br><span class="line">  googletest</span><br><span class="line">  URL https://github.com/google/googletest/archive/<span class="number">03597</span>a01ee50ed33e9dfd640b249b4be3799d395.zip</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># For Windows: Prevent overriding the parent project&#x27;s compiler/linker settings</span></span><br><span class="line"><span class="keyword">set</span>(gtest_force_shared_crt <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line">FetchContent_MakeAvailable(googletest)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(GoogleTest)</span><br><span class="line"></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE TEST_CPPS <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/tests/*test.cpp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (test_source <span class="variable">$&#123;TEST_CPPS&#125;</span>)</span><br><span class="line">    <span class="comment"># Create a human readable name.</span></span><br><span class="line">    <span class="keyword">get_filename_component</span>(test_filename <span class="variable">$&#123;test_source&#125;</span> NAME)</span><br><span class="line">    <span class="keyword">string</span>(REPLACE <span class="string">&quot;.cpp&quot;</span> <span class="string">&quot;&quot;</span> mySTL_test_name <span class="variable">$&#123;test_filename&#125;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add the test target separately and as part of &quot;make check-tests&quot;.</span></span><br><span class="line">    <span class="keyword">add_executable</span>(<span class="variable">$&#123;mySTL_test_name&#125;</span>  <span class="variable">$&#123;test_source&#125;</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;mySTL_test_name&#125;</span> GTest::gtest_main)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gtest_discover_tests(<span class="variable">$&#123;mySTL_test_name&#125;</span></span><br><span class="line">            EXTRA_ARGS</span><br><span class="line">            --gtest_color=auto</span><br><span class="line">            --gtest_output=xml:<span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="keyword">test</span>/<span class="variable">$&#123;mySTL_test_name&#125;</span>.xml</span><br><span class="line">            --gtest_catch_exceptions=<span class="number">0</span></span><br><span class="line">            DISCOVERY_TIMEOUT <span class="number">120</span></span><br><span class="line">            PROPERTIES</span><br><span class="line">            TIMEOUT <span class="number">120</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set test target properties and dependencies.</span></span><br><span class="line">    <span class="keyword">set_target_properties</span>(<span class="variable">$&#123;mySTL_test_name&#125;</span></span><br><span class="line">            PROPERTIES</span><br><span class="line">            RUNTIME_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/test&quot;</span></span><br><span class="line">            <span class="keyword">COMMAND</span> <span class="variable">$&#123;mySTL_test_name&#125;</span></span><br><span class="line">            )</span><br><span class="line"><span class="keyword">endforeach</span> ()</span><br></pre></td></tr></table></figure><p>在线获取<code>gtest</code>的部分和之前一样, 这里介绍其是如何自动发现单元测试文件的:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB_RECURSE TEST_CPPS <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/tests/*test.cpp&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>file(GLOB_RECURSE ...)</code>用于递归地搜索所有匹配的文件，并将它们的列表存储在变量<code>TEST_CPPS</code>中。在这种情况下，它搜索项目源目录下<code>tests</code>文件夹中所有以<code>test.cpp</code>结尾的文件。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (test_source <span class="variable">$&#123;TEST_CPPS&#125;</span>)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endforeach</span> ()</span><br></pre></td></tr></table></figure><p>这个循环遍历所有找到的测试文件。对于每个文件，它执行以下操作：</p><ul><li>获取文件名，去除<code>.cpp</code>后缀，创建一个易读的测试名称（<code>mySTL_test_name</code>）。</li><li>使用<code>add_executable</code>为每个测试文件创建一个可执行文件。</li><li>使用<code>target_link_libraries</code>将Google Test主库链接到每个测试可执行文件。</li><li>调用<code>gtest_discover_tests</code>来发现和注册测试，设置额外的参数和属性，包括输出格式（XML），是否捕获异常，测试发现超时和测试超时。</li><li>设置每个测试目标的属性，确保测试的可执行文件被放置在预期的目录，并指定运行测试的命令。</li></ul><p>然后只需要在根路径下的<code>CMakeLists</code>中包含这个模块即可:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(tests)</span><br></pre></td></tr></table></figure><p>之后自己新建的单元测试就可以被自动发现了</p><h2 id="3-2-测试套件"><a href="#3-2-测试套件" class="headerlink" title="3.2 测试套件"></a>3.2 测试套件</h2><p>如果有这样一种情况, 多个测试用例中, 代码初始化部分逻辑是相同的, 可以将其设置为测试套件, 下面是一个测试堆(<code>Heap</code>)数据结构的单元测试:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/heap.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义测试固件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InitHeap</span> : <span class="keyword">public</span> ::testing::Test &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Heap&lt;<span class="type">int</span>&gt; minHeap;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetUp</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置测试环境的代码</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">TearDown</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清理测试环境的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test case for inserting elements into the heap</span></span><br><span class="line"><span class="built_in">TEST_F</span>(InitHeap, InsertAndSize) &#123;</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(minHeap.<span class="built_in">size</span>(), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test case for removing the root element</span></span><br><span class="line"><span class="built_in">TEST_F</span>(InitHeap, RemoveRoot) &#123;</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(minHeap.<span class="built_in">removeRoot</span>(), <span class="number">2</span>); <span class="comment">// Assuming a min heap</span></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(minHeap.<span class="built_in">size</span>(), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test case to check heap property is maintained after insertions</span></span><br><span class="line"><span class="built_in">TEST_F</span>(InitHeap, HeapPropertyAfterInsertion) &#123;</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(minHeap.<span class="built_in">removeRoot</span>(), <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(minHeap.<span class="built_in">removeRoot</span>(), <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(minHeap.<span class="built_in">removeRoot</span>(), <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(minHeap.<span class="built_in">removeRoot</span>(), <span class="number">5</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(minHeap.<span class="built_in">removeRoot</span>(), <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test case for handling removal from an empty heap</span></span><br><span class="line"><span class="built_in">TEST_F</span>(InitHeap, RemoveFromEmptyHeap) &#123;</span><br><span class="line">  <span class="built_in">EXPECT_THROW</span>(minHeap.<span class="built_in">removeRoot</span>(), std::out_of_range);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test case for dynamic resizing of the heap</span></span><br><span class="line"><span class="built_in">TEST_F</span>(InitHeap, ResizeHeap) &#123;</span><br><span class="line">  <span class="type">size_t</span> initialCapacity = <span class="number">32</span>; <span class="comment">// Assuming initial capacity is 32</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; initialCapacity + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    minHeap.<span class="built_in">insert</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">EXPECT_GT</span>(minHeap.<span class="built_in">size</span>(), initialCapacity);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(initialCapacity); ++i) &#123;</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(minHeap.<span class="built_in">removeRoot</span>(), i); <span class="comment">// Assuming a min heap</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test case for max heap property</span></span><br><span class="line"><span class="built_in">TEST</span>(HeapTest, MaxHeapProperty) &#123;</span><br><span class="line">  Heap&lt;<span class="type">int</span>, std::greater&lt;<span class="type">int</span>&gt;&gt; maxHeap;</span><br><span class="line">  maxHeap.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">  maxHeap.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">  maxHeap.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line">  maxHeap.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">  maxHeap.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">  maxHeap.<span class="built_in">insert</span>(<span class="number">26</span>);</span><br><span class="line">  maxHeap.<span class="built_in">insert</span>(<span class="number">-5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(maxHeap.<span class="built_in">removeRoot</span>(), <span class="number">26</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(maxHeap.<span class="built_in">removeRoot</span>(), <span class="number">8</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(maxHeap.<span class="built_in">removeRoot</span>(), <span class="number">5</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(maxHeap.<span class="built_in">removeRoot</span>(), <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(maxHeap.<span class="built_in">removeRoot</span>(), <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(maxHeap.<span class="built_in">removeRoot</span>(), <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(maxHeap.<span class="built_in">removeRoot</span>(), <span class="number">-5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了最后一个测试用例外, 每个测试都是初始化一个泛型为<code>int</code>的小根堆, 因此可以定义一个继承自<code>testing::Test</code>的类<code>InitHeap</code>, 并添加一个成员变量<code>minHeap</code>, 此后在使用<code>TEST_F</code>宏的测试案中将第一个参数设置为<code>InitHeap</code>, 然后就可以不用初始化小根堆了。如果有别的需求， 还可以重写<code>TearDown</code>和<code>SetUp</code>成员方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Google-Test简介&quot;&gt;&lt;a href=&quot;#1-Google-Test简介&quot; class=&quot;headerlink&quot; title=&quot;1 Google Test简介&quot;&gt;&lt;/a&gt;1 Google Test简介&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Google Test&lt;</summary>
      
    
    
    
    <category term="C++随笔" scheme="http://example.com/categories/C-%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="单元测试" scheme="http://example.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    <category term="gtest" scheme="http://example.com/tags/gtest/"/>
    
  </entry>
  
  <entry>
    <title>CMU15445 2022 project0: C++ Primer: 字典树</title>
    <link href="http://example.com/2024/02/06/CMU15445/proj0/"/>
    <id>http://example.com/2024/02/06/CMU15445/proj0/</id>
    <published>2024-02-06T09:37:18.000Z</published>
    <updated>2024-02-21T16:16:04.636Z</updated>
    
    <content type="html"><![CDATA[<p>这是对个人在2022年秋的<code>CMU15445</code>的<code>project</code>总结, 算是补档, 所有很多代码也忘了, 这里也就值只介绍其中的思路, 不涉及具体代码细节, 不过<code>CMU15445</code>的老师<code>Andy</code>本来也禁止个人公开代码实现的。</p><p>本次实验是实现一个字典树<code>Trie</code>, 但难度主要不在这个数据结构, 更多是通过这个项目熟悉<code>C++</code>常见的新特性。</p><p><code>官方project指导书</code>: <a href="https://15445.courses.cs.cmu.edu/fall2022/project0/">https://15445.courses.cs.cmu.edu/fall2022/project0/</a></p><h1 id="1-Trie数据结构介绍"><a href="#1-Trie数据结构介绍" class="headerlink" title="1 Trie数据结构介绍"></a>1 <code>Trie</code>数据结构介绍</h1><p>下面是摘自官方文档的数据结构示意图:</p><p><img src="/../../images/CMU15445/trie.png" alt="trie"></p><p>在上面的图中可以看到, 字典树每个节点实际上存储的就是字符串的一个字符, 这个树结构从根路径到叶子结点路径上的字符一起组成了字符串, 如<code>hello</code>, <code>have</code>, <code>hat</code></p><p>另一方面, 还可以在特定的节点存储<code>value</code>形成<code>KV</code>存储的数据结构, 下面是摘自官方文档的数据结构示意图:</p><blockquote><p>另外, 如果不存在某个字符是所有字符串的祖先(第一个字符), 就设一个空的<code>root</code>节点替代</p></blockquote><p><img src="/../../images/CMU15445/trie-kv.png" alt="trie-k"></p><p>这个数据结构存储了<code>(&quot;ab&quot;, 1)</code> 和 <code>(&quot;ac&quot;, &quot;val&quot;)</code>2个数据结构</p><p>可以看出, 这种数据结构的核心思想就是: <strong>将公共的前缀压缩在树的公共祖先路径上</strong>, 路径形成<code>key</code>, 再在节点上存储<code>value</code></p><h1 id="2-代码实现思路"><a href="#2-代码实现思路" class="headerlink" title="2 代码实现思路"></a>2 代码实现思路</h1><h2 id="2-1-数据结构解析"><a href="#2-1-数据结构解析" class="headerlink" title="2.1 数据结构解析"></a>2.1 数据结构解析</h2><p>给出的代码框架中, <code>TrieNode</code>就对应不包含值的节点, <code>TrieNodeWithValue</code>就是包含了值的节点, 二者是继承关系, 而<code>TrieNode</code>使用<code>unordered_map</code>存储指向每个节点的<code>unique_ptr</code></p><h2 id="2-3-Insert函数实现思路"><a href="#2-3-Insert函数实现思路" class="headerlink" title="2.3 Insert函数实现思路"></a>2.3 <code>Insert</code>函数实现思路</h2><p><code>Insert</code> 函数是一个模板函数，用于插入键值对。它接受一个字符串 <code>key</code> 作为要插入的键，以及一个 <code>value</code> 作为与键关联的值。流程如下：</p><ol><li><p>检查键 (<code>key</code>) 是否为空。如果为空，直接返回 <code>false</code></p></li><li><p>使用迭代器<code>c</code> 循环遍历 <code>key</code> 中的每个字符，直至迭代器 <code>c</code> 到达 <code>key</code> 的末尾。</p></li><li><p>在循环中，<code>cur</code> 存储当前迭代器 <code>c</code> 的值，并立即将 <code>c</code> 增加。如果 <code>c</code> 到达 <code>key</code> 的末尾，则跳出循环。</p></li><li><p>检查前一个子节点 <code>pre_child</code> 是否有当前字符 <code>*cur</code> 对应的子节点。</p><ol><li>如果没有，使用 <code>InsertChildNode</code> 创建一个新的 <code>TrieNode</code> 子节点，并更新 <code>pre_child</code> 指向新节点。</li><li>如果 <code>pre_child</code> 已经有当前字符 <code>*cur</code> 对应的子节点，那么就获取这个子节点，并更新 <code>pre_child</code> 指向它。</li></ol></li><li><p>循环结束后，<code>c</code> 递减，指向 <code>key</code> 的最后一个字符。</p></li><li><p>尝试获取最后一个字符对应的子节点 <code>end_node</code>。</p><ol><li>如果 <code>end_node</code> 已经存在并且是一个结束节点（即已经存储了一个值），则释放写锁并返回 <code>false</code>，表示键已存在。</li><li>如果 <code>end_node</code> 存在但不是结束节点，创建一个带有值 <code>value</code> 的新 <code>TrieNodeWithValue</code> 节点，并使用 <code>std::move</code> 把 <code>end_node</code> 的数据移动到新节点。然后用 <code>reset</code> 方法替换 <code>end_node</code> 中的指针。</li><li>如果 <code>end_node</code> 不存在，使用 <code>InsertChildNode</code> 在 <code>pre_child</code> 下插入一个新的 <code>TrieNode</code>，然后创建一个新的 <code>TrieNodeWithValue</code> 实例，将 <code>pre_child</code> 的数据移动到新节点，并设置值 <code>value</code>。</li></ol></li><li><p>最后，函数释放写锁，并返回 <code>true</code>，表示键值对已成功插入字典树。</p></li></ol><p>上面的代码其实说的太详细了, <code>Tie</code>的插入其实也很简单, 之所以说这么复杂, 主要是要提到使用的<code>C++11\14\17</code>的新特性</p><h2 id="2-2-Remove函数实现思路"><a href="#2-2-Remove函数实现思路" class="headerlink" title="2.2 Remove函数实现思路"></a>2.2 <code>Remove</code>函数实现思路</h2><ol><li><p>检查键是否为空：<br>如果提供的键 <code>key</code> 为空字符串，函数返回 <code>false</code>，因为无法从Trie中移除一个不存在的键。</p></li><li><p>使用栈跟踪路径：<br>  代码初始化了一个栈 <code>s</code> 来存储遍历过程中的路径。栈中的元素是一个包含字符和指向<code>TrieNode</code>指针的<code>pair</code>。</p></li><li><p>遍历键中的每个字符：</p><ol><li>使用一个迭代器 <code>c</code> 遍历键 <code>key</code> 的每个字符。</li><li>检查是否存在当前字符对应的子节点。如果存在：<ol><li>将当前字符和指向父节点的指针存入栈中。</li><li>更新 <code>pre_child</code> 指向当前字符的子节点。</li></ol></li><li>如果不存在当前字符对应的子节点，说明键不在Trie中，返回 <code>false</code>。</li></ol></li><li><p>检查并移除没有子节点的节点：</p><ol><li>从栈中弹出元素，这样就可以从键的末尾向根节点遍历。</li><li>对于每一个弹出的元素，检查当前节点（通过 <code>(*node)-&gt;GetChildNode(key)</code> 获取）是否存在子节点。</li><li>如果当前节点没有子节点，使用 <code>(*node)-&gt;RemoveChildNode(key)</code> 方法移除它。</li><li>如果当前节点有子节点，说明该节点是其他键的前缀，或者其子节点中有其他键的后续部分，因此不能移除该节点。</li></ol></li><li><p>返回成功：<br>  如果整个键已经被遍历，并且相关节点已被移除，函数返回 <code>true</code> 表示键已成功从Trie中移除。</p></li></ol><p>在这个过程中，推荐使用后进先出（LIFO）的栈结构来保存遍历过程中的路径。这是因为在移除过程中，可能需要从叶子节点回溯到根节点，去除沿途的任何不再有用的节点。这种回溯机制确保只有当<strong>一个节点不再表示任何其他键时，它才会被移除</strong>。如果在回溯过程中<strong>遇到一个有子节点的节点，这意味着该节点仍然是其他键的一部分</strong>，因此该节点和它的祖先节点都不应该被移除。</p><p>这个代码实际写起来应该很简单, 本项目的目的也就是对C++17进行练手而已</p><h1 id="3-补充知识-用到的C-新特性"><a href="#3-补充知识-用到的C-新特性" class="headerlink" title="3 补充知识: 用到的C++新特性"></a>3 补充知识: 用到的C++新特性</h1><h2 id="3-1-右值"><a href="#3-1-右值" class="headerlink" title="3.1 右值"></a>3.1 右值</h2><h3 id="3-1-1-右值的定义"><a href="#3-1-1-右值的定义" class="headerlink" title="3.1.1 右值的定义"></a>3.1.1 右值的定义</h3><p>在C++中，右值（rvalue）是指一个临时的、非持久的对象，它通常出现在赋值表达式的右侧。右值表示对象的值，而不是对象的身份（位置），这意味着它们不具有可识别的内存地址。</p><p>C++中的值可以分为两大类：左值（lvalue）和右值（rvalue）。左值是指那些具有持久状态的对象，这些对象通常可以<strong>通过它们的地址来标识</strong>。它们可以出现在赋值表达式的左侧。例如，一个变量或者一个数组的元素都是左值。</p><p>而右值分为两类：</p><ol><li><p>纯右值：表示表达式完全不对应任何对象存储位置。例如，数字字面量（如<code>42</code>）、算术表达式的结果（如<code>3+4</code>）、返回非引用类型的函数调用等。</p></li><li><p>将亡值：C++11中引入的概念，是一种特殊的右值，它对应于即将被销毁、或者可以“移动”的对象。这类右值允许将资源（比如动态分配的内存）从一个对象转移到另一个对象，这样可以提升效率，避免不必要的复制。例如，使用<code>std::move</code>函数可以将一个左值转换为将亡值。</p></li></ol><p>右值的一个关键特性是它们可以被移动而非复制，这是C++11中引入的右值引用（<code>&amp;&amp;</code>）的主要用途。右值引用允许开发者重用即将销毁的对象的资源，例如在移动构造函数（<code>T(T&amp;&amp;)</code>）和移动赋值操作符（<code>T&amp; operator=(T&amp;&amp;)</code>）中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">42</span>; <span class="comment">// 42是一个纯右值</span></span><br><span class="line"><span class="type">int</span> b = a;  <span class="comment">// a是一个左值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp;&amp; rvalue_ref = a * <span class="number">2</span>; <span class="comment">// a * 2是一个纯右值，rvalue_ref是对它的右值引用</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; moved_ref = std::<span class="built_in">move</span>(b); <span class="comment">// 使用std::move将b转换为一个将亡值，moved_ref是对它的右值引用</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>42</code>是一个纯右值，<code>a * 2</code>是一个临时结果，也是一个纯右值，而<code>std::move(b)</code>将<code>b</code>转换为一个将亡值，这允许将<code>b</code>的资源移动到另一个对象中。</p><h3 id="3-1-2-赋值后的右值"><a href="#3-1-2-赋值后的右值" class="headerlink" title="3.1.2 赋值后的右值"></a>3.1.2 赋值后的右值</h3><p>这里有个非常容易误解的地方, 涉及到C++中的一个微妙之处。当创建一个右值引用，比如 <code>int&amp;&amp; rvalue_ref</code>，并将一个右值表达式 <code>a * 2</code> 绑定到它上面时，<code>rvalue_ref</code> 本身成为一个具名的引用，它的身份可以被识别，因此在某种意义上它表现得像一个左值。</p><p>然而，<code>rvalue_ref</code> 仍然保持着与它所绑定的右值的联系，这意味着可以使用它来“移动”所绑定的临时对象的资源，正如右值引用的初衷那样。C++标准规定，即使是具名的右值引用，也应该被视为一个右值，以允许移动语义和其他对右值的操作。</p><p>在函数重载解析中，<code>rvalue_ref</code> 会被当作一个右值来处理。举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// 针对左值的重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// 针对右值的重载</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; rvalue_ref = a * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">foo</span>(rvalue_ref); <span class="comment">// 这里会调用 foo(int&amp;&amp; x)</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，即使 <code>rvalue_ref</code> 是一个具名的变量，<code>foo(rvalue_ref)</code> 依然会调用接受右值引用的重载版本 <code>foo(int&amp;&amp; x)</code>，因为 <code>rvalue_ref</code> 在表达式中被视为右值。</p><p>然而，如果尝试对 <code>rvalue_ref</code> 取地址或者再次对其赋值，它就会表现得像一个左值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = &amp;rvalue_ref; <span class="comment">// 现在取得了它的地址，它表现得像一个左值</span></span><br><span class="line"></span><br><span class="line">rvalue_ref = <span class="number">100</span>; <span class="comment">// 可以对它赋值，它表现得像一个左值</span></span><br></pre></td></tr></table></figure><p>在这些情况下，<code>rvalue_ref</code> 的行为与左值没有区别，因为它是一个具名的对象，可以对它进行操作，例如取地址和赋值，这是标准左值操作。</p><p>下面的陈述不一定复合编译器的事实, 但阐述了右值的思想: <strong>右值引用的出现可以延长一个右值的生命周期，并提供了对这个右值的直接访问。</strong>:<br>比较<code>int&amp;&amp; rvalue_ref = a * 2;</code>和<code>int&amp; rvalue_ref = a * 2;</code>这2句代码的执行, </p><ul><li><code>int rvalue_ref = a * 2;</code>的执行</li></ul><ol><li><code>a * 2</code>这个临时的右值存放在栈上</li><li><code>rvalue_ref</code>是个左值,  <code>a * 2</code>会被复制到<code>rvalue_ref</code>的地址中</li><li><code>rvalue_ref</code>的地址被释放</li></ol><ul><li><code>int&amp;&amp; rvalue_ref = a * 2;</code>的执行</li></ul><ol><li><code>a * 2</code>这个临时的右值存放在栈上</li><li><code>rvalue_ref</code>是个右值引用, 其内存地址直接和存放<code>a * 2</code>这个临时的右值的地址相同</li><li>由于原来临时右值将要被继续使用, 所以不需要释放</li></ol><h2 id="3-1-3-右值的使用——完美转发"><a href="#3-1-3-右值的使用——完美转发" class="headerlink" title="3.1.3 右值的使用——完美转发"></a>3.1.3 右值的使用——完美转发</h2><p>完美转发（<code>Perfect forwarding</code>）是C++11引入的一个概念，简单说就是: <strong>允许函数模板将其接收到的参数以原始的值类别（即保持其是左值还是右值的特性）转发到另一个函数</strong>。其目的也是减少复制的数量。</p><p>完美转发的关键在于<code>std::forward</code>函数模板和右值引用的结合使用。右值引用独自并不能实现完美转发，因为当一个右值引用被传递时，它变成了一个左值。为了解决这个问题，<code>std::forward</code>用于保持参数的原始值类别。</p><p>以下是使用右值引用和<code>std::forward</code>实现完美转发的一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// For std::forward</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forwarder</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span>&amp;&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只有当n是一个右值时，这里的代码才会被执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    forwarder(g, <span class="number">42</span>); <span class="comment">// 42是一个右值，forwarder能够完美转发它到g</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>forwarder</code>是一个函数模板，它接受任意类型的函数<code>f</code>和参数<code>args</code>。它用<code>std::forward</code>来转发参数<code>args</code>到函数<code>f</code>，同时保持每个参数的左值或右值属性。</p><p><code>std::forward</code>的作用是这样的：</p><ul><li>当参数是一个左值时，<code>std::forward</code>将其转换为左值引用类型。</li><li>当参数是一个右值时，<code>std::forward</code>将其转换为右值引用类型，允许移动语义的发生。</li></ul><h2 id="3-2-智能指针"><a href="#3-2-智能指针" class="headerlink" title="3.2 智能指针"></a>3.2 智能指针</h2><p>所有的智能指针都是自动回收资源, 这一点是最重要的。</p><h2 id="3-2-1-unique-ptr"><a href="#3-2-1-unique-ptr" class="headerlink" title="3.2.1 unique_ptr"></a>3.2.1 <code>unique_ptr</code></h2><p>在任何给定时间，只有一个 <code>unique_ptr</code> 实例可以指向一个特定的对象。这个特性使得 <code>unique_ptr</code> 成为管理动态分配内存的理想选择，因为它可以确保对象被正确删除，并且防止了资源泄露。</p><p><code>unique_ptr</code> 是一个模板类，提供了一系列用于管理动态分配的资源的接口函数。以下是一些常用的接口函数及其用法：</p><ol><li><strong>初始化</strong></li></ol><ul><li><p><strong>构造函数</strong>：可以用来创建 <code>unique_ptr</code>，有多种构造方式，包括默认构造、从原始指针构造等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr1; <span class="comment">// 默认构造，初始化为空</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">5</span>))</span></span>; <span class="comment">// 从原始指针构造</span></span><br></pre></td></tr></table></figure></li><li><p><strong>移动构造函数</strong>：允许从另一个 <code>unique_ptr</code> 转移所有权。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr3</span><span class="params">(std::move(ptr2))</span></span>; <span class="comment">// ptr2 为空，ptr3 拥有原始资源</span></span><br></pre></td></tr></table></figure></li><li><p><strong>make_unique</strong>：C++14 引入了 <code>std::make_unique</code> 函数模板，用于在堆上创建一个对象，并返回这个对象的 <code>unique_ptr</code>。这是创建 <code>unique_ptr</code> 的推荐方式，因为它可以防止原始指针的泄露，并且可以提供异常安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr7 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">30</span>); <span class="comment">// 使用 make_unique 创建</span></span><br></pre></td></tr></table></figure></li><li><p><strong>构造函数 with deleter</strong>：创建一个带有自定义删除器的 <code>unique_ptr</code>。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> deleter = [](<span class="type">int</span>* ptr)&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Custom deleter is called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>, <span class="title">decltype</span><span class="params">(deleter)</span>&gt; <span class="title">ptr6</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>, deleter)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><p><strong>赋值</strong></p><ul><li><strong>移动赋值操作符</strong>：允许转移所有权。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr4 = std::<span class="built_in">move</span>(ptr3); <span class="comment">// ptr3 为空，ptr4 拥有原始资源</span></span><br></pre></td></tr></table></figure></li><li><p><strong>资源管理</strong></p><ul><li><strong>reset</strong>：替换管理的对象，或设置为空。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr4.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>)); <span class="comment">// ptr4 现在拥有一个新的 int 对象</span></span><br><span class="line">ptr4.<span class="built_in">reset</span>(); <span class="comment">// 自动删除管理的对象，并将 ptr4 设置为空</span></span><br></pre></td></tr></table></figure><ul><li><strong>release</strong>：释放对对象的所有权，并返回原始指针，之后 <code>unique_ptr</code> 将为空。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* rawPtr = ptr4.<span class="built_in">release</span>(); <span class="comment">// 现在 rawPtr 是裸指针，需要手动管理</span></span><br></pre></td></tr></table></figure><ul><li><strong>swap</strong>：交换两个 <code>unique_ptr</code> 的管理的对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr5</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">20</span>))</span></span>;</span><br><span class="line">ptr4.<span class="built_in">swap</span>(ptr5); <span class="comment">// 现在 ptr4 管理一个 int(20)，ptr5 为空</span></span><br></pre></td></tr></table></figure></li><li><p><strong>裸指针获取</strong></p><ul><li><strong>get</strong>：返回管理的对象的裸指针。</li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* rawPtr = ptr5.<span class="built_in">get</span>(); <span class="comment">// 不释放所有权，仅返回指针</span></span><br></pre></td></tr></table></figure><ul><li>**<code>operator*</code> 和 <code>operator-&gt;</code>**：提供对管理对象的访问。</li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = *ptr5; <span class="comment">// 访问 int 值</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="3-2-2-shared-ptr"><a href="#3-2-2-shared-ptr" class="headerlink" title="3.2.2 shared_ptr"></a>3.2.2 <code>shared_ptr</code></h2><p>与 <code>unique_ptr</code> 不同，多个 <code>shared_ptr</code> 实例可以共享同一个对象，引用计数会跟踪有多少个 <code>shared_ptr</code> 拥有同一个资源，当最后一个 <code>shared_ptr</code> 被销毁时，资源会被自动释放。</p><ol><li><strong>构造函数</strong></li></ol><ul><li><p><strong>默认构造函数</strong>：构造一个空的 <code>shared_ptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr;</span><br></pre></td></tr></table></figure></li><li><p><strong>从原始指针构造</strong>：创建一个 <code>shared_ptr</code> 管理一个新的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>拷贝构造函数</strong>：构造一个新的 <code>shared_ptr</code>，它与另一个 <code>shared_ptr</code> 共享对象，并增加引用计数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>移动构造函数</strong>：从另一个 <code>shared_ptr</code> 移动构造，转移所有权并将原 <code>shared_ptr</code> 设置为空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr3</span><span class="params">(std::move(ptr2))</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>构造函数 with deleter</strong>：创建一个带有自定义删除器的 <code>shared_ptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> deleter = [](<span class="type">int</span>* p)&#123; <span class="keyword">delete</span> p; &#125;;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr6</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>, deleter)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>make_shared</strong>：C++11 引入了 <code>std::make_shared</code> 函数模板，用于在堆上创建一个对象，并返回这个对象的 <code>shared_ptr</code>。这是创建 <code>shared_ptr</code> 的推荐方式，因为它通常更高效，并可以减少内存分配次数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr7 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">30</span>);</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>赋值运算符</strong></li></ol><ul><li><p><strong>拷贝赋值运算符</strong>：允许将一个 <code>shared_ptr</code> 的所有权赋值给另一个 <code>shared_ptr</code>，原 <code>shared_ptr</code> 的引用计数减一，新 <code>shared_ptr</code> 的引用计数加一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr4;</span><br><span class="line">ptr4 = ptr;</span><br></pre></td></tr></table></figure></li><li><p><strong>移动赋值运算符</strong>：将一个 <code>shared_ptr</code> 的所有权移动给另一个 <code>shared_ptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr5;</span><br><span class="line">ptr5 = std::<span class="built_in">move</span>(ptr4);</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>资源管理</strong></li></ol><ul><li><p><strong>reset</strong>：更换 <code>shared_ptr</code> 所管理的对象，或者放弃对当前对象的所有权。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>)); <span class="comment">// ptr 现在指向新的 int 对象</span></span><br><span class="line">ptr.<span class="built_in">reset</span>(); <span class="comment">// 放弃所有权，如果 ptr 是最后一个引用，将释放对象</span></span><br></pre></td></tr></table></figure></li><li><p><strong>use_count</strong>：返回当前共享同一个对象的 <code>shared_ptr</code> 数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> count = ptr.<span class="built_in">use_count</span>(); <span class="comment">// 获取引用计数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>unique</strong>：检查 <code>shared_ptr</code> 是否是管理对象的唯一拥有者。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isUnique = ptr.<span class="built_in">unique</span>(); <span class="comment">// 如果引用计数为1，则返回 true</span></span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><strong>裸指针获取</strong></li></ol><ul><li><p><strong>get</strong>：返回管理的对象的原始指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* rawPtr = ptr.<span class="built_in">get</span>(); <span class="comment">// 获取裸指针</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>operator*</code> 和 <code>operator-&gt;</code>**：提供对管理对象的访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = *ptr; <span class="comment">// 解引用</span></span><br><span class="line"><span class="type">int</span> value = ptr-&gt;<span class="built_in">someMethod</span>(); <span class="comment">// 访问对象成员</span></span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li><strong>检查</strong></li></ol><ul><li><p><strong>operator bool</strong>：检查 <code>shared_ptr</code> 是否拥有一个对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr is not empty.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-3-weak-ptr"><a href="#3-2-3-weak-ptr" class="headerlink" title="3.2.3 weak_ptr"></a>3.2.3 <code>weak_ptr</code></h2><p><code>weak_ptr</code> 用来解决智能指针间的循环引用问题。<code>weak_ptr</code> 持有对 <code>shared_ptr</code> 管理对象的非拥有（弱）引用，即它不会增加对象的引用计数。这意味着 <code>weak_ptr</code> 的存在不会阻止其所指向的对象被销毁。</p><p><code>weak_ptr</code> 主要用于监视 <code>shared_ptr</code>，而不是拥有资源。它通常用于缓存、观察者模式、和防止 <code>shared_ptr</code> 之间的循环引用导致的内存泄漏。</p><p><strong>一个循环引用的例子</strong><br>如果有两个类 <code>A</code> 和 <code>B</code>，它们互相持有对方的 <code>shared_ptr</code>，那么它们将永远不会被释放，因为它们的引用计数永远不会降到零。使用 <code>weak_ptr</code> 可以打破这种循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; b_ptr;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;A&gt; a_ptr; <span class="comment">// 使用 weak_ptr 而不是 shared_ptr</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，即使 <code>A</code> 和 <code>B</code> 相互引用，一旦外部对 <code>A</code> 和 <code>B</code> 的 <code>shared_ptr</code> 被销毁，它们最终也能被正确清理。</p><ol><li><strong>构造函数</strong></li></ol><ul><li><p><strong>默认构造函数</strong>：创建一个不指向任何对象的 <code>weak_ptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; wp;</span><br></pre></td></tr></table></figure></li><li><p><strong>从 shared_ptr 构造</strong>：创建一个 <code>weak_ptr</code> 实例，它指向由 <code>shared_ptr</code> 管理的对象，但不增加引用计数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>资源管理</strong></li></ol><ul><li><p><strong>reset</strong>：重置 <code>weak_ptr</code> 实例，放弃对对象的引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wp.<span class="built_in">reset</span>();</span><br></pre></td></tr></table></figure></li><li><p><strong>use_count</strong>：返回与此 <code>weak_ptr</code> 共享对象的 <code>shared_ptr</code> 实例的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> count = wp.<span class="built_in">use_count</span>(); <span class="comment">// 如果对象已经被删除，则返回 0</span></span><br></pre></td></tr></table></figure></li><li><p><strong>expired</strong>：检查所管理的对象是否已经被删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isExpired = wp.<span class="built_in">expired</span>(); <span class="comment">// 如果对象已经被删除，则返回 true</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>获得 <code>shared_ptr</code></strong></li></ol><ul><li><strong>lock</strong>：尝试从 <code>weak_ptr</code> 创建一个 <code>shared_ptr</code> 实例。如果对象还存在，这将返回一个有效的 <code>shared_ptr</code>，否则返回一个空的 <code>shared_ptr</code>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp = wp.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (sp) &#123;</span><br><span class="line">    <span class="comment">// 对象仍然存在，可以安全使用 sp</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 对象已被删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-3-类型转换"><a href="#3-3-类型转换" class="headerlink" title="3.3 类型转换"></a>3.3 类型转换</h2><p>C++ 提供了四种类型转换运算符来覆盖不同的类型转换场景：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code> 和 <code>reinterpret_cast</code>。</p><h3 id="3-3-1-static-cast"><a href="#3-3-1-static-cast" class="headerlink" title="3.3.1 static_cast"></a>3.3.1 <code>static_cast</code></h3><p><code>static_cast</code> 在编译时执行类型转换，不进行运行时类型检查。<code>static_cast</code> 可以用于各种明确的类型转换，包括基本数据类型之间的转换、指向基类和派生类之间的转换（只要没有虚继承），以及用户定义的类型转换（通过转换构造函数或转换运算符）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(i); <span class="comment">// 基础数据类型转换</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2-dynamic-cast"><a href="#3-3-2-dynamic-cast" class="headerlink" title="3.3.2 dynamic_cast"></a>3.3.2 <code>dynamic_cast</code></h3><p><code>dynamic_cast</code> 专门用于处理多态类型。它在运行时检查对象类型，确保转换的安全性。<code>dynamic_cast</code> 主要用于将基类指针或引用安全地转换为派生类指针或引用，它依赖于运行时类型信息（<code>RTTI</code>）。</p><p>如果转换失败，当转换的目标类型是指针时，<code>dynamic_cast</code> 返回 <code>nullptr</code>；当目标类型是引用时，则抛出一个 <code>std::bad_cast</code> 异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line">Base* base_ptr = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived* derived_ptr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base_ptr); <span class="comment">// 安全地转换为派生类指针</span></span><br></pre></td></tr></table></figure><h3 id="3-3-3-const-cast"><a href="#3-3-3-const-cast" class="headerlink" title="3.3.3 const_cast"></a>3.3.3 <code>const_cast</code></h3><p><code>const_cast</code> 用于改变对象的 <code>const</code> 或 <code>volatile</code> 属性。它是唯一能够去除对象的 <code>const</code> 属性的 C++ 类型转换运算符。但是，它不应该用来去除对象本身就是常量的 <code>const</code> 属性，那样会导致未定义行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* modifiable = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;i); <span class="comment">// 去除 const 属性</span></span><br></pre></td></tr></table></figure><h3 id="3-3-4-reinterpret-cast"><a href="#3-3-4-reinterpret-cast" class="headerlink" title="3.3.4 reinterpret_cast"></a>3.3.4 <code>reinterpret_cast</code></h3><p><code>reinterpret_cast</code> 提供了低级别的重新解释类型的能力，它可以将任何指针转换为任何其他类型的指针。也可以用于指针与足够大的整数类型之间的转换。<code>reinterpret_cast</code> 不检查语义安全性，其实也就类似C语言的强制转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> p = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="type">void</span>* vp = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(p); <span class="comment">// 将整数转换为 void 指针</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是对个人在2022年秋的&lt;code&gt;CMU15445&lt;/code&gt;的&lt;code&gt;project&lt;/code&gt;总结, 算是补档, 所有很多代码也忘了, 这里也就值只介绍其中的思路, 不涉及具体代码细节, 不过&lt;code&gt;CMU15445&lt;/code&gt;的老师&lt;code&gt;And</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CMU15445" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/CMU15445/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="Trie" scheme="http://example.com/tags/Trie/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>清华大学开源操作系统训练营: rCore chapter1笔记</title>
    <link href="http://example.com/2024/02/05/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch1%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/02/05/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch1%E7%AC%94%E8%AE%B0/</id>
    <published>2024-02-05T07:06:13.000Z</published>
    <updated>2024-02-21T16:16:04.677Z</updated>
    
    <content type="html"><![CDATA[<p>本文不会将原本<code>rCore文档</code>的内容重复太多, 主要是补充学习过程中遇到的知识点, 因此还需结合原文使用, 原文在后面的链接中</p><p>本章节的内容是介绍如何构建一个能在裸机上运行的<code>Rust</code>程序, 这一部分其实也是很多操作系统课程, 包括<code>MIT 6.S081</code>缺少的部分, 通过这一部分, 我们可以学习到操作系统和硬件之间是如何工作的, 还是挺重要的。</p><p>本文是只个人对官方文档第一章知识的梳理和补充，因此一些基础的知识概念并不会再设计， 这些细节请阅读：</p><p>完整版官方文档： <a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/1app-ee-platform.html">https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/1app-ee-platform.html</a></p><p>精简版文档： <a href="https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter1/index.html">https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter1/index.html</a></p><h1 id="1-理论知识梳理"><a href="#1-理论知识梳理" class="headerlink" title="1 理论知识梳理"></a>1 理论知识梳理</h1><h2 id="1-1-应用程序执行环境"><a href="#1-1-应用程序执行环境" class="headerlink" title="1.1 应用程序执行环境"></a>1.1 应用程序执行环境</h2><p><img src="/../../../images/LearningOS/ch1-env.png" alt="应用程序执行环境栈"></p><p>上图是从官方文档中摘取的，<code>操作系统</code>承接了<code>硬件平台</code>和各种编程语言标准库中的<code>系统调用</code>, 裸机程序就是没有操作系统的程序, 因此我们实现的程序需要绕过标准库直接和硬件打交道, 一句话就是, 不能调包了, 得手写</p><h2 id="1-2-平台与目标三元组"><a href="#1-2-平台与目标三元组" class="headerlink" title="1.2 平台与目标三元组"></a>1.2 平台与目标三元组</h2><p>目标三元组 (Target Triplet): CPU 指令集、操作系统类型和标准运行时库。</p><p><code>Rust</code>工具链中的<code>rustc</code>可以获取以上信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ rustc --version --verbose</span><br><span class="line">rustc 1.75.0-nightly (aa1a71e9e 2023-10-26)</span><br><span class="line">binary: rustc</span><br><span class="line">commit-hash: aa1a71e9e90f6eb3aed8cf79fc80bea304c17ecb</span><br><span class="line">commit-date: 2023-10-26</span><br><span class="line">host: x86_64-unknown-linux-gnu</span><br><span class="line">release: 1.75.0-nightly</span><br><span class="line">LLVM version: 17.0.3</span><br></pre></td></tr></table></figure><p><code>host</code>中展示了: 目标平台是<code> x86_64-unknown-linux-gnu</code>， CPU 架构是 <code>x86_64</code>，CPU 厂商是 <code>unknown</code>, 操作系统是 <code>linux</code>，运行时库是 <code>gnu</code></p><h2 id="1-3-从qemu看层级架构"><a href="#1-3-从qemu看层级架构" class="headerlink" title="1.3 从qemu看层级架构"></a>1.3 从qemu看层级架构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-riscv64 \</span><br><span class="line">    -machine virt \</span><br><span class="line">    -nographic \</span><br><span class="line">    -bios ../bootloader/rustsbi-qemu.bin \</span><br><span class="line">    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000</span><br></pre></td></tr></table></figure><p>下面是<code>qemu</code>的启动命令, 其中<code>os.bin</code>就是我们构建的裸机程序, 但为什么又存在一个<code>rustsbi-qemu.bin</code>呢?</p><p>这涉及到计算机的启动流程, 在<code>qemu</code>虚拟平台上, 第一阶段的启动是<code>qemu</code>自己提供的程序, 第二段启动是<code>bootloader</code>, <code>bootloader</code>进行硬件相关的初始化工作, 第三个阶段是加载操作系统镜像（就是这里的裸机程序）。每一阶段的程序都需要将下一阶段程序放在指定的位置并进行跳转。</p><p>也就是说，我们的裸机程序直接在<code>bootloader</code>启动后就运行了， 不需要操作系统</p><p>更详细的启动流程请见<a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/3first-instruction-in-kernel1.html#id5">官方文档说明</a></p><h2 id="1-4-裸机程序构建思路"><a href="#1-4-裸机程序构建思路" class="headerlink" title="1.4 裸机程序构建思路"></a>1.4 裸机程序构建思路</h2><p>第一章中, 裸机程序的构建实际上就是一步步<strong>剥离标准库</strong>并实现替代标准库中相应数据结构和函数的过程。因为<code>std</code>依赖于操作系统, 因此需要用不依赖与操作系统的<code>core</code>代替</p><p>裸机程序的代码其实不复杂, 只是涉及一些不常用的知识点, 包括内联汇编等, 这些在后面的补充知识会介绍到, 除此外, 原始文档给的代码很详细了, 因此这里就不进行代码分析了。</p><h2 id="1-5-链接脚本的作用"><a href="#1-5-链接脚本的作用" class="headerlink" title="1.5 链接脚本的作用"></a>1.5 链接脚本的作用</h2><p>由于上述的原因，<code>bootloader</code>启动后跳转的地址是固定的(<code>bootloader</code>已经提供了, 不需要自己实现), 所以程序需要将起始位置放置在这固定的内存位置(此时还没有页表, 是物理内存地址), 这就是链接脚本的作用</p><p>具体内存也参见<a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/3first-instruction-in-kernel1.html#id8">官方文档说明</a></p><h2 id="1-6-剥离elf"><a href="#1-6-剥离elf" class="headerlink" title="1.6 剥离elf"></a>1.6 剥离elf</h2><p>编译后的代码存在一些元数据段， 因此需要将其剥离才能将程序的第一条指令放在指定的位置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin</span><br></pre></td></tr></table></figure><p>具体的解析参考<a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/4first-instruction-in-kernel2.html#id5">源文档</a></p><h2 id="1-7-sbi的调用时机"><a href="#1-7-sbi的调用时机" class="headerlink" title="1.7 sbi的调用时机"></a>1.7 <code>sbi</code>的调用时机</h2><p>我第一次阅读官方文档后仍然有一个疑惑, 就是我们是如何调用<code>sbi</code>, 提供的服务的? </p><p>实际上还是使用<code>ecall</code>, 先贴出调用<code>sbi</code>的代码:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[inline(always)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sbi_call</span>(which: <span class="type">usize</span>, arg0: <span class="type">usize</span>, arg1: <span class="type">usize</span>, arg2: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(</span><br><span class="line">            <span class="string">&quot;li x16, 0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">inlateout</span>(<span class="string">&quot;x10&quot;</span>) arg0 =&gt; ret,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x11&quot;</span>) arg1,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x12&quot;</span>) arg2,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x17&quot;</span>) which,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里, 和U模式下的系统调用中<code>ecall</code>的使用类似, S模式下也是通过<code>ecall</code>来进入M模式, 从而使用<code>sbi</code>提供的服务。相关部分会在后续的系统调用章节进行更多的介绍， 此处只简单介绍：</p><ol><li>S 模式下的操作系统设置 <code>a0-a7 </code>和<code> t0</code> 寄存器，以指定所需的 SBI 调用和参数。</li><li>操作系统执行 <code>ecall</code> 指令，触发异常并切换到 M 模式。</li><li>M 模式下的 <code>SBI</code> 实现查看寄存器的值，确定请求的服务并执行它。</li><li><code>SBI</code> 实现将结果存入寄存器中。</li><li>控制权返回给 S 模式的操作系统，操作系统读取寄存器以获取服务结果。</li></ol><p>这种机制允许分离操作系统和机器模式执行环境，使得操作系统无须了解硬件的详细实现，也能够利用硬件提供的功能。</p><h1 id="2-补充知识"><a href="#2-补充知识" class="headerlink" title="2 补充知识"></a>2 补充知识</h1><h2 id="2-1-cargo配置"><a href="#2-1-cargo配置" class="headerlink" title="2.1 cargo配置"></a>2.1 <code>cargo</code>配置</h2><p><code>Rust</code> 项目中，<code>.cargo/config</code> 是一个配置文件，用于定义和调整 Cargo 的各种行为和设置。<code>Cargo</code> 是 <code>Rust</code> 的包管理器和构建工具，它处理依赖下载、编译过程及更多功能。<code>.cargo/config</code> 文件通常位于项目的根目录下的 <code>.cargo</code> 文件夹内，或者在用户的主目录下的 <code>.cargo</code> 文件夹内作为全局配置。</p><p>下面是 <code>.cargo/config</code> 文件中一些基本配置操作的概述：</p><ol><li><p>设置构建目标<br>可以指定默认的构建目标（target triple）：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[build]</span></span><br><span class="line"><span class="attr">target</span> = <span class="string">&quot;riscv64gc-unknown-none-elf&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>设置构建标志<br>可以添加自定义的构建标志，比如优化等级、链接参数等：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[build]</span></span><br><span class="line"><span class="attr">rustflags</span> = [<span class="string">&quot;-C&quot;</span>, <span class="string">&quot;opt-level=2&quot;</span>]</span><br></pre></td></tr></table></figure></li><li><p>设置环境变量<br>可以设置在构建脚本中使用的环境变量：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[build]</span></span><br><span class="line"><span class="attr">rustc-env</span> = [<span class="string">&quot;RUST_BACKTRACE=1&quot;</span>]</span><br></pre></td></tr></table></figure></li><li><p>定义自定义构建目标<br>如果有一个自定义的架构，可以指定链接器和其他构建参数：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[target.i686-unknown-linux-gnu]</span></span><br><span class="line"><span class="attr">linker</span> = <span class="string">&quot;gcc&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>重写依赖源<br>如果需要从不同的源或者私有源下载依赖项，可以重写它们：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[source.crates-io]</span></span><br><span class="line"><span class="attr">replace-with</span> = <span class="string">&#x27;tuna&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[source.tuna]</span></span><br><span class="line"><span class="attr">registry</span> = <span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>设置别名<br>可以为常用的命令设置别名，以便更快地调用：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[alias]</span></span><br><span class="line"><span class="attr">b</span> = <span class="string">&quot;build&quot;</span></span><br><span class="line"><span class="attr">r</span> = <span class="string">&quot;run&quot;</span></span><br><span class="line"><span class="attr">t</span> = <span class="string">&quot;test&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>配置货物配置文件<br>可以为不同的构建配置（例如 debug 或 release）指定不同的设置：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure></li></ol><p>在实际使用中，应该根据项目的具体需要来调整这些设置。此外，<code>.cargo/config</code> 文件支持层级结构，可以在多个目录级别定义配置文件，Cargo 会合并这些配置，其中更具体（更深层目录）的配置会覆盖更通用（更高层目录）的配置。</p><p>下面是本项目的<code>cargo</code>配置文件:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[build]</span></span><br><span class="line"><span class="section">[build]</span></span><br><span class="line"><span class="attr">target</span> = <span class="string">&quot;riscv64gc-unknown-none-elf&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[target.riscv64gc-unknown-none-elf]</span></span><br><span class="line"><span class="attr">rustflags</span> = [</span><br><span class="line">    <span class="string">&quot;-Clink-arg=-Tsrc/linker.ld&quot;</span>, <span class="string">&quot;-Cforce-frame-pointers=yes&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其中 两个 Rust 编译器标志（<code>rustflags</code>）解释如下：</p><ol><li><p><code>-Clink-arg=-Tsrc/linker.ld</code>: 这告诉 Rust 编译器传递 <code>linker.ld</code> 链接器脚本文件的路径给链接器。链接器脚本文件通常用于指导链接器如何生成最终的可执行文件，包括内存布局等。这里 <code>linker.ld</code> 文件位于项目的 <code>src</code> 目录下。</p></li><li><p><code>-Cforce-frame-pointers=yes</code>: 这指示 Rust 编译器在生成可执行文件时，即使在优化模式下也保留帧指针。帧指针通常用于帮助调试和获取函数调用栈信息，但有时在优化时会被省略以提高性能。</p></li></ol><h2 id="2-2-链接脚本的语法"><a href="#2-2-链接脚本的语法" class="headerlink" title="2.2 链接脚本的语法"></a>2.2 链接脚本的语法</h2><p>下面是<code>ch1</code>中使用的链接脚本:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_ARCH(riscv) </span><br><span class="line">/*设置了目标平台为 riscv */</span><br><span class="line">ENTRY(_start)</span><br><span class="line">/* 设置了整个程序的入口点为之前定义的全局符号 _start */</span><br><span class="line">BASE_ADDRESS = 0x80200000;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = BASE_ADDRESS;</span><br><span class="line">    skernel = .;</span><br><span class="line"></span><br><span class="line">    stext = .;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    etext = .;</span><br><span class="line">    srodata = .;</span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata .rodata.*)</span><br><span class="line">        *(.srodata .srodata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    erodata = .;</span><br><span class="line">    sdata = .;</span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data .data.*)</span><br><span class="line">        *(.sdata .sdata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    edata = .;</span><br><span class="line">    .bss : &#123;</span><br><span class="line">        *(.bss.stack)</span><br><span class="line">        sbss = .;</span><br><span class="line">        *(.bss .bss.*)</span><br><span class="line">        *(.sbss .sbss.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    ebss = .;</span><br><span class="line">    ekernel = .;</span><br><span class="line"></span><br><span class="line">    /DISCARD/ : &#123;</span><br><span class="line">        *(.eh_frame)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链接脚本 (<code>Linker Script</code>) 是由 <code>GNU</code> 链接器 (<code>ld</code>) 使用的脚本语言，用于控制程序的链接过程。链接脚本的语法允许用户定义输出文件的内存布局，指定各个段的位置、大小和属性。</p><ol><li><p>输出架构 (<code>OUTPUT_ARCH</code>)<br><code>OUTPUT_ARCH(architecture)</code><br>  指定目标架构，告诉链接器生成针对特定架构的代码。</p></li><li><p>入口点 (<code>ENTRY</code>)<br><code>ENTRY(symbol)</code><br>  指定程序的入口点，即程序开始执行的地方。</p></li><li><p>符号赋值<br><code>symbol = expression;</code><br>  定义符号，并将其设置为特定的值或地址。</p></li><li><p>段定义 (<code>SECTIONS</code>)<br><code>SECTIONS &#123;...&#125;</code><br>  段定义块开始和结束的标志，里面包含了对输出段的具体指令。</p></li><li><p>地址计数器<br><code>.</code> (点) 表示当前地址计数器，可以设置为特定值或者用于符号赋值。<br><strong>进行字段包含后, 其会自动地增长</strong></p></li><li><p>段地址和属性<br><code>segment : &#123; subsections &#125;</code><br>  定义一个段（如 <code>.text</code>, <code>.data</code>），并指定包含在该段的子段内容。</p></li><li><p>子段<br><code>*(.subsection)</code><br>  将特定的子段包含进父段中，如将 <code>.text</code> 子段包含进 <code>.text</code> 段中。</p></li><li><p>对齐指令 (ALIGN)<br><code>ALIGN(expression)</code><br>  对当前地址计数器进行对齐，确保地址是特定值的倍数，常用于页对齐或数据结构对齐。</p></li><li><p>输出段属性</p></li></ol><ul><li><code>&gt;region</code><br>指定输出段应该放置在哪个内存区域。</li><li><code>AT(address)</code><br>指定输出段的加载地址，与放置地址可能不同。</li><li><code>:alignment</code><br>指定段对齐。</li></ul><ol start="10"><li>内存布局 (<code>MEMORY</code>)</li></ol><ul><li><code>MEMORY &#123; ... &#125;</code><br>定义内存布局和属性，用于告诉链接器如何使用不同的内存区域。</li></ul><ol start="11"><li><code>/DISCARD/</code></li></ol><ul><li><code>/DISCARD/ : &#123; ... &#125;</code><br>用于丢弃不需要的段，例如调试信息或未使用的段。</li></ul><p>现在再来看本章的链接脚本:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_ARCH(riscv) </span><br><span class="line">/*设置了目标平台为 riscv */</span><br><span class="line">ENTRY(_start)</span><br><span class="line">/* 设置了整个程序的入口点为之前定义的全局符号 _start */</span><br><span class="line">BASE_ADDRESS = 0x80200000;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = BASE_ADDRESS;</span><br><span class="line">    skernel = .;</span><br><span class="line"></span><br><span class="line">    stext = .;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    etext = .;</span><br><span class="line">    srodata = .;</span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata .rodata.*)</span><br><span class="line">        *(.srodata .srodata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    erodata = .;</span><br><span class="line">    sdata = .;</span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data .data.*)</span><br><span class="line">        *(.sdata .sdata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    edata = .;</span><br><span class="line">    .bss : &#123;</span><br><span class="line">        *(.bss.stack)</span><br><span class="line">        sbss = .;</span><br><span class="line">        *(.bss .bss.*)</span><br><span class="line">        *(.sbss .sbss.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    ebss = .;</span><br><span class="line">    ekernel = .;</span><br><span class="line"></span><br><span class="line">    /DISCARD/ : &#123;</span><br><span class="line">        *(.eh_frame)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就很好理解了, 其分别将指的目标文件中各个段的内容整合在一起, 并且为每个段的开始地址声明了变量: <code>stext</code>, <code>etext</code>, <code>erodata</code>, <code>edata</code>, <code>ebss</code> </p><h2 id="2-3-Rust宏语法"><a href="#2-3-Rust宏语法" class="headerlink" title="2.3 Rust宏语法"></a>2.3 <code>Rust</code>宏语法</h2><p>本项目执行实现了<code>println!</code>宏, 在我之前学<code>Rust</code>时, 主要是使用已定义的宏, 自己实现宏的部分仅仅是略过, 因此这里特别来复习下宏的定义, 项目中定义了下面的宏:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> print &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        $crate::console::<span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>($fmt $(, $($arg)+)?))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释如下:</p><ol><li><p><code>#[macro_export]</code><br>表示这个宏是要被导出的，使得当这个宏所在的<code>crate</code>被其他<code>crate</code>引用时，这个宏也可以被使用。</p></li><li><p><code>macro_rules!</code><br>这是宏的声明开始，<code>macro_rules!</code>是Rust中定义宏的关键字，后面跟着的<code>println</code>是宏的名字。</p></li><li><p>宏的匹配部分</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">($fmt: literal $(, $($arg: tt)+)?)</span><br></pre></td></tr></table></figure><p> 这行定义了宏的模式匹配部分。它匹配一个字面量<code>$fmt</code>作为第一个参数，后面可以跟一个逗号和任意数量的额外参数<code>$arg</code>。参数使用Rust宏的”token tree” (<code>tt</code>)设计，它可以匹配几乎任何Rust语法。</p></li></ol><ul><li><code>$fmt: literal</code>表示第一个参数必须是一个字面量（通常是一个字符串字面量）。</li><li><code>literal</code>: 一个特定的关键字, 用来指定宏参数应该是一个字面量</li><li><code>$(, $($arg: tt)+)?</code>是一个可选的模式，它使用了Rust宏的重复模式：</li><li><code>$($arg: tt)+</code>表示可以有一个或多个额外的参数，每个参数都是一个<code>token tree</code>。</li></ul><blockquote><p>补充宏知识<br>在Rust的宏定义中，<code>$</code>和<code>?</code>符号都用于模式匹配，但它们在宏规则中扮演着不同的角色。</p><ul><li><code>$</code> 符号: <ul><li>用法1: 指示一个变量的开始，可以捕获宏输入中的相应部分。在宏规则中，<code>$</code>后面通常跟着一个标识符和一个冒号，再跟着一个设计符(<code>designator</code>)，用来指定变量的类型。例如，<code>$var:ident</code>表示匹配一个标识符并将其绑定到变量<code>$var</code>中。</li><li>用法2: 标识重复的开始，例如<code>$($arg:tt),*</code>表示重复匹配<code>$arg</code>零次或多次，每次匹配由逗号分隔。</li></ul></li><li><code>?</code> 符号: 它用于表示前面的模式是可选的。在宏规则中，将<code>?</code>放在模式的外部，表示这个模式可以出现零次或一次。这类似于正则表达式中的<code>?</code>运算符。例如，在<code>$($arg:tt)?</code>中，<code>?</code>表明<code>$arg</code>是可选的，可以有或没有。</li><li><code>+</code> 符号: 它用于表示前面的模式出现一次多次。在宏规则中，将<code>+</code>放在模式的外部，表示这个模式可以出现一次或多次。这类似于正则表达式中的<code>+</code>运算符。例如，在<code>$($arg:tt)+</code>中，<code>?</code>表明<code>$arg</code>以出现一次或多次</li></ul><p>结合上面的符号使用时，<code>$</code>捕获宏参数，而<code>?</code>或<code>+</code>指定这些参数的重复模式。所以<code>$(, $($arg: tt)+)?</code>这部分的意思是：</p><ul><li><code>$( ... )?</code> 表示整个模式是可选的，即可以有也可以没有。</li><li><code>,</code> 表示模式的开始，一个逗号，用来分隔参数。</li><li><code>$($arg: tt)+</code> 表示匹配一个或多个<code>$arg</code>，每个<code>$arg</code>是一个token tree。</li></ul></blockquote><ol start="4"><li>匹配后的动作<br>根据前面的分析, 这个模式可以匹配零个或多个以逗号分隔的<code>token trees</code>，如果匹配到，则将这些<code>token trees</code>作为参数传递给<code>format_args!</code>宏。 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$crate::console::<span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>(<span class="built_in">concat!</span>($fmt, <span class="string">&quot;\n&quot;</span>) $(, $($arg)+)?))</span><br></pre></td></tr></table></figure></li></ol><p>这是宏展开的部分。</p><ul><li><code>$crate</code>是一个特殊的变量，它在宏内部用于引用当前<code>crate</code>的根路径，这样即使宏被移动到其他crate中，它也能正确地引用到原来的<code>crate</code>中定义的项。</li><li><code>format_args!</code>是Rust的一个内置宏，用于处理格式化参数。它接受一个格式化字符串和对应的参数，并返回一个可以延迟计算的格式化参数结构体，这通常用于避免字符串的分配和复制。</li><li><code>concat!($fmt, &quot;\n&quot;)</code>将传入的格式化字符串和一个换行符连在一起，确保输出后会自动换行。</li><li><code>$(, $($arg)+)?</code>是对传入参数的引用，如果有参数的话，它们会被插入到格式化参数结构体中。</li></ul><h2 id="2-4-Rust内联汇编"><a href="#2-4-Rust内联汇编" class="headerlink" title="2.4 Rust内联汇编"></a>2.4 Rust内联汇编</h2><p>使用的<code>RustSbi</code>中存在如下的<code>Rust</code>内联汇编的用法:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[inline(always)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sbi_call</span>(which: <span class="type">usize</span>, arg0: <span class="type">usize</span>, arg1: <span class="type">usize</span>, arg2: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(</span><br><span class="line">            <span class="string">&quot;li x16, 0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">inlateout</span>(<span class="string">&quot;x10&quot;</span>) arg0 =&gt; ret,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x11&quot;</span>) arg1,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x12&quot;</span>) arg2,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x17&quot;</span>) which,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释如下:</p><ol><li><p><code>#[inline(always)]</code><br><code>Rust</code>的属性<code>#[inline(always)]</code>告诉编译器这个函数应该总是被内联，也就是说，在每个调用点替换为函数体的代码，而不是实际进行函数调用。</p></li><li><p><code>asm!</code><br><code>asm!</code>宏是用来编写内联汇编代码的，这段代码直接使用了RISC-V的汇编语法：</p><ul><li><p><code>&quot;li x16, 0&quot;</code>：这条指令将立即数0加载到寄存器<code>x16</code>中。<code>li</code>代表”load immediate”。</p></li><li><p><code>&quot;ecall&quot;</code>：陷入更低级的模式</p></li><li><p><code>inlateout(&quot;x10&quot;) arg0 =&gt; ret</code><br>  在<code>ecall</code>执行后，返回值通常存放在<code>x10</code>寄存器中。Rust内联汇编通过<code>inlateout(&quot;x10&quot;) arg0 =&gt; ret</code>这个约束来传递这个信息，即<code>arg0</code>的值在<code>ecall</code>执行前被放入<code>x10</code>寄存器中，并且<code>ecall</code>执行后，<code>x10</code>寄存器中的值会存放到变量<code>ret</code>中。</p></li><li><p><code>in(&quot;x11&quot;) arg1</code> &amp;&amp; <code>in(&quot;x12&quot;) arg2</code> &amp;&amp; <code>in(&quot;x17&quot;) which</code><br>  在执行汇编代码前将值加载到指定的寄存器中。在这种情况下，<code>arg1</code>被加载到<code>x11</code>寄存器，<code>arg2</code>被加载到<code>x12</code>寄存器，<code>which</code>被加载到<code>x17</code>寄存器。</p></li></ul></li></ol><p>这里容易产生一个误区, 就是, 存放输入寄存器的操作位于<code>ecall</code>出现之后, 实际上所有的输入操作数都是在执行任何汇编指令之前就被放入相应寄存器中的。</p><h2 id="2-5-直接嵌入汇编代码"><a href="#2-5-直接嵌入汇编代码" class="headerlink" title="2.5 直接嵌入汇编代码"></a>2.5 直接嵌入汇编代码</h2><p>可以使用 <code>global_asm!</code> 宏包含全局汇编代码。这个宏允许在 <code>Rust</code> 代码中直接嵌入汇编代码片段，并且这些代码会在全局范围内被汇编器处理。</p><p>以下项目代码中的 <code>global_asm!</code> 的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(global_asm)]</span></span><br><span class="line"></span><br><span class="line">global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;entry.asm&quot;</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文不会将原本&lt;code&gt;rCore文档&lt;/code&gt;的内容重复太多, 主要是补充学习过程中遇到的知识点, 因此还需结合原文使用, 原文在后面的链接中&lt;/p&gt;
&lt;p&gt;本章节的内容是介绍如何构建一个能在裸机上运行的&lt;code&gt;Rust&lt;/code&gt;程序, 这一部分其实也是很多</summary>
      
    
    
    
    <category term="训练营笔记" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
    
    <category term="清华大学开源操作系统训练营2023" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A52023/"/>
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="riscv" scheme="http://example.com/tags/riscv/"/>
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.5840(6.824) Lab3: 分布式KV数据库 3B</title>
    <link href="http://example.com/2024/02/03/MIT6.5840/Lab3B/"/>
    <id>http://example.com/2024/02/03/MIT6.5840/Lab3B/</id>
    <published>2024-02-03T10:19:25.000Z</published>
    <updated>2024-10-03T17:47:36.141Z</updated>
    
    <content type="html"><![CDATA[<p><em>最新的更新在博客 <a href="https://tonixwd.github.io/">ToniBlog</a></em></p><p>本文将介绍<code>lab3B</code>部分的实现, <code>lab3B</code>要求基于在<code>lab3A</code>的基础上实现快照, 仅从<code>lab</code>本省来讲其实很简单, 可以说是目前我做的所有<code>lab</code>里面难度最小的一个模块了, 但实际上遇到了很多困难, 调试的时间比<code>lab3A</code>还久, 核心原因就是自己的<code>lab2</code>实现的<code>raft</code>底层有一些问题(真真真真太折磨了, 即时过了所有单元测试, 还是时不时地在后续的<code>lab</code>暴露出问题来, 并且这些问题还挺难定位, 得仔细分析海量的<code>log</code>输出才可以)</p><p><code>Lab</code>文档见: <a href="http://nil.csail.mit.edu/6.5840/2023/labs/lab-kvraft.html">http://nil.csail.mit.edu/6.5840/2023/labs/lab-kvraft.html</a></p><p>我的代码: <a href="https://github.com/ToniXWD/MIT6.5840/tree/lab3B">https://github.com/ToniXWD/MIT6.5840/tree/lab3B</a></p><h1 id="1-快照的生成和传递逻辑"><a href="#1-快照的生成和传递逻辑" class="headerlink" title="1 快照的生成和传递逻辑"></a>1 快照的生成和传递逻辑</h1><p>简单说, <code>lab3B</code>就是要在底层<code>raft</code>的<code>log</code>过大时生成快照并截断日志, 从而节省内存空间, 并且快照会持久化存储到本地。因此， 原来的代码结构只需要在以下几个方面做出调整：</p><ol><li>需要再某个地方定期地判断底层<code>raft</code>的日志大小, 决定是否要生成快照, 生成快照直接调用我们在<code>lab2</code>中实现的接口<code>Snapshot</code>即可</li><li>由于<code>follower</code>的底层<code>raft</code>会出现无法从<code>Leader</code>获取<code>log</code>的情况, 这时<code>Leader</code>会发送给<code>follower</code>的<code>raft</code>层一个快照, <code>raft</code>层会将其上交给<code>server</code>, <code>server</code>通过快照改变自己的状态机</li><li><code>server</code>启动时需要判断是否有持久化的快照需要加载, 如果有就加载</li></ol><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a>2 代码实现</h1><h2 id="2-1-快照应该包含什么"><a href="#2-1-快照应该包含什么" class="headerlink" title="2.1 快照应该包含什么?"></a>2.1 快照应该包含什么?</h2><p>快照首先应该包含的肯定是内存中的<code>KV</code>数据库, 也就是自己维护的<code>map</code>, 但是还应该包含对每个<code>clerk</code>序列号的记录信息, 因为从快照恢复后的<code>server</code>应该具备判断重复的客户端请求的能力, 同时也应该记录最近一次应用到状态机的日志索引, 凡是低于这个索引的日志都是包含在快照中</p><p>因此, <code>server</code>结构体需要添加如下成员:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KVServer <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">persister    *raft.Persister</span><br><span class="line">lastApplied  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-加载和生成快照"><a href="#2-2-加载和生成快照" class="headerlink" title="2.2 加载和生成快照"></a>2.2 加载和生成快照</h2><p>通过上述分析, 快照的加载和生成就很简单了,代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> GenSnapShot() []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="comment">// 调用时必须持有锁mu</span></span><br><span class="line">w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">e := labgob.NewEncoder(w)</span><br><span class="line"></span><br><span class="line">e.Encode(kv.db)</span><br><span class="line">e.Encode(kv.historyMap)</span><br><span class="line"></span><br><span class="line">serverState := w.Bytes()</span><br><span class="line"><span class="keyword">return</span> serverState</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> LoadSnapShot(snapShot []<span class="type">byte</span>) &#123;</span><br><span class="line"><span class="comment">// 调用时必须持有锁mu</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(snapShot) == <span class="number">0</span> || snapShot == <span class="literal">nil</span> &#123;</span><br><span class="line">ServerLog(<span class="string">&quot;server %v LoadSnapShot: 快照为空&quot;</span>, kv.me)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r := bytes.NewBuffer(snapShot)</span><br><span class="line">d := labgob.NewDecoder(r)</span><br><span class="line"></span><br><span class="line">tmpDB := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">tmpHistoryMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]*Result)</span><br><span class="line"><span class="keyword">if</span> d.Decode(&amp;tmpDB) != <span class="literal">nil</span> ||</span><br><span class="line">d.Decode(&amp;tmpHistoryMap) != <span class="literal">nil</span> &#123;</span><br><span class="line">ServerLog(<span class="string">&quot;server %v LoadSnapShot 加载快照失败\n&quot;</span>, kv.me)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">kv.db = tmpDB</span><br><span class="line">kv.historyMap = tmpHistoryMap</span><br><span class="line">ServerLog(<span class="string">&quot;server %v LoadSnapShot 加载快照成功\n&quot;</span>, kv.me)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GenSnapShot</code>和<code>LoadSnapShot</code>分别生成和加载快照, 唯一需要注意的就是这两个函数应当在持有锁时才能调用</p><h2 id="2-3-生成快照的时机判断"><a href="#2-3-生成快照的时机判断" class="headerlink" title="2.3 生成快照的时机判断"></a>2.3 生成快照的时机判断</h2><p>由于<code>ApplyHandler</code>协程会不断地读取<code>raft commit</code>的通道, 所以每收到一个<code>log</code>后进行判断即可:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> ApplyHandler() &#123;</span><br><span class="line"><span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">log := &lt;-kv.applyCh</span><br><span class="line"><span class="keyword">if</span> log.CommandValid &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 如果在follower一侧, 可能这个log包含在快照中, 直接跳过</span></span><br><span class="line"><span class="keyword">if</span> log.CommandIndex &lt;= kv.lastApplied &#123;</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 每收到一个log就检测是否需要生成快照</span></span><br><span class="line"><span class="keyword">if</span> kv.maxraftstate != <span class="number">-1</span> &amp;&amp; kv.persister.RaftStateSize() &gt;= kv.maxraftstate/<span class="number">100</span>*<span class="number">95</span> &#123;</span><br><span class="line"><span class="comment">// 当达到95%容量时需要生成快照</span></span><br><span class="line">snapShot := kv.GenSnapShot()</span><br><span class="line">kv.rf.Snapshot(log.CommandIndex, snapShot)</span><br><span class="line">&#125;</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还需要进行之前提到的判断: 低于<code>lastApplied</code>索引的日志都是包含在快照中, 在尽显<code>lab3A</code>的操作之后, 再判断是否需要生成快照, 在我的实现中, 如果仅仅比较<code>maxraftstate</code>和<code>persister.RaftStateSize()</code>相等才生成快照的话, 无法通过测例, 因为可能快照<code>RPC</code>存在一定延时, 所以我采用的手段是只要达到阈值的95%, 就生成快照</p><h2 id="2-4-加载快照的时机判断"><a href="#2-4-加载快照的时机判断" class="headerlink" title="2.4 加载快照的时机判断"></a>2.4 加载快照的时机判断</h2><p>首先启动时需要判断是否需要加载快照, 然后就是<code>ApplyHandler</code>从通道收到快照时需要判断加载, 都很简单:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartKVServer</span><span class="params">(servers []*labrpc.ClientEnd, me <span class="type">int</span>, persister *raft.Persister, maxraftstate <span class="type">int</span>)</span></span> *KVServer &#123;</span><br><span class="line">...</span><br><span class="line">kv.persister = persister</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先在启动时检查是否有快照</span></span><br><span class="line">kv.mu.Lock()</span><br><span class="line">kv.LoadSnapShot(persister.ReadSnapshot())</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> kv.ApplyHandler()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> ApplyHandler() &#123;</span><br><span class="line"><span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">log := &lt;-kv.applyCh</span><br><span class="line"><span class="keyword">if</span> log.CommandValid &#123;</span><br><span class="line">            ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> log.SnapshotValid &#123;</span><br><span class="line"><span class="comment">// 日志项是一个快照</span></span><br><span class="line">kv.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> log.SnapshotIndex &gt;= kv.lastApplied &#123;</span><br><span class="line">kv.LoadSnapShot(log.Snapshot)</span><br><span class="line">kv.lastApplied = log.SnapshotIndex</span><br><span class="line">&#125;</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-调试Bug和修复"><a href="#3-调试Bug和修复" class="headerlink" title="3 调试Bug和修复"></a>3 调试Bug和修复</h1><p>这里才是这个<code>lab</code>的重头戏, 我在完成上述所有修改后, 会在<code>TestSnapshotUnreliable3B</code>这个单元测试中大概率卡死, 一直会卡到<code>go</code>默认的十分钟单元测试时间截止后才报错退出, 在反复检查了<strong>死锁</strong>和<strong>持锁接发通道消息</strong>等常见问题并确认无误后, 我再次观察超时报错的堆栈信息和日志输出, 得到结论就是:<br><strong><code>raft</code>层因为无法承受测试的高并发程度而导致大量的<code>RPC</code>请求失败, 从而导致<code>clerk</code>无限重复发送请求<code>RPC</code>(我的实现是<code>RPC</code>请求失败)就重试</strong></p><p>……陷入了沉思, 自己还是菜啊, 但代码还得慢慢修, 总不能把<code>raft</code>推倒重来吧……</p><p>我最后分别从<code>raft</code>层和<code>server</code>层进行了优化</p><h2 id="3-1-raft层优化"><a href="#3-1-raft层优化" class="headerlink" title="3.1 raft层优化"></a>3.1 <code>raft</code>层优化</h2><h3 id="3-1-1-修复过多的AppendEntries-RPC"><a href="#3-1-1-修复过多的AppendEntries-RPC" class="headerlink" title="3.1.1 修复过多的AppendEntries RPC"></a>3.1.1 修复过多的<code>AppendEntries RPC</code></h3><p>通过对日志的调试发现, <code>AppendEntries RPC</code>数量太多了, 这是因为我在<code>lab3A</code>中做了如下修改:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Start(command <span class="keyword">interface</span>&#123;&#125;) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.ResetHeartTimer(<span class="number">1</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rf.VirtualLogIdx(<span class="built_in">len</span>(rf.log) - <span class="number">1</span>), rf.currentTerm, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是在接受一个请求并追加一个<code>log</code>后立即发送<code>AppendEntries RPC</code>, 但是如果在高并发的场景下, 新的请求绵绵不断地到来, 每到达一个请求都发一个<code>RPC</code>, 并且每个<code>RPC</code>可能只包含了长度为1的日志切片, 这是不太合理的设计, 过多的<code>RPC</code>使得<code>raft</code>无法及时处理而出现<code>RPC</code>卡死的情况, 因此, 我手动修改了重置定时器的时间为<code>15ms</code>, 这个值比心跳间隔小很多, 但又不是很小, 足以在满足响应速度的前提下摊销多个命令, 使一次<code>AppendEntries RPC</code>包含多个新的日志项:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Start(command <span class="keyword">interface</span>&#123;&#125;) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.ResetHeartTimer(<span class="number">15</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rf.VirtualLogIdx(<span class="built_in">len</span>(rf.log) - <span class="number">1</span>), rf.currentTerm, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么是<code>15ms</code>…, 我自己也说不出理由, 随便设的, 比心跳小很多, 但又不太小就是了, <strong>本质目的就是积攒多个<code>AppendEntries RPC</code>后一次性发送, 避免<code>AppendEntries RPC</code>数量过大</strong></p><h3 id="3-1-2-修复过多的InstallSnapshot-RPC"><a href="#3-1-2-修复过多的InstallSnapshot-RPC" class="headerlink" title="3.1.2 修复过多的InstallSnapshot RPC"></a>3.1.2 修复过多的<code>InstallSnapshot RPC</code></h3><p>在我原来的设计中, <code>InstallSnapshot RPC</code>的发送有2中情形:</p><ol><li><code>handleAppendEntries</code>在处理<code>AppendEntries RPC</code>回复时发现<code>follower</code>需要的日志项背快照截断, 立即调用<code>go rf.handleInstallSnapshot(serverTo)</code>协程发送快照</li><li>心跳函数发送时发现<code>PrevLogIndex &lt; rf.lastIncludedIndex</code>, 则发送快照</li></ol><p>这和之前的情形类似, 在高并发的场景下，<code>follower</code>和<code>Leader</code>之间的日志复制也很频繁, 如果某一个日志触发了<code>InstallSnapshot RPC</code>的发送, 接下来连续很多个日志也会触发<code>InstallSnapshot RPC</code>的发送, 因为<code>InstallSnapshot RPC</code>的发送时间消耗更大, 这样以来, 又加大了<code>raft</code>的压力, 所以, 我对<code>InstallSnapshot RPC</code>的发送做出修改:</p><ol><li><code>handleAppendEntries</code>在处理<code>AppendEntries RPC</code>回复时发现<code>follower</code>需要的日志项背快照截断, 仅仅设置<code>rf.nextIndex[serverTo] = rf.lastIncludedIndex</code>, 这将导致下一次心跳时调用<code>go rf.handleInstallSnapshot(serverTo)</code>协程发送快照</li><li>心跳函数发送时发现<code>PrevLogIndex &lt; rf.lastIncludedIndex</code>, 则发送快照</li></ol><p>代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> handleAppendEntries(serverTo <span class="type">int</span>, args *AppendEntriesArgs) &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> reply.Term == rf.currentTerm &amp;&amp; rf.role == Leader &#123;</span><br><span class="line"><span class="comment">// term仍然相同, 且自己还是leader, 表名对应的follower在prevLogIndex位置没有与prevLogTerm匹配的项</span></span><br><span class="line"><span class="comment">// 快速回退的处理</span></span><br><span class="line"><span class="keyword">if</span> reply.XTerm == <span class="number">-1</span> &#123;</span><br><span class="line"><span class="comment">// PrevLogIndex这个位置在Follower中不存在</span></span><br><span class="line">DPrintf(<span class="string">&quot;leader %v 收到 server %v 的回退请求, 原因是log过短, 回退前的nextIndex[%v]=%v, 回退后的nextIndex[%v]=%v\n&quot;</span>, rf.me, serverTo, serverTo, rf.nextIndex[serverTo], serverTo, reply.XLen)</span><br><span class="line"><span class="keyword">if</span> rf.lastIncludedIndex &gt;= reply.XLen &#123;</span><br><span class="line"><span class="comment">// 由于snapshot被截断</span></span><br><span class="line"><span class="comment">// 下一次心跳添加InstallSnapshot的处理</span></span><br><span class="line">rf.nextIndex[serverTo] = rf.lastIncludedIndex</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rf.nextIndex[serverTo] = reply.XLen</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> i == rf.lastIncludedIndex &amp;&amp; rf.log[rf.RealLogIdx(i)].Term &gt; reply.XTerm &#123;</span><br><span class="line"><span class="comment">// 要找的位置已经由于snapshot被截断</span></span><br><span class="line"><span class="comment">// 下一次心跳添加InstallSnapshot的处理</span></span><br><span class="line">rf.nextIndex[serverTo] = rf.lastIncludedIndex</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> rf.log[rf.RealLogIdx(i)].Term == reply.XTerm &#123;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 之前PrevLogIndex发生冲突位置时, Follower的Term自己没有</span></span><br><span class="line"><span class="keyword">if</span> reply.XIndex &lt;= rf.lastIncludedIndex &#123;</span><br><span class="line"><span class="comment">// XIndex位置也被截断了</span></span><br><span class="line"><span class="comment">// 添加InstallSnapshot的处理</span></span><br><span class="line">rf.nextIndex[serverTo] = rf.lastIncludedIndex</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rf.nextIndex[serverTo] = reply.XIndex</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-server层优化"><a href="#3-2-server层优化" class="headerlink" title="3.2 server层优化"></a>3.2 <code>server</code>层优化</h2><p><code>server</code>层应该尽量减小对<code>raft</code>层的接口的调用, 因为大量的接口调用将获取<code>raft</code>层的一把大锁, 从而阻碍<code>RPC</code>的响应</p><h3 id="3-2-1-调用Start前过滤"><a href="#3-2-1-调用Start前过滤" class="headerlink" title="3.2.1 调用Start前过滤"></a>3.2.1 调用<code>Start</code>前过滤</h3><p>之前的实现中, 无论是<code>Put/Append</code>还是<code>Get</code>, 都是封装成<code>OP</code>结构体, 在<code>HandleOp</code>中一股脑调用<code>Start</code>扔给<code>raft</code>层处理, 然后在<code>ApplyHandler</code>处进行去重判断, 现在可以在调用<code>raft</code>层的<code>Start</code>之前就从<code>historyMap</code>中判断是否有历史记录可以直接返回:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> HandleOp(opArgs *Op) (res Result) &#123;</span><br><span class="line"><span class="comment">// 先判断是否有历史记录</span></span><br><span class="line">kv.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> hisMap, exist := kv.historyMap[opArgs.Identifier]; exist &amp;&amp; hisMap.LastSeq == opArgs.Seq &#123;</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line">ServerLog(<span class="string">&quot;leader %v HandleOp: identifier %v Seq %v 的请求: %s(%v, %v) 从历史记录返回\n&quot;</span>, kv.me, opArgs.Identifier, opArgs.OpType, opArgs.Key, opArgs.Val)</span><br><span class="line"><span class="keyword">return</span> *hisMap</span><br><span class="line">&#125;</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-减少GetState的调用"><a href="#3-2-2-减少GetState的调用" class="headerlink" title="3.2.2 减少GetState的调用"></a>3.2.2 减少<code>GetState</code>的调用</h3><p><code>ratf</code>的<code>GetState</code>也会获取锁, 从而阻碍<code>RPC</code>的响应速度, 我原来的实现中, <code>GetState</code>会在2个地方调用:</p><ol><li><code>Get</code>和<code>PutAppend</code>调用<code>GetState</code>判断是否是<code>leader</code>, 不是则返回错误</li><li><code>ApplyHandler</code>在通过通道唤醒<code>HandleOp</code>时, 需要判断当前节点是不是<code>leader</code>, 不是<code>leader</code>则不需要唤醒</li></ol><p>以上2不操作看似合理, 但实际上是冗余的:</p><ol><li>首先, <code>Get</code>和<code>PutAppend</code>在后续的<code>HandleOp</code>会调用<code>Start</code>, <code>Start</code>也会因为当前节点不是<code>leader</code>而返回, 所以<code>GetState</code>是冗余的, 反而阻碍<code>RPC</code>响应速度</li><li>其次, <code>ApplyHandler</code>在通过通道唤醒<code>HandleOp</code>时, 日志项本身有<code>term</code>的记录, <code>HandleOp</code>会调用<code>Start</code>时也会获取那时的<code>term</code>, <code>HandleOp</code>只需要在被唤醒后比较前后的<code>term</code>是否相同, 就可以判断出当前的节点是不是一个过时的<code>leader</code></li></ol><p>以上2处修改很简单, 由于是删代码而不是新增和修改, 就不贴代码了, 感兴趣可以看仓库</p><h3 id="3-2-3-clerk先sleep再重试"><a href="#3-2-3-clerk先sleep再重试" class="headerlink" title="3.2.3 clerk先sleep再重试"></a>3.2.3 <code>clerk</code>先<code>sleep</code>再重试</h3><p>这个修改也很简单, 如果<code>server</code>返回了需要重试类型的错误, <code>clerk</code>先<code>sleep</code>一会, 再重试, 代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Get(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">args := &amp;GetArgs&#123;Key: key, Seq: ck.GetSeq(), Identifier: ck.identifier&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">reply := &amp;GetReply&#123;&#125;</span><br><span class="line">ok := ck.servers[ck.leaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, args, reply)</span><br><span class="line"><span class="keyword">if</span> !ok || reply.Err == ErrNotLeader || reply.Err == ErrLeaderOutDated &#123;</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">reply.Err = ERRRPCFailed</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> reply.Err != ErrNotLeader &#123;</span><br><span class="line">DPrintf(<span class="string">&quot;clerk %v Seq %v 重试Get(%v), Err=%s&quot;</span>, args.Identifier, args.Key, args.Key, reply.Err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ck.leaderId += <span class="number">1</span></span><br><span class="line">ck.leaderId %= <span class="built_in">len</span>(ck.servers)</span><br><span class="line">time.Sleep(RpcRetryInterval)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> reply.Err &#123;</span><br><span class="line"><span class="keyword">case</span> ErrChanClose:</span><br><span class="line">DPrintf(<span class="string">&quot;clerk %v Seq %v 重试Get(%v), Err=%s&quot;</span>, args.Identifier, args.Key, args.Key, reply.Err)</span><br><span class="line">time.Sleep(time.Microsecond * <span class="number">5</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> ErrHandleOpTimeOut:</span><br><span class="line">DPrintf(<span class="string">&quot;clerk %v Seq %v 重试Get(%v), Err=%s&quot;</span>, args.Identifier, args.Key, args.Key, reply.Err)</span><br><span class="line">time.Sleep(RpcRetryInterval)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> ErrKeyNotExist:</span><br><span class="line">DPrintf(<span class="string">&quot;clerk %v Seq %v 成功: Get(%v)=%v, Err=%s&quot;</span>, args.Identifier, args.Key, args.Key, reply.Value, reply.Err)</span><br><span class="line"><span class="keyword">return</span> reply.Value</span><br><span class="line">&#125;</span><br><span class="line">DPrintf(<span class="string">&quot;clerk %v Seq %v 成功: Get(%v)=%v, Err=%s&quot;</span>, args.Identifier, args.Key, args.Key, reply.Value, reply.Err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> reply.Value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> PutAppend(key <span class="type">string</span>, value <span class="type">string</span>, op <span class="type">string</span>) &#123;</span><br><span class="line"><span class="comment">// You will have to modify this function.</span></span><br><span class="line">args := &amp;PutAppendArgs&#123;Key: key, Value: value, Op: op, Seq: ck.GetSeq(), Identifier: ck.identifier&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">reply := &amp;PutAppendReply&#123;&#125;</span><br><span class="line">ok := ck.servers[ck.leaderId].Call(<span class="string">&quot;KVServer.PutAppend&quot;</span>, args, reply)</span><br><span class="line"><span class="keyword">if</span> !ok || reply.Err == ErrNotLeader || reply.Err == ErrLeaderOutDated &#123;</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">reply.Err = ERRRPCFailed</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> reply.Err != ErrNotLeader &#123;</span><br><span class="line">DPrintf(<span class="string">&quot;clerk %v Seq %v 重试%s(%v, %v), Err=%s&quot;</span>, args.Identifier, args.Key, args.Op, args.Key, args.Value, reply.Err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ck.leaderId += <span class="number">1</span></span><br><span class="line">ck.leaderId %= <span class="built_in">len</span>(ck.servers)</span><br><span class="line">time.Sleep(RpcRetryInterval)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> reply.Err &#123;</span><br><span class="line"><span class="keyword">case</span> ErrChanClose:</span><br><span class="line">DPrintf(<span class="string">&quot;clerk %v Seq %v 重试%s(%v, %v), Err=%s&quot;</span>, args.Identifier, args.Key, args.Op, args.Key, args.Value, reply.Err)</span><br><span class="line">time.Sleep(RpcRetryInterval)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> ErrHandleOpTimeOut:</span><br><span class="line">DPrintf(<span class="string">&quot;clerk %v Seq %v 重试%s(%v, %v), Err=%s&quot;</span>, args.Identifier, args.Key, args.Op, args.Key, args.Value, reply.Err)</span><br><span class="line">time.Sleep(RpcRetryInterval)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">DPrintf(<span class="string">&quot;clerk %v Seq %v 成功: %s(%v, %v), Err=%s&quot;</span>, args.Identifier, args.Key, args.Op, args.Key, args.Value, reply.Err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h1><ol><li>执行测试命令测试<code>lab3B</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -run 3B</span><br></pre></td></tr></table></figure>结果如下:<br><img src="/../../images/MIT6.5840/lab3B/lab3-3B-test.png" alt="Alt text"><br>可以看出, 取消立即发送心跳广播导致前3个测例满了不少, 但也就凑活吧(<del>不想优化了, 麻木了</del>)</li></ol><p>该代码经过150次测试没有报错</p><ol><li><p>执行测试命令测试整个<code>lab3</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -run 3</span><br></pre></td></tr></table></figure><p>结果如下:<br><img src="/../../images/MIT6.5840/lab3B/lab3-3-test.png" alt="Alt text"><br>该代码经过150次测试没有报错</p></li><li><p>修改后再次测试<code>lab2</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../raft/</span><br><span class="line">go <span class="built_in">test</span> -run 2</span><br></pre></td></tr></table></figure><p>结果如下:<br><img src="/../../images/MIT6.5840/lab3B/lab3-2-test.png" alt="Alt text"></p></li></ol><p>该代码经过150次测试没有报错</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;最新的更新在博客 &lt;a href=&quot;https://tonixwd.github.io/&quot;&gt;ToniBlog&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;本文将介绍&lt;code&gt;lab3B&lt;/code&gt;部分的实现, &lt;code&gt;lab3B&lt;/code&gt;要求基于在&lt;code&gt;lab</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="Lab笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/Lab%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Go" scheme="http://example.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>红黑树1: 插入、删除原理详解与代码实现</title>
    <link href="http://example.com/2024/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://example.com/2024/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2024-02-02T02:01:07.000Z</published>
    <updated>2024-10-03T17:47:36.143Z</updated>
    
    <content type="html"><![CDATA[<p>本文将从原理介绍红黑树的实现思路，尽量做到图文并茂</p><p>具体的<code>cpp</code>代码实现在<a href="https://github.com/ToniXWD/cppDataStructure/blob/main/include/rbTree.hpp">这里</a>, 就不在文章里代码了, 自己写的实在太丑</p><h1 id="0-引入-为什么需要红黑树"><a href="#0-引入-为什么需要红黑树" class="headerlink" title="0 引入: 为什么需要红黑树?"></a>0 引入: 为什么需要红黑树?</h1><p>通常, 基本的数据结构课程和<code>Leetcode</code>中主要关注的是普通二叉树或者完全二叉树。我们知道其各自存在一些优缺点:</p><ul><li>普通二叉树<code>BST</code><ul><li>优点: 实现简单</li><li>缺点: 如果插入的节点恰好是有序的，那么<code>BST</code>将会退化成一个链表，导致搜索、插入和删除的操作的时间复杂度都下降到<code>O(n)</code></li></ul></li><li>均衡二叉树<code>AVL</code><ul><li>优点: 查询时时间复杂度一定是<code>O(log n)</code>, 不能存在退化成一个链表的情况</li><li>缺点: 维护均衡二叉树消耗很大</li></ul></li></ul><p>为了解决普通<code>BST</code>在最坏情况下性能下降的问题，需要一种能够保持树平衡的数据结构，红黑树就是这样一种结构。红黑树通过节点着色和在插入或删除后进行特定的旋转操作，来保证树基本平衡。这种自平衡机制保证了在最坏情况下，树的高度保持在<code>O(log n)</code>，使得搜索、插入和删除操作的时间复杂度也都是<code>O(log n)</code>。</p><p>红黑树的自平衡特性使得它在实现许多数据结构（如关联数组、映射和集合）时非常有用，这些数据结构在<code>STL</code>（标准模板库）中被广泛使用。它为那些需要高效搜索、插入和删除操作的场景提供了一种可靠的解决方案，无论数据是如何插入的。</p><h1 id="1-红黑树的性质"><a href="#1-红黑树的性质" class="headerlink" title="1 红黑树的性质"></a>1 红黑树的性质</h1><p>红黑树是一种自平衡的二叉搜索树，它保持树的平衡通过确保任何从根到叶子的最长路径不会超过最短路径的两倍。为了实现这一点，红黑树维护以下性质：</p><ol><li><p><strong>节点颜色</strong>：每个节点要么是红色，要么是黑色。</p></li><li><p><strong>根节点性质</strong>：根节点总是黑色。</p></li><li><p><strong>叶子节点性质</strong>：所有叶子节点（NIL节点，通常表示为哨兵节点）都是黑色。</p></li><li><p><strong>红色节点性质</strong>：如果一个节点是红色的，那么它的两个子节点都是黑色的（也就是说，红色节点不能有红色的父节点或子节点，即不会有两个连续的红色节点）。</p></li><li><p><strong>黑色高度性质</strong>：从任何给定节点到其任何叶子节点的路径中，经过的黑色节点的数量是相同的（这个数量称为该节点的黑色高度）。</p></li></ol><p>这些性质确保了红黑树的关键优势：在最坏的情况下，树的高度保持在<code>O(log N)</code>，其中N是树中节点的数量。这意味着查找、插入和删除操作都可以在对数时间内完成，保持了高效性。红黑树通过旋转和重新着色来维持这些性质。当执行插入和删除等修改操作时，通过一系列的树旋转和重新着色来修复可能被破坏的红黑树性质，从而保持树结构的平衡。</p><h1 id="2-红黑树的查找"><a href="#2-红黑树的查找" class="headerlink" title="2 红黑树的查找"></a>2 红黑树的查找</h1><p>红黑树的查找和<code>BST</code>没有区别, 直接略过吧…</p><h1 id="3-红黑树的插入"><a href="#3-红黑树的插入" class="headerlink" title="3 红黑树的插入"></a>3 红黑树的插入</h1><h2 id="3-1-插入原理"><a href="#3-1-插入原理" class="headerlink" title="3.1 插入原理"></a>3.1 插入原理</h2><blockquote><p>草图说明:</p><ol><li>圆圈表示节点, 矩形表示子树</li><li>黑色和红色代表红黑树的颜色, 蓝色表示颜色未知</li><li>阴影表示操作节点</li><li>子树的颜色表示了子树的根节点的颜色</li><li>删除的时候, 初始操作节点的颜色是不确定的</li></ol></blockquote><p>插入过程:</p><ol><li><p><strong>插入新节点</strong>：</p><ul><li>将新节点插入到红黑树中，就像在普通的二叉搜索树中那样。新节点的颜色初始化为<strong>红色</strong>。</li></ul></li><li><p><strong>检查红黑树性质</strong>：</p><ol><li>如果新插入的节点是根节点，仅将其颜色改为黑色即可满足所有性质。</li><li>如果新节点的父节点是黑色，不违反红黑树的性质，不需要做任何额外的操作。</li><li>如果新节点的父节点是红色，就需要进行一些调整来修复树的性质，因为这违反了性质: 红色节点的子节点必须是黑色。</li></ol></li><li><p><strong>调整红黑树</strong>：<br> 如果新节点的父节点是红色的，有以下几种情况需要处理：</p><ol><li><p>叔叔节点为红色</p><ol><li>更改叔叔节点和父节点为黑色</li><li>将爷爷节点设为红色</li><li>以爷爷节点为目标继续判断是否需要调整<br>上述操作可参考下图, 将叔叔和父亲设为黑色是避免连续的红色节点, 将爷爷节点设为红色目的是确保<strong>黑色高度</strong>不变, 因为爷爷的父亲可能还是红色, 所以需要继续判断:<br><img src="/../../images/data_structures/rbTree_insert_uncle_red.png" alt="rbTree_insert_uncle_red"></li></ol></li><li><p>叔叔节点为黑色或者不存在</p><ol><li>如果新节点相对父节点的方向和父节点相对爷爷节点的<strong>方向不一致</strong>, 将操作的目标节点变为其父亲, 并进行左旋或右旋, 使者三代节点<strong>方向一致</strong>,</li><li>将操作节点(可能因为上一步的左旋或右旋, 操作节点发生了变化)的父节点设为黑色, 爷爷节点设为红色</li><li>右旋或左旋爷爷节点(父节点是爷爷节点的右孩子就左旋, 反之右旋), 修复完成, 不需要进一步判断<br>上述操作可参考下图, 目的其实就是化3层为2层, 从而避免原来2-3层连续的红节点, 需要注意的是, 如果是第一次检查修复, 叔叔节点一定是不存在的, 叔叔节点存在且为黑色只会出现在<code>叔叔节点为红色</code>这个条件下的递归修复过程中<br><img src="/../../images/data_structures/rbTree_insert_uncle_black.png" alt="rbTree_insert_uncle_black"></li></ol></li></ol><p> 递归向上进行修复，直到根节点，或满足红黑树性质, 注意,<strong>最后需要将根节点重置为黑色, 因为之前的调整可能改变了根节点的颜色</strong></p></li></ol><p><strong>名词解释：</strong></p><ul><li><strong>左旋</strong>：将父节点的右孩子设为新的父节点, 原来的父节点变为新的父节点的左孩子</li><li><strong>右旋</strong>：与左旋相反，将父节点的左孩子设为新的父节点, 原来的父节点变为新的父节点的右孩子</li><li><strong>方向不一致</strong>: 新节点是父节点的右孩子而父节点是祖父节点的左孩子，或者新节点是父节点的左孩子而父节点是祖父节点的右孩子</li></ul><h2 id="3-2-插入案例"><a href="#3-2-插入案例" class="headerlink" title="3.2 插入案例"></a>3.2 插入案例</h2><p>上面的流程看起来很抽象, 因此我们结合实际的案例来说明, 我使用了<a href="../../images/data_structures/https://algo.hufeifei.cn/RedBlack.html">这个网站</a>演示红黑树插入的逻辑:<br><strong>1. 首先创建一个空的红黑树:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RedBlackTree&lt;<span class="type">int</span>&gt; tree; <span class="comment">// 伪代码</span></span><br></pre></td></tr></table></figure><p><strong>2. 再插入10</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree.<span class="built_in">insert</span>(<span class="number">10</span>); <span class="comment">// 伪代码</span></span><br></pre></td></tr></table></figure><p><img src="/../../images/data_structures/insert_10.png" alt="insert_10"><br>新的节点是根节点, 置为黑色</p><p><strong>3. 再插入5</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree.<span class="built_in">insert</span>(<span class="number">10</span>); <span class="comment">// 伪代码</span></span><br></pre></td></tr></table></figure><p><img src="/../../images/data_structures/insert_5.png" alt="insert_5"><br>插入后没有改变红黑树性质, 无需调整</p><p><strong>4. 再插入50</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree.<span class="built_in">insert</span>(<span class="number">50</span>); <span class="comment">// 伪代码</span></span><br></pre></td></tr></table></figure><p><img src="/../../images/data_structures/insert_50.png" alt="insert_50"><br>插入后没有改变红黑树性质, 无需调整</p><p><strong>5. 再插入30</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree.<span class="built_in">insert</span>(<span class="number">30</span>); <span class="comment">// 伪代码</span></span><br></pre></td></tr></table></figure><p><img src="/../../images/data_structures/insert_30_1.png" alt="insert_30_1"><br>插入后30的父节点50是连续的红节点, 需要调整</p><p><img src="/../../images/data_structures/insert_30_2.png" alt="insert_30_2"><br>叔叔节是红色, 将叔叔和父亲置为黑色, 爷爷节点设为红色</p><p><img src="/../../images/data_structures/insert_30_3.png" alt="insert_30_3"><br>从爷爷节点继续判断, 爷爷节点是根节点, 重新置为黑色</p><blockquote><p>小结: 为什么<code>父亲和叔叔节点都是红色</code>下的这种策略能有效地修复红黑树?<br>因为将父亲和叔叔变黑就已经修复了<strong>红色节点性质</strong>, 但增加了黑色节点高度怎么办呢? 再把爷爷节点变红就修复了<strong>黑色高度性质</strong>, 但需要从爷爷节点还是继续判断是否需要修复</p></blockquote><p><strong>6. 再插入36</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree.<span class="built_in">insert</span>(<span class="number">36</span>); <span class="comment">// 伪代码</span></span><br></pre></td></tr></table></figure><p><img src="/../../images/data_structures/insert_30_6.png" alt="insert_30_6"><br>插入后36的父节点30是连续的红节点, 需要调整</p><p><img src="/../../images/data_structures/insert_30_6_2.png" alt="insert_30_6_2"><br>50, 30和36方向不一致, 左旋父节点30使其方向和50与36的方向一致: 向左, 左旋后, 将30置为操作节点</p><p><img src="/../../images/data_structures/insert_30_6_3.png" alt="insert_30_6_3"><br>将操作节点30的父节点36设为黑色, 爷爷几点50设为红色, 右旋爷爷节点50</p><blockquote><p>小结: </p><ol><li>为什么<code>叔叔节点为黑色或者不存在</code>这个情况下旋转爷爷节点有效?<br>实际上就是将原来以爷爷节点为起点的3个分布在3层的节点压缩层了2层, 原来第二层和第三层连续的2个红色节点调整后就不连续了, 因为其中一个更大的一个节点变到了原来的爷爷节点的位置并变黑了, 原来的爷爷节点变成了儿子并且变成了红色, 所以满足了<strong>黑色高度性质</strong>的性质和<strong>红色节点性质</strong></li><li>为什么需要判断<strong>方向一致</strong>?<br>方便后续统一操作而已</li></ol></blockquote><p><strong>7. 再插入4</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree.<span class="built_in">insert</span>(<span class="number">4</span>); <span class="comment">// 伪代码</span></span><br></pre></td></tr></table></figure><p><img src="/../../images/data_structures/insert_4.png" alt="insert_4"><br>插入后4后不需要调整(主要是为了后续删除的演示)</p><h1 id="4-红黑树的删除"><a href="#4-红黑树的删除" class="headerlink" title="4 红黑树的删除"></a>4 红黑树的删除</h1><p>红黑树的删除比插入复杂很多, 整体分3步:</p><ol><li>找到删除节点</li><li>找到一个替换节点接替删除节点的位置</li><li>修复红黑树高度</li></ol><p>这里分删除和修复2部分说明</p><h2 id="4-1-修复前的替换"><a href="#4-1-修复前的替换" class="headerlink" title="4.1 修复前的替换"></a>4.1 修复前的替换</h2><p><strong>1. 查找要删除的节点</strong><br>就像在普通的二叉搜索树中那样, 查找要删除的节点。</p><p><strong>2. 替换节点</strong><br>红黑树需要用于一个节点来替换要删除的节点, 具体分情况如下:</p><ol><li><p><strong>删除节点有两个非空子节点</strong><br>   在这种情况下，通常会找到该节点的后继或前驱（中序遍历下的下一个节点或上一个节点），这将是该节点右子树中的最小值(或左子树的最大值)。然后，将后继或前驱的值复制到要删除的节点中，并删除后继或前驱节点。因为后继节点(或前驱节点)至多只有一个非空子节点，所以这步骤将问题简化为删除有一个或没有子节点的节点。<strong>本文采取使用前驱替代的策略</strong></p></li><li><p><strong>删除节点最多有一个非空子节点：</strong><br>   任意找到一个空子节点, 然后将另一个子节点(可能也是空的, 也可能是非空), 替代当前节点,</p></li></ol><p>删除红色节点不需要判断修复, 但删除黑色节点后, 需要从一个节点开始判断红黑树是否需要修复, 具体有以下情况:</p><ol><li><strong>删除节点有两个非空子节点</strong><br>由于前驱节点是实际被删除的黑色节点, 因此从它开始就违反了<strong>黑色高度性质</strong>, 具体分类如下:<ol><li>如果前驱节点有孩子, 孩子将替代前驱节点原来的位置, 这个位置就是修复判断的起始位置</li><li>如果前驱节点没有孩子, 那么也就是替代者是空指针, 虽然这个节点也是判断的其实位置, 但从这个节点开始不能进行修复判断, 因为空指针无法索引到它的父节点, 因此, 额外用一个<strong>哨兵节点Nil</strong>来代替这个空指针, 哨兵节点除了包含原来前驱的父节点指针外, 本身不算是红黑树的有效成员, 只是在删除修复时临时使用, <strong>哨兵节点Nil</strong>就是修复判断的起始位置</li></ol></li><li><strong>删除节点最多有一个非空子节点：</strong><br>任意找到一个空子节点, 然后将另一个子节点(可能也是空的, 也可能是非空), 替代当前节点, 当前节点被替代的位置就是判断的其实位置, 当然这个位置现在也可能是空的, 所以这种情况也需要使用<strong>哨兵节点Nil</strong>来处理</li></ol><p><strong>替换完成后, 还需要将替换的节点的颜色置为原来删除位置节点的颜色</strong></p><h2 id="4-2-修复红黑树"><a href="#4-2-修复红黑树" class="headerlink" title="4.2 修复红黑树"></a>4.2 修复红黑树</h2><p>删除节点后，可能会违反红黑树的性质。如果删除的是红色节点，通常不需要进一步的修复，因为红色节点的删除不会影响黑色节点的平衡。但如果删除的是黑色节点，就可能需要通过一系列复杂的树的旋转和重新着色来进行修复。</p><p>修复过程是从某个节点开始进行判断的, 这个判断的节点的含义是: 这个节点开始的子树的<strong>黑色高度</strong>比删除前减小了1</p><p>修复的目标是重新分配树中的黑色高度, 修复过程遵循以下原则：</p><ol><li><strong>兄弟节点是红色：</strong> <ol><li>兄弟节点是红色意味着父节点一定是黑色, 先交换父节点和兄弟节点的颜色。</li><li>将父节点进行旋转, 方向朝着修复判断的操作节点</li><li>旋转后操作节点的新兄弟节点就是黑色了, 可以继续下面的判断修复<br>这一过程可参考下图, 需要注意的是, 这个过程仅仅是将兄弟节点变黑, 并没有完成修复, 需要后续进一步操作<br><img src="/../../images/data_structures/rbTree_delete_change_sibling_to_black.png" alt="rbTree_delete_change_sibling_to_black"></li></ol></li><li><strong>兄弟节点是黑色，其子节点也都是黑色：</strong> <ol><li><p>将兄弟节点设为红色, 此时兄弟节点开始的子树和操作节点开始的子树的<strong>黑色高度</strong>已经一样了</p></li><li><p>由于上述原因, 可以将操作节点向上移动到父节点, 继续判断修复:</p><ol><li>如果父节点是红色, 将其置为黑色, 修复完成</li><li>否则, 从父节点开始继续判断</li></ol><p>这一过程可参考下图, 此时操作节点变成了原来的父节点, 继续判断:</p></li></ol><p><img src="/../../images/data_structures/rbTree_delete.set_sibling_red.png" alt="rbTree_delete.set_sibling_red"></p></li><li><strong>兄弟节点是黑色，且至少有一个红色子节点：</strong> <ol><li><p>无论兄弟节点的红色节点是哪一侧, 都可以通过旋转操作统一到某一侧一定有红色节点, 这里将红色节点位置统一为操作节点的相反侧(如果操作节点是左节点, 就把兄弟节点的红色节点放在右孩子), 如果需要调整兄弟节点的子节点的位置的话</p><ol><li>将兄弟节点和兄弟节点的红色孩子交换颜色</li><li>将兄弟节点向与操作节点向反的方向旋转<br>这一过程可参考下图<br><img src="/../../images/data_structures/./rbTree_delete_change_red.png" alt="delete_change_red"></li></ol></li><li><p>将兄弟节点(可能因旋转发生了变化)设置为操作节点的父节点的颜色，将操作节点的父节点设置为黑色，将兄弟节点的与操作节点相反方向的孩子(之前的操作确保其为红)设置为黑色<br>这一过程可参考下图<br><img src="/../../images/data_structures/rbTree_delete_exchange_parent_sibling_blacking_red_child_of_sibling.png" alt="rbTree_delete_exchange_parent_sibling_blacking_red_child_of_sibling"></p></li><li><p>将操作节点的父节点向操作节点方向旋转<br>这一过程可参考下图, 此时操作节点的路径上多了一个黑色节点, 其<strong>黑色高度</strong>被修复, 而操作节点的兄弟节点由于红色节点被置为黑色, 补充了被转移到原来操作节点一侧的黑节点, 因此高度也不变化, 此时, 完成了修复, 可以退出循环<br><img src="/../../images/data_structures/rbTree_delete_rotate_after_exchange_parent_sibling_blacking_red_child_of_sibling.png" alt="rbTree_delete_rotate_after_exchange_parent_sibling_blacking_red_child_of_sibling"></p></li></ol></li></ol><p>删除修复可能会在树上向上递归，直到到达根节点，或者遇到可以修复树平衡的情况。</p><p>同时, 修复完成后还需要重新将<strong>哨兵节点</strong>卸载掉</p><blockquote><p>有一个很重要的特性值得观察: 就是初始状态的修复判断的操作节点的颜色是未知的, 但通过以上的修复逻辑, 最终效果一定会将初始的操作节点安排一个黑色父节点从而避免连续的红色节点</p></blockquote><h2 id="4-3-删除案例"><a href="#4-3-删除案例" class="headerlink" title="4.3 删除案例"></a>4.3 删除案例</h2><p>使用我们之前插入案例最后状态的红黑树:<br><img src="/../../images/data_structures/insert_4.png" alt="insert_4"><br><strong>1. 删除36</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree.<span class="built_in">remove</span>(<span class="number">36</span>); <span class="comment">// 伪代码</span></span><br></pre></td></tr></table></figure><p><img src="/../../images/data_structures/remove_36.png" alt="remove_36"><br>删除的36左右孩子都不为空, 所以找到其前驱30, 用30替代36, 并且替代的节点需要设置成和原来位置节点相同的颜色</p><p>替换的30节点是红色, 无需修复 </p><p><strong>2. 删除30</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree.<span class="built_in">remove</span>(<span class="number">30</span>); <span class="comment">// 伪代码</span></span><br></pre></td></tr></table></figure><p><img src="/../../images/data_structures/remove_30_1.png" alt="remove_30_1"></p><p>删除的30节点用50节点来代替, 并将50节点设置为黑色<br>替换的50节点是红色, 不需要修复</p><p><strong>3. 删除10</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree.<span class="built_in">remove</span>(<span class="number">10</span>); <span class="comment">// 伪代码</span></span><br></pre></td></tr></table></figure><p><img src="/../../images/data_structures/remove_10_1.png" alt="remove_10_1"><br>删除的10的左右孩子不为空, 用前驱5替代10, 并将10节点设置为黑色<br>替换的5节点是黑色, 需要修复</p><p><img src="/../../images/data_structures/remove_10_2.png" alt="remove_10_2"><br>兄弟节点是黑色, 且孩子都是黑色(空节点也是黑色), 所以将兄弟节点染红, 操作节点置为其父节点</p><blockquote><p>在线可视化的网页是将其4染成黑色, 都可以, 我按照我总结的思路将50染红, 所以P了下图</p></blockquote><p>操作节点此时是根节点, 再次置为黑色, 结束修复</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将从原理介绍红黑树的实现思路，尽量做到图文并茂&lt;/p&gt;
&lt;p&gt;具体的&lt;code&gt;cpp&lt;/code&gt;代码实现在&lt;a href=&quot;https://github.com/ToniXWD/cppDataStructure/blob/main/include/rbTree.hp</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="红黑树" scheme="http://example.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.5840(6.824) Lab3: 分布式KV数据库 3A</title>
    <link href="http://example.com/2024/01/30/MIT6.5840/Lab3A/"/>
    <id>http://example.com/2024/01/30/MIT6.5840/Lab3A/</id>
    <published>2024-01-30T12:21:22.000Z</published>
    <updated>2024-10-03T17:47:36.140Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍<code>lab3A</code>部分的实现, <code>lab3A</code>要求基于<code>raft</code>实现一个容错的分布式<code>KV</code>数据库, 但不要求实现快照, 难度还是不小</p><p><code>Lab</code>文档见: <a href="http://nil.csail.mit.edu/6.5840/2023/labs/lab-kvraft.html">http://nil.csail.mit.edu/6.5840/2023/labs/lab-kvraft.html</a></p><p>我的代码: <a href="https://github.com/ToniXWD/MIT6.5840/tree/lab3A">https://github.com/ToniXWD/MIT6.5840/tree/lab3A</a></p><h1 id="1-lab2-Raft-bug-修复"><a href="#1-lab2-Raft-bug-修复" class="headerlink" title="1 lab2:Raft bug 修复"></a>1 <code>lab2:Raft bug </code>修复</h1><p>首先又是万恶的老旧代码<code>bug</code>修复</p><h2 id="1-1-心跳发送逻辑修复"><a href="#1-1-心跳发送逻辑修复" class="headerlink" title="1.1 心跳发送逻辑修复"></a>1.1 心跳发送逻辑修复</h2><h3 id="1-1-1-bug描述"><a href="#1-1-1-bug描述" class="headerlink" title="1.1.1 bug描述"></a>1.1.1 <code>bug</code>描述</h3><p>在<code>lab3A</code>中, <code>kv</code>数据库的命令要求命令能够尽快被<code>commit</code>, 且要求比一个心跳间隔更快, 但我在<code>lab2</code>的实现中, 无论是否调用了<code>Start</code>, 都不影响心跳的发送频率, 因此自然<code>commit</code>速度很慢, 过不了测试。因此需要修改<code>lab2</code>中<code>Start</code>, 使其立即唤醒一次心跳</p><h3 id="1-1-2-修改方案"><a href="#1-1-2-修改方案" class="headerlink" title="1.1.2 修改方案"></a>1.1.2 修改方案</h3><p>由于需要在发送心跳的携程函数<code>SendHeartBeats</code>外控制心跳发送, 因此可以简单地修改<code>SendHeartBeats</code>通过事件触发心跳发送, 而不是发送后简单地<code>Sleep</code>,</p><ol><li>首先设置一个心跳定时器<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    heartTimer *time.Timer</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>SendHeartBeats</code>通过事件触发心跳发送<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> SendHeartBeats() &#123;</span><br><span class="line"><span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">&lt;-rf.heartTimer.C</span><br><span class="line">...</span><br><span class="line">rf.ResetHeartTimer(HeartBeatTimeOut)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> ResetHeartTimer(timeStamp <span class="type">int</span>) &#123;</span><br><span class="line">rf.heartTimer.Reset(time.Duration(timeStamp) * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>Start</code>函数理解触发心跳<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Start(command <span class="keyword">interface</span>&#123;&#125;) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.ResetHeartTimer(<span class="number">1</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rf.VirtualLogIdx(<span class="built_in">len</span>(rf.log) - <span class="number">1</span>), rf.currentTerm, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>其余重设定时器的地方就不在赘述了</li></ol><h2 id="1-2-投票逻辑修复"><a href="#1-2-投票逻辑修复" class="headerlink" title="1.2 投票逻辑修复"></a>1.2 投票逻辑修复</h2><h3 id="1-2-1-bug描述"><a href="#1-2-1-bug描述" class="headerlink" title="1.2.1 bug描述"></a>1.2.1 <code>bug</code>描述</h3><p>简单说就是某节点2轮选举撞在了一起, 首先先回顾选举相关的结构体成员:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">muVote    sync.Mutex <span class="comment">// 保护投票数据</span></span><br><span class="line">voteCount <span class="type">int</span>        <span class="comment">// 票数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>bug</code>原来本来是没有的, 因为之前<code>Start</code>并不会立即发送心跳，所以不容易出现如<code>RPC</code>重复, <code>RPC</code>乱序等问题, 但修改了<code>Start</code>后, 并发场景更复杂, 因此出现了如下的场景:</p><ol><li>某一时刻<code>Follower 2</code>进行选举</li><li><code>Follower 2</code>选举还没结束时, 又收到了新的<code>Leader</code>的心跳, 证明选举结束了, 但由于选举的某个携程的<code>RPC</code>响应很慢, 其还没有进行选举是否结束(自身变为了<code>Follower</code>)的判断</li><li>选举超时又被触发, <code>Follower 2</code>进行新一轮选举, 由于票数是以结构体成员<code>voteCount</code>保存的, 因此<code>voteCount</code>可能与之前的选票发生冲突</li></ol><h3 id="1-2-2-修改方案"><a href="#1-2-2-修改方案" class="headerlink" title="1.2.2 修改方案"></a>1.2.2 修改方案</h3><p>既然结构体成员会发生冲突, 那不如为每轮选票临时创建一个成员和投票锁:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Elect() &#123;</span><br><span class="line"><span class="comment">// 特别注意, 要先对muVote加锁, 再对mu加锁, 这是为了统一获取锁的顺序以避免死锁</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">voteCount := <span class="number">1</span>      <span class="comment">// 自己有一票</span></span><br><span class="line"><span class="keyword">var</span> muVote sync.Mutex <span class="comment">// 临时的投票锁</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == rf.me &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> rf.collectVote(i, args, &amp;muVote, &amp;voteCount)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>collectVote</code>函数就不展示了, 将原来的结构体成员<code>muVote</code>和<code>voteCount</code>换为临时创建的变量即可</p><h1 id="2-KV数据库架构"><a href="#2-KV数据库架构" class="headerlink" title="2 KV数据库架构"></a>2 KV数据库架构</h1><p>首先先贴出官方提供的架构图:</p><p><img src="/../../images/raft_diagram.png" alt="raftkv-structure1"></p><p>简单说, 我们要建立的<code>KV</code>数据库是位于<code>raft</code>层之上的, 或者说我们的<code>KV</code>数据库使用了<code>raft</code>库。客户端（就是代码中的<code>clerk</code>）调用应用层(<code>server</code>)的<code>RPC</code>，应用层收到<code>RPC</code>之后，会调用<code>Start</code>函数，<code>Start</code>函数会立即返回，但是这时，应用层不会返回消息给客户端，因为它还没有执行客户端请求，它也不知道这个请求是否会被<code>Raft</code>层<code>commit</code>。只有在某一时刻，对应于这个客户端请求的消息在<code>applyCh channel</code>中出现, 应用层才会执行这个请求，并返回响应给客户端。</p><p>对于上述过程, 可参考我在课堂笔记中画的图:</p><p><img src="/../../images/Lec06-raft-kv.png" alt="raftkv-structure2"></p><h1 id="3-设计思路"><a href="#3-设计思路" class="headerlink" title="3 设计思路"></a>3 设计思路</h1><h2 id="3-1-为什么会线性不一致"><a href="#3-1-为什么会线性不一致" class="headerlink" title="3.1 为什么会线性不一致?"></a>3.1 为什么会线性不一致?</h2><p><code>clerk</code>和真正的客户端交互并管理<code>RPC</code>, 而<code>server</code>收到请求后需要将请求传递给<code>raft</code>层进行集群复制, 然后收到<code>raft</code>的<code>commit</code>, 在应用到状态机并返回给客户端。</p><p>但问题在于需要确保以上操作的线性一致性， 那什么时候会出现线形不一致的情况呢？就是重复的请求。因为网络问题，<code>clerk</code>可能认为之前的请求丢包了， 所以会再次发送请求。而<code>raft</code>层是无法判断这个请求是否重复的, 如果<code>server</code>层没有特殊处理, 有的请可能在客户端看来只执行了一次, 但在<code>server</code>执行了多次, 并且如果这是<code>Put</code>等改变状态机的请求, 执行了多次将导致逻辑错误。</p><h2 id="3-2-实现线性一致性的思路"><a href="#3-2-实现线性一致性的思路" class="headerlink" title="3.2 实现线性一致性的思路"></a>3.2 实现线性一致性的思路</h2><h3 id="3-2-1-如何判断重复请求？"><a href="#3-2-1-如何判断重复请求？" class="headerlink" title="3.2.1 如何判断重复请求？"></a>3.2.1 如何判断重复请求？</h3><p>首先，<code>server</code>需要判断某一个请求是否重复，最简单的方法就是让<code>clerk</code>携带一个全局递增的序列号，并且<code>server</code>需要在第一次将这个请求应用到状态机时记录这个序列号, 用以判断后续的请求是否重复。由于<code>clerk</code>不是并发的, 所以<code>server</code>只需要记录某个<code>clerk</code>序列号最高的一个请求即可, 序列号更低的请求不会出现, 只需要考虑请求重复的场景。</p><h3 id="3-2-2-如何处理重复请求？"><a href="#3-2-2-如何处理重复请求？" class="headerlink" title="3.2.2 如何处理重复请求？"></a>3.2.2 如何处理重复请求？</h3><p>除了记录某个<code>clerk</code>请求的序列号外， 还需要记录器执行结果，因为如果是一个重复的<code>Get</code>请求, 其返回的结果应该与其第一次发送请求时一致, 否则将导致线性不一致。如果是重复的<code>Put</code>等改变状态机的请求，就不应该被执行</p><p><strong>总结下来, 思路就是:</strong></p><ol><li>重复的<code>Put/Append</code>请求只在第一次出现时应用到状态机</li><li>记录每次应用到状态机的请求结果和序列号</li></ol><h1 id="4-具体实现"><a href="#4-具体实现" class="headerlink" title="4 具体实现"></a>4 具体实现</h1><h2 id="4-1-client实现"><a href="#4-1-client实现" class="headerlink" title="4.1 client实现"></a>4.1 <code>client</code>实现</h2><h3 id="4-1-1-结构体设计"><a href="#4-1-1-结构体设计" class="headerlink" title="4.1.1 结构体设计"></a>4.1.1 结构体设计</h3><p>先贴代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Clerk <span class="keyword">struct</span> &#123;</span><br><span class="line">servers    []*labrpc.ClientEnd</span><br><span class="line">seq        <span class="type">uint64</span></span><br><span class="line">identifier <span class="type">int64</span></span><br><span class="line">leaderId   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>identifier</code>用于标识<code>clerk</code>, <code>seq</code>是单调递增的序列号, 标记请求, <code>identifier</code>和<code>seq</code>一起标记了唯一的请求, <code>leaderId</code>记录领导者</p><h3 id="4-1-2-client-RPC设计"><a href="#4-1-2-client-RPC设计" class="headerlink" title="4.1.2 client RPC设计"></a>4.1.2 <code>client RPC</code>设计</h3><h4 id="4-1-2-1-RPC结构体设计"><a href="#4-1-2-1-RPC结构体设计" class="headerlink" title="4.1.2.1 RPC结构体设计"></a>4.1.2.1 <code>RPC</code>结构体设计</h4><p><code>RPC</code>请求只需要额外携带<code>identifier</code>和<code>seq</code>, <code>RPC</code>回复则需要携带结果和错误信息:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PutAppendArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Key        <span class="type">string</span></span><br><span class="line">Value      <span class="type">string</span></span><br><span class="line">Op         <span class="type">string</span> <span class="comment">// &quot;Put&quot; or &quot;Append&quot;</span></span><br><span class="line">Seq        <span class="type">uint64</span></span><br><span class="line">Identifier <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PutAppendReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Err Err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Key        <span class="type">string</span></span><br><span class="line">Seq        <span class="type">uint64</span></span><br><span class="line">Identifier <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Err   Err</span><br><span class="line">Value <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-2-Put-Append"><a href="#4-1-2-2-Put-Append" class="headerlink" title="4.1.2.2 Put/Append"></a>4.1.2.2 <code>Put/Append</code></h4><p>这2个函数很简单 ,不断轮询<code>server</code>即可, 但是需要注意, 如果对方返回了超时错误和通道关闭错误等意料之外的错误, 需要重试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Get(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">args := &amp;GetArgs&#123;Key: key, Seq: ck.GetSeq(), Identifier: ck.identifier&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">reply := &amp;GetReply&#123;&#125;</span><br><span class="line">ok := ck.servers[ck.leaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, args, reply)</span><br><span class="line"><span class="keyword">if</span> !ok || reply.Err == ErrNotLeader || reply.Err == ErrLeaderOutDated &#123;</span><br><span class="line">ck.leaderId += <span class="number">1</span></span><br><span class="line">ck.leaderId %= <span class="built_in">len</span>(ck.servers)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> reply.Err &#123;</span><br><span class="line"><span class="keyword">case</span> ErrChanClose:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> ErrHandleOpTimeOut:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> ErrKeyNotExist:</span><br><span class="line"><span class="keyword">return</span> reply.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> reply.Value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> PutAppend(key <span class="type">string</span>, value <span class="type">string</span>, op <span class="type">string</span>) &#123;</span><br><span class="line"><span class="comment">// You will have to modify this function.</span></span><br><span class="line">args := &amp;PutAppendArgs&#123;Key: key, Value: value, Op: op, Seq: ck.GetSeq(), Identifier: ck.identifier&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">reply := &amp;PutAppendReply&#123;&#125;</span><br><span class="line">ok := ck.servers[ck.leaderId].Call(<span class="string">&quot;KVServer.PutAppend&quot;</span>, args, reply)</span><br><span class="line"><span class="keyword">if</span> !ok || reply.Err == ErrNotLeader || reply.Err == ErrLeaderOutDated &#123;</span><br><span class="line">ck.leaderId += <span class="number">1</span></span><br><span class="line">ck.leaderId %= <span class="built_in">len</span>(ck.servers)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> reply.Err &#123;</span><br><span class="line"><span class="keyword">case</span> ErrChanClose:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> ErrHandleOpTimeOut:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Put(key <span class="type">string</span>, value <span class="type">string</span>) &#123;</span><br><span class="line">ck.PutAppend(key, value, <span class="string">&quot;Put&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Append(key <span class="type">string</span>, value <span class="type">string</span>) &#123;</span><br><span class="line">ck.PutAppend(key, value, <span class="string">&quot;Append&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重试<code>RPC</code>时, 需要新建<code>reply</code>结构体, 重复使用同一个结构体将导致<code>labgob</code>报错</p></blockquote><h2 id="4-2-Server实现"><a href="#4-2-Server实现" class="headerlink" title="4.2 Server实现"></a>4.2 <code>Server</code>实现</h2><h3 id="4-2-1-Server设计思路"><a href="#4-2-1-Server设计思路" class="headerlink" title="4.2.1 Server设计思路"></a>4.2.1 <code>Server</code>设计思路</h3><p>根据前文分析可知, <code>RPC handler</code>(就是<code>Get/Put handler</code>)只会在<code>raft</code>层的<code>commit</code>信息到达后才能回复, 因此其逻辑顺序就是</p><ol><li>将请求封装后通过接口<code>Start</code>交付给<code>raft</code>层<ol><li>如果<code>raft</code>层节点不是<code>Leader</code>, 返回相应错误</li><li>否则继续</li></ol></li><li>等待<code>commit</code>信息<ol><li>信息到达, 根据<code>commit</code>信息处理回复(具体是什么样的信息回复后面会说)</li><li>超时, 返回相应错误</li></ol></li></ol><p>分析到这里可知, 必然有一个协程在不断地接收<code>raft</code>层的<code>commit</code>日志(此后称为<code>ApplyHandler</code>协程), 那上述提到的重复<code>RPC</code>判别和处理是在<code>ApplyHandler</code>中进行, 还是在<code>RPC handler</code>中进行呢?</p><p>我的处理方式是在<code>ApplyHandler</code>中进行, 因为<code>ApplyHandler</code>是绝对串行的, 在其中处理这些日志是最安全的, 否则通过通道发送给<code>RPC handler</code>货条件变量唤醒<code>RPC handler</code>, 都存在一些并发同步的问题, 因此, <code>ApplyHandler</code>需要进行重复<code>RPC</code>判别和处理(可能需要存储), 并将这个请求(<code>commit log</code>就对应一个请求)的结果返回给<code>RPC handler</code></p><h3 id="4-2-2-结构体设计"><a href="#4-2-2-结构体设计" class="headerlink" title="4.2.2 结构体设计"></a>4.2.2 结构体设计</h3><p>因此, 通过上述分析, <code>server</code>结构体如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KVServer <span class="keyword">struct</span> &#123;</span><br><span class="line">mu         sync.Mutex</span><br><span class="line">me         <span class="type">int</span></span><br><span class="line">rf         *raft.Raft</span><br><span class="line">applyCh    <span class="keyword">chan</span> raft.ApplyMsg</span><br><span class="line">dead       <span class="type">int32</span>                <span class="comment">// set by Kill()</span></span><br><span class="line">waiCh      <span class="keyword">map</span>[<span class="type">int</span>]*<span class="keyword">chan</span> result <span class="comment">// 映射 startIndex-&gt;ch</span></span><br><span class="line">historyMap <span class="keyword">map</span>[<span class="type">int64</span>]*result    <span class="comment">// 映射 Identifier-&gt;*result</span></span><br><span class="line"></span><br><span class="line">maxraftstate <span class="type">int</span> <span class="comment">// snapshot if log grows this big</span></span><br><span class="line">maxMapLen    <span class="type">int</span></span><br><span class="line">db           <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">LastSeq <span class="type">uint64</span></span><br><span class="line">Err     Err</span><br><span class="line">Value   <span class="type">string</span></span><br><span class="line">ResTerm <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><code>historyMap</code>记录某<code>clerk</code>的最高序列号的请求的序列号和结果<code>result</code></li><li><code>result</code>结构体存储一个请求的序列号和结果, 以及<code>ResTerm</code>记录<code>commit</code>被<code>apply</code>时的<code>term</code>, 因为其可能与<code>Start</code>相比发生了变化, 需要将这一信息返回给客户端</li><li><code>waiCh</code>纪录等待<code>commit</code>信息的<code>RPC handler</code>的通道</li></ul><h3 id="4-2-3-RPC-handler设计"><a href="#4-2-3-RPC-handler设计" class="headerlink" title="4.2.3 RPC handler设计"></a>4.2.3 <code>RPC handler</code>设计</h3><p><code>RPC handler</code>设计较为简单,只需要调用<code>Start</code>, 等待<code>commit</code>信息即可, 不过还需要考虑超时的错误处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> Get(args *GetArgs, reply *GetReply) &#123;</span><br><span class="line"><span class="comment">// 先判断是不是leader</span></span><br><span class="line">_, isLeader := kv.rf.GetState()</span><br><span class="line"><span class="keyword">if</span> !isLeader &#123;</span><br><span class="line">reply.Err = ErrNotLeader</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">opArgs := &amp;Op&#123;OpType: OPGet, Seq: args.Seq, Key: args.Key, Identifier: args.Identifier&#125;</span><br><span class="line"></span><br><span class="line">res := kv.HandleOp(opArgs)</span><br><span class="line">reply.Err = res.Err</span><br><span class="line">reply.Value = res.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> PutAppend(args *PutAppendArgs, reply *PutAppendReply) &#123;</span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line"><span class="comment">// 先判断是不是leader</span></span><br><span class="line">_, isLeader := kv.rf.GetState()</span><br><span class="line"><span class="keyword">if</span> !isLeader &#123;</span><br><span class="line">reply.Err = ErrNotLeader</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">opArgs := &amp;Op&#123;Seq: args.Seq, Key: args.Key, Val: args.Value, Identifier: args.Identifier&#125;</span><br><span class="line"><span class="keyword">if</span> args.Op == <span class="string">&quot;Put&quot;</span> &#123;</span><br><span class="line">opArgs.OpType = OPPut</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">opArgs.OpType = OPAppend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res := kv.HandleOp(opArgs)</span><br><span class="line">reply.Err = res.Err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Get</code>和<code>PutAppend</code>都将请求封装成<code>Op</code>结构体, 统一给<code>HandleOp</code>处理, <code>HandleOp</code>处理<code>ApplyHandler</code>发过来的<code>commit</code>信息并生成回复, 这里我采用的通信方式是管道, 每一个请求会将自己创建的管道存储在<code>waiCh</code>中, 并在函数离开时清理管道和<code>waiCh</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> HandleOp(opArgs *Op) (res result) &#123;</span><br><span class="line">startIndex, startTerm, isLeader := kv.rf.Start(*opArgs)</span><br><span class="line"><span class="keyword">if</span> !isLeader &#123;</span><br><span class="line"><span class="keyword">return</span> result&#123;Err: ErrNotLeader, Value: <span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kv.mu.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接覆盖之前记录的chan</span></span><br><span class="line">newCh := <span class="built_in">make</span>(<span class="keyword">chan</span> result)</span><br><span class="line">kv.waiCh[startIndex] = &amp;newCh</span><br><span class="line">DPrintf(<span class="string">&quot;leader %v identifier %v Seq %v 的请求: 新建管道: %p\n&quot;</span>, kv.me, opArgs.Identifier, opArgs.Seq, &amp;newCh)</span><br><span class="line">kv.mu.Unlock() <span class="comment">// Start函数耗时较长, 先解锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">kv.mu.Lock()</span><br><span class="line"><span class="built_in">delete</span>(kv.waiCh, startIndex)</span><br><span class="line"><span class="built_in">close</span>(newCh)</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待消息到达或超时</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(HandleOpTimeOut):</span><br><span class="line">res.Err = ErrHandleOpTimeOut</span><br><span class="line">DPrintf(<span class="string">&quot;server %v identifier %v Seq %v: 超时&quot;</span>, kv.me, opArgs.Identifier, opArgs.Seq)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> msg, success := &lt;-newCh:</span><br><span class="line"><span class="keyword">if</span> success &amp;&amp; msg.ResTerm == startTerm &#123;</span><br><span class="line">res = msg</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !success &#123;</span><br><span class="line"><span class="comment">// 通道已经关闭, 有另一个协程收到了消息 或 通道被更新的RPC覆盖</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 是否需要判断消息到达时自己已经不是leader了?</span></span><br><span class="line">DPrintf(<span class="string">&quot;server %v identifier %v Seq %v: 通道已经关闭, 有另一个协程收到了消息 或 更新的RPC覆盖, args.OpType=%v, args.Key=%+v&quot;</span>, kv.me, opArgs.Identifier, opArgs.Seq, opArgs.OpType, opArgs.Key)</span><br><span class="line">res.Err = ErrChanClose</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// term与一开始不匹配, 说明这个Leader可能过期了</span></span><br><span class="line">DPrintf(<span class="string">&quot;server %v identifier %v Seq %v: term与一开始不匹配, 说明这个Leader可能过期了, res.ResTerm=%v, startTerm=%+v&quot;</span>, kv.me, opArgs.Identifier, opArgs.Seq, res.ResTerm, startTerm)</span><br><span class="line">res.Err = ErrLeaderOutDated</span><br><span class="line">res.Value = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要额外注意错误处理:</p><ol><li>超时错误</li><li>通道关闭错误</li><li><code>Leader</code>可能过期的错误(<code>term</code>不匹配)</li><li>不是<code>Leader</code>的错误</li></ol><p>同时这里还有一个难点, 就是如果出现了重复的<code>RPC</code>, 他们都在等待<code>commit</code>信息, 那么他们的管道存储在<code>waiCh</code>中的<code>key</code>是什么呢? 如果使用<code>Identifier</code>或<code>Seq</code>, 那么必然后来的<code>RPC</code>会覆盖之前的管道, 可能造成错误, 因为两个重复<code>RPC</code>的<code>Identifier</code>或<code>Seq</code>是一样的。 这里可以巧妙地利用<code>Start</code>函数的第一个返回值， 其代表如果<code>commit</code>成功, 其日志项的索引号, 由于<code>raft</code>层不区分重复<code>RPC</code>的<code>log</code>, 因此这个索引号肯定是不同的, 不会相互覆盖</p><h3 id="4-2-4-ApplyHandler设计"><a href="#4-2-4-ApplyHandler设计" class="headerlink" title="4.2.4 ApplyHandler设计"></a>4.2.4 <code>ApplyHandler</code>设计</h3><p><code>ApplyHandler</code>是<code>3A</code>的最核心的部分, 其思路是:</p><ol><li>先判断<code>log</code>请求的<code>Identifier</code>和<code>Seq</code>是否在历史记录<code>historyMap</code>中是否存在, 如果存在就直接返回历史记录</li><li>不存在就需要应用到状态机, 并更新历史记录<code>historyMap</code></li><li>如果<code>log</code>请求的<code>CommandIndex</code>对应的<code>key</code>在<code>waiCh</code>中存在, 表面当前节点可能是一个<code>Leader</code>, 需要将结果发送给<code>RPC handler</code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> ApplyHandler() &#123;</span><br><span class="line"><span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">log := &lt;-kv.applyCh</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> log.CommandValid &#123;</span><br><span class="line"></span><br><span class="line">op := log.Command.(Op)</span><br><span class="line">kv.mu.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要判断这个log是否需要被再次应用</span></span><br><span class="line"><span class="keyword">var</span> res result</span><br><span class="line"></span><br><span class="line">needApply := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> hisMap, exist := kv.historyMap[op.Identifier]; exist &#123;</span><br><span class="line"><span class="keyword">if</span> hisMap.LastSeq == op.Seq &#123;</span><br><span class="line"><span class="comment">// 历史记录存在且Seq相同, 直接套用历史记录</span></span><br><span class="line">res = *hisMap</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> hisMap.LastSeq &lt; op.Seq &#123;</span><br><span class="line"><span class="comment">// 否则新建</span></span><br><span class="line">needApply = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 历史记录不存在</span></span><br><span class="line">needApply = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, isLeader := kv.rf.GetState()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> needApply &#123;</span><br><span class="line"><span class="comment">// 执行log</span></span><br><span class="line">res = kv.DBExecute(&amp;op, isLeader)</span><br><span class="line">res.ResTerm = log.SnapshotTerm</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新历史记录</span></span><br><span class="line">kv.historyMap[op.Identifier] = &amp;res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !isLeader &#123;</span><br><span class="line"><span class="comment">// 不是leader则继续检查下一个log</span></span><br><span class="line">kv.mu.Unlock()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Leader还需要额外通知handler处理clerk回复</span></span><br><span class="line">ch, exist := kv.waiCh[log.CommandIndex]</span><br><span class="line"><span class="keyword">if</span> !exist &#123;</span><br><span class="line"><span class="comment">// 接收端的通道已经被删除了并且当前节点是 leader, 说明这是重复的请求, 但这种情况不应该出现, 所以panic</span></span><br><span class="line">DPrintf(<span class="string">&quot;leader %v ApplyHandler 发现 identifier %v Seq %v 的管道不存在, 应该是超时被关闭了&quot;</span>, kv.me, op.Identifier, op.Seq)</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 如果这里有 panic，是因为通道关闭</span></span><br><span class="line">DPrintf(<span class="string">&quot;leader %v ApplyHandler 发现 identifier %v Seq %v 的管道不存在, 应该是超时被关闭了&quot;</span>, kv.me, op.Identifier, op.Seq)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">res.ResTerm = log.SnapshotTerm</span><br><span class="line">*ch &lt;- res</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这里有几大易错点:</p><ol><li>需要额外传递<code>Term</code>以供<code>RPC handler</code>判断与调用<code>Start</code>时相比, <code>term</code>是否变化, 如果变化, 可能是<code>Leader</code>过期, 需要告知<code>clerk</code></li><li>发送消息到通道时, 需要解锁</li><li>因为发送消息到通道时解锁, 所以通道可能被关闭, 因此需要单独在一个函数中使用<code>recover</code>处理发送消息到不存在的通道时的错误</li><li>这个<code>ApplyHandler</code>是<code>leader</code>和<code>follower</code>都存在的协程, 只不过<code>follower</code>到应用到状态机和判重那里就结束了, <code>leader</code>多出来告知<code>RPC handler</code>结果的部分</li></ol><p><code>DBExecute</code>就是将日志项应用到状态机, 逻辑很简单:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> DBExecute(op *Op, isLeader <span class="type">bool</span>) (res result) &#123;</span><br><span class="line"><span class="comment">// 调用该函数需要持有锁</span></span><br><span class="line">res.LastSeq = op.Seq</span><br><span class="line"><span class="keyword">switch</span> op.OpType &#123;</span><br><span class="line"><span class="keyword">case</span> OPGet:</span><br><span class="line">val, exist := kv.db[op.Key]</span><br><span class="line"><span class="keyword">if</span> exist &#123;</span><br><span class="line">kv.LogInfoDBExecute(op, <span class="string">&quot;&quot;</span>, val, isLeader)</span><br><span class="line">res.Value = val</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res.Err = ErrKeyNotExist</span><br><span class="line">res.Value = <span class="string">&quot;&quot;</span></span><br><span class="line">kv.LogInfoDBExecute(op, <span class="string">&quot;&quot;</span>, ErrKeyNotExist, isLeader)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> OPPut:</span><br><span class="line">kv.db[op.Key] = op.Val</span><br><span class="line">kv.LogInfoDBExecute(op, <span class="string">&quot;&quot;</span>, kv.db[op.Key], isLeader)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> OPAppend:</span><br><span class="line">val, exist := kv.db[op.Key]</span><br><span class="line"><span class="keyword">if</span> exist &#123;</span><br><span class="line">kv.db[op.Key] = val + op.Val</span><br><span class="line">kv.LogInfoDBExecute(op, <span class="string">&quot;&quot;</span>, kv.db[op.Key], isLeader)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">kv.db[op.Key] = op.Val</span><br><span class="line">kv.LogInfoDBExecute(op, <span class="string">&quot;&quot;</span>, kv.db[op.Key], isLeader)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-测试"><a href="#5-测试" class="headerlink" title="5 测试"></a>5 测试</h1><p>执行测试命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -v -run 3A</span><br></pre></td></tr></table></figure><p>结果如下:<br><img src="/../../images/lab3-3A-test.png" alt="Alt text"></p><p>该代码经过150次测试没有报错</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将介绍&lt;code&gt;lab3A&lt;/code&gt;部分的实现, &lt;code&gt;lab3A&lt;/code&gt;要求基于&lt;code&gt;raft&lt;/code&gt;实现一个容错的分布式&lt;code&gt;KV&lt;/code&gt;数据库, 但不要求实现快照, 难度还是不小&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Lab&lt;/cod</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="Lab笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/Lab%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Go" scheme="http://example.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.5840(6.824) Lec10: ZooKeeper</title>
    <link href="http://example.com/2024/01/19/MIT6.5840/Lec10%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/01/19/MIT6.5840/Lec10%E7%AC%94%E8%AE%B0/</id>
    <published>2024-01-19T06:22:02.000Z</published>
    <updated>2024-01-22T00:22:47.152Z</updated>
    
    <content type="html"><![CDATA[<p>本次课程介绍了<code>ZooKeeper</code>, 并且我结合教授的课程和原论文总结了<code>ZooKeeper</code>的关键知识点形成了本文</p><p>课程主页: <a href="https://pdos.csail.mit.edu/6.824/schedule.html">https://pdos.csail.mit.edu/6.824/schedule.html</a></p><p>原论文地址: <a href="https://pdos.csail.mit.edu/6.824/papers/zookeeper.pdf">https://pdos.csail.mit.edu/6.824/papers/zookeeper.pdf</a></p><h1 id="0-引入-ZooKeeper是什么-和Raft区别是什么"><a href="#0-引入-ZooKeeper是什么-和Raft区别是什么" class="headerlink" title="0 引入: ZooKeeper是什么? 和Raft区别是什么?"></a>0 引入: ZooKeeper是什么? 和Raft区别是什么?</h1><ul><li><strong>更容易的交互</strong></li></ul><ol><li><code>Apache ZooKeeper</code> 是一个开源的分布式协调服务，它为分布式应用提供了一种可靠的同步服务。<code>ZooKeeper</code> 允许分布式进程通过一个共享的层次名称空间互相协调，这个名称空间类似于文件系统的目录树结构，但是它更专注于协调，而不是存储。ZooKeeper的设计目标是将分布式协调的复杂性封装起来，为开发人员提供一个简单一致的编程接口。也就是说, <code>ZooKeeper</code> 可以直接供应用程序进行交互, 应用程序不需要与<code>ZooKeeper</code>在底层上关联(例如加载二进制库文件)</li><li><code>Raft</code>不是一个可以直接交互的独立的服务， 而是以一个库的形式提供服务, 因此必须要设计自己的应用程序来与<code>Raft</code>库交互。<blockquote><p><code>Zookeeper</code>运行在<code>Zab</code>之上，<code>Zab</code>和之前的<code>Lab</code>实现的<code>Raft</code>属于同一层级, <code>Zab</code>在更低的层级也是维护一系列的<code>log</code>, 和<code>raft</code>类似</p></blockquote></li></ol><ul><li>提升读请求的性能</li></ul><ol><li><p><code>raft</code>的效率<br>由于我们目前已经实现了<code>raft</code>协议, 因此我们知道, 服务的性能并不随服务器数量的提升线性增长, 甚至会有性能下降, 因为<code>raft</code>需要将一个日志复制到过半的节点后才能标记为<code>commit</code>, 因此服务器越多, 这一步骤耗费越大, 甚至拖累整个几集群的运行速度。</p></li><li><p><code>ZooKeeper</code>的效率<br><code>ZooKeeper</code>的读请求直接发送给一个随机的副本处理, 不需要在真个集群内进行同步, 因此其运行速度更快, 缺点是<strong>除了<code>Leader</code>以外的任何一个副本节点的数据是不一定是最新的</strong></p><blockquote><p>因此, <code>Zookeeper</code>的读操作放弃了线性一致性</p></blockquote></li></ol><h1 id="1-ZooKeeper如何提供服务"><a href="#1-ZooKeeper如何提供服务" class="headerlink" title="1 ZooKeeper如何提供服务?"></a>1 <code>ZooKeeper</code>如何提供服务?</h1><h2 id="1-1-服务保证"><a href="#1-1-服务保证" class="headerlink" title="1.1 服务保证"></a>1.1 服务保证</h2><p>简单来说, <code>ZooKeeper</code>是通过<code>client</code>对一个<strong>分层的命名空间</strong>中节点(<code>znodes</code>)的<code>CRUD</code>操作来实现各种分布式服务, <code>ZooKeeper</code>为这个命名空间的各种操作做出了如下的保证:</p><ol><li><p>写操作的线性一致性 (<code>Linearizable Writes</code>)<br>ZooKeeper保证所有更新其状态的请求都是可序列化的，并且遵循先行顺序。这意味着写操作是原子的，并且系统中的所有其他操作都将看到这一操作之前或之后的状态，而不会有部分更新的现象。这是分布式系统中对于一致性的一个关键保证。</p><blockquote><p>需要注意的是, <code>ZooKeeper</code>中的读操作默认情况下并不是线性一致的，这意味着读操作可能会返回一个稍微过时的数据状态，而不是最新的写操作之后的状态。这样做的目的是为了提高性能，因为读操作可以在没有与其他服务器通信的情况下本地快速完成。如果需要读取最新的数据状态, <code>ZooKeeper</code>提供了后面提到的<code>sync</code>操作</p></blockquote></li><li><p>客户端FIFO顺序 (<code>FIFO Client Order</code>)<br>来自同一个客户端的所有请求都将按照它们被客户端发送的顺序执行。这意味着同一个客户端发起的操作将会按照其发起的顺序被严格处理，保证了客户端视图的顺序性。</p></li><li><p>线性一致性 (<code>A-linearizability</code>)<br><code>ZooKeeper</code>定义的线性一致性称为异步线性一致性（<code>A-linearizability</code>）。在Herlihy的定义中，客户端一次只能有一个操作在执行中（如同一个线程）。而在<code>ZooKeeper</code>的定义中，一个客户端可以有多个未完成的操作，因此可以选择不保证同一客户端的未完成操作的特定顺序，或者保证FIFO顺序。<code>ZooKeeper</code>选择了后者。</p></li><li><p>读操作的本地处理<br>由于只有更新请求是<code>A-linearizable</code>，<code>ZooKeeper</code>将读请求在每个副本上本地处理。这允许服务随着服务器的增加而线性扩展。</p></li><li><p>交互的保证<br>举例来说，如果一个系统中的多个进程选举出一个<code>Leader</code>来指挥工作进程，当一个新的<code>Leader</code>接管系统时，它必须更改许多配置参数，并在完成后通知其他进程。在这种情况下，<code>ZooKeeper</code>需要保证：</p></li></ol><ul><li>当新<code>Leader</code>开始进行更改时，不希望其他进程开始使用正在更改的配置；</li><li>如果新<code>Leader</code>在配置完全更新之前死亡，不希望进程使用这个部分配置。</li></ul><ol start="6"><li>存活性和持久性保证<br><code>ZooKeeper</code>还保证了存活性和持久性：</li></ol><ul><li>只要<code>ZooKeeper</code>服务器的大多数都是活跃的并且能够通信，服务就会可用；</li><li>如果<code>ZooKeeper</code>服务成功响应了一个变更请求，那么只要服务器的法定人数最终能够恢复，该变更就会持续存在，不会因为任何数量的故障而丢失。</li></ul><ol start="7"><li>同步读 (<code>sync</code>)<br>为了处理由于客户端之间通信延迟导致的潜在问题，<code>ZooKeeper</code>提供了<code>sync</code>请求。如果在执行读操作之前使用<code>sync</code>，它会导致服务器先应用所有挂起的写请求再处理读请求，这样客户端就能看到最新的状态，而不需要承担完整写操作的开销。</li></ol><p>通过以上的几项基本保证, 应用程序可以通过<code>ZooKeeper</code>构建许多的分布式服务, 如分布式锁、配置管理等。</p><h2 id="1-2-命名空间"><a href="#1-2-命名空间" class="headerlink" title="1.2 命名空间"></a>1.2 命名空间</h2><p>下图所示为<code>ZooKeeper</code>的命名空间图解， 实际上就是一棵树</p><p><img src="/../../images/ZooKeeper-namespace.png" alt="ZooKeeper-namespace"></p><p>树中的每一个节点用数据结构<code>Znode</code>表示, <code>Znode</code>可以有子节点，并且可以存储数据。每个<code>Znode</code>都由路径唯一标识，例如<code>/app1/myconfig/dbconfig</code>。具体而言, <code>Znode</code>有一下几个类比:</p><ol><li><code>Regular znodes</code>: 一旦创建，就永久存在，除非显示删除</li><li><code>Ephemeral znodes</code>: 与<code>client session</code>绑定, <code>session</code>结束则被删除(通过心跳判断<code>session</code>是否存活)</li><li><code>Sequential znodes</code>: 会自动为指定的文件名再加上一个数字并确保数字不重合且单调递增</li></ol><h2 id="1-3-API"><a href="#1-3-API" class="headerlink" title="1.3 API"></a>1.3 API</h2><p><code>ZooKeeper</code>的设计目标是将分布式协调的复杂性封装起来，为开发人员提供一个简单一致的编程接口。<br>基于您提供的格式，以下是对Apache ZooKeeper核心API的简化解释：</p><ol><li>create(path, data, flags)<br>用于创建一个新的<code>znode</code>。</li></ol><ul><li><code>path</code>: 想要创建的<code>znode</code>的路径。</li><li><code>data</code>: 一个字节数组，您想要存储在新<code>znode</code>中的数据。</li><li><code>flags</code>: 这个参数用来指定创建<code>znode</code>的类型。可以选择创建一个普通<code>znode</code>，一个临时的<code>znode</code>（<code>ephemeral</code>），或者是一个顺序的<code>znode</code>（<code>sequential</code>）。临时<code>znode</code>在创建它的客户端会话结束时会被删除，而顺序<code>znode</code>会有一个唯一的递增序号自动追加到它的路径名中。</li></ul><ol start="2"><li>delete(path, version)<br>删除指定路径的<code>znode</code>，但只在<code>znode</code>的版本号与提供的<code>version</code>参数匹配时才会执行。</li></ol><ul><li><code>path</code>: 要删除的<code>znode</code>的路径。</li><li><code>version</code>: 预期的<code>znode</code>版本号。如果指定的版本号与<code>znode</code>的当前版本号不匹配，删除操作将失败。</li></ul><ol start="3"><li>exists(path, watch)<br>这个API检查指定路径的<code>znode</code>是否存在。</li></ol><ul><li><code>path</code>: 要检查的<code>znode</code>的路径。</li><li><code>watch</code>: 一个布尔值，当设置为<code>true</code>时，如果这个<code>znode</code>的状态发生变化（比如被删除或数据被修改），客户端将被通知。</li></ul><ol start="4"><li>getData(path, watch)<br>获取一个<code>znode</code>的数据和元数据（如版本信息）。</li></ol><ul><li><code>path</code>: <code>znode</code>的路径。</li><li><code>watch</code>: 与<code>exists</code>中的<code>watch</code>相同，允许客户端在这个<code>znode</code>上设置一个监视器。如果这个<code>znode</code>不存在，ZooKeeper不会设置监视器。</li></ul><ol start="5"><li>setData(path, data, version)<br>向指定的<code>znode</code>写入数据，但只在当前版本号与提供的<code>version</code>参数匹配时才会执行。</li></ol><ul><li><code>path</code>: <code>znode</code>的路径。</li><li><code>data</code>: 要写入的数据的字节数组。</li><li><code>version</code>: <code>znode</code>的预期版本号。</li></ul><ol start="6"><li>getChildren(path, watch)<br>获取一个<code>znode</code>的所有子节点的名称集合。</li></ol><ul><li><code>path</code>: 父<code>znode</code>的路径。</li><li><code>watch</code>: 一个布尔值，作用与<code>exists</code>和<code>getData</code>中的<code>watch</code>相同。</li></ul><ol start="7"><li>sync(path)<br>同步API等待所有在操作开始时挂起的更新传播到客户端所连接的服务器。论文中提到目前实现中<code>path</code>参数被忽略，但在将来它可能会被用于指定同步操作的范围。</li></ol><h1 id="2-ZooKeeper的服务案例"><a href="#2-ZooKeeper的服务案例" class="headerlink" title="2 ZooKeeper的服务案例"></a>2 <code>ZooKeeper</code>的服务案例</h1><h2 id="2-1-配置管理"><a href="#2-1-配置管理" class="headerlink" title="2.1 配置管理"></a>2.1 配置管理</h2><p><code>ZooKeeper</code> 可以用来为分布式应用实现动态配置管理。其结构可以如下：</p><ul><li><strong>存储</strong>：配置数据被存储在 <code>ZooKeeper</code> 的一个节点（<code>znode</code>），称为 <code>zc</code>。</li><li><strong>初始化</strong>：进程启动时带有<code>zc</code>的完整路径，并通过读取该<code>znode</code>获取配置。</li><li><strong>监听</strong>：进程在读取配置时对 <code>zc</code> 设置监听（<code>watch flag</code>），以便在配置更新时得到通知。</li><li><strong>通知更新</strong>：一旦 <code>zc</code> 节点更新，进程会收到通知，并读取新的配置信息，并再次设置监听以便未来的更新。</li><li><strong>效率</strong>：监听确保进程始终使用最新的配置信息，并且在连续更新发生时不需要接收多个通知。</li></ul><blockquote><p>为什么需要<code>watch</code>?<br>因为可能存在如下情况:</p><ol><li>某个副本通过<code>exist</code>发现<code>zc</code>存在</li><li><code>Leader</code>删除了<code>zc</code></li><li>副本继续读取后续配置节点信息</li></ol><p>为了避免上述情况, <code>exist</code>查询时还会建立<code>watch</code>, 如果<code>zc</code>有任何变更, <strong>副本会确保在合适的时机返回变化的通知, 并且这是在任何后续的读请求之前完成</strong>, 体现在业务上就是: 读取配置读了一半，收到了<code>zc</code>删除的通知，放弃这次读再重试</p></blockquote><h2 id="2-2-会合点"><a href="#2-2-会合点" class="headerlink" title="2.2 会合点"></a>2.2 会合点</h2><p><code>ZooKeeper</code> 使得分布式系统中的进程能够动态发现对方，尤其是在系统配置未知的情况下：</p><ul><li>**会合点<code>znode</code>**：创建一个会合点<code>znode</code>，<code>zr</code>，用于进程间协调。</li><li><strong>启动参数</strong>：将 <code>zr</code> 的完整路径作为启动参数传递给主进程(master)和工作进程(worker)。</li><li><strong>主进程注册信息</strong>：主进程启动后，将其地址和端口信息写入 <code>zr</code>。</li><li><strong>工作进程发现</strong>：工作进程读取 <code>zr</code> 并设置监听，以便在 <code>zr</code> 更新主进程信息时得到通知。</li><li><strong>临时节点</strong>：如果 <code>zr</code> 是临时节点，主进程和工作进程可以通过监听 <code>zr</code> 的删除来进行清理操作（表示客户端结束）。</li></ul><h2 id="2-3-组成员管理"><a href="#2-3-组成员管理" class="headerlink" title="2.3 组成员管理"></a>2.3 组成员管理</h2><p><code>ZooKeeper</code> 使用临时节点来管理分布式系统中的组成员资格：</p><ul><li><strong>组表示</strong>：指定一个 <code>znode</code>，<code>zg</code>，来代表组。</li><li><strong>成员注册</strong>：成员进程启动时，在 <code>zg</code> 下创建一个临时子节点。</li><li><strong>唯一标识</strong>：子节点以进程的唯一名称或标识符命名，或者使用SEQUENTIAL标志以自动获取唯一名称。</li><li><strong>进程信息</strong>：子节点的数据字段可以包含相关进程信息，例如使用的地址和端口。</li><li><strong>自动清理</strong>：当进程失败或结束时，其在 <code>zg</code> 下代表它的节点会被自动移除。</li><li><strong>发现和监控</strong>：进程通过列出 <code>zg</code> 的子节点来获取组信息，并且可以设置监听来监控组成员资格的变化，接到通知时刷新信息并再次设置监听。</li></ul><h2 id="2-3-分布式锁"><a href="#2-3-分布式锁" class="headerlink" title="2.3 分布式锁"></a>2.3 分布式锁</h2><h3 id="2-3-1-简单锁"><a href="#2-3-1-简单锁" class="headerlink" title="2.3.1 简单锁"></a>2.3.1 简单锁</h3><p>尽管 <code>ZooKeeper</code> 不是专门的锁服务，但它可以用来实现锁。使用 <code>ZooKeeper</code> 的应用程序通常会根据它们的需求使用定制的同步原语，如上所述。下面展示如何使用 <code>ZooKeeper</code> 实现锁，以表明它能够实现多种通用的同步原语。</p><p>最简单的锁实现使用“锁文件”。</p><ol><li>锁由一个 <code>znode</code> 表示。</li><li>为了获得锁，客户端尝试使用 <code>EPHEMERAL</code> 标志创建指定的 <code>znode</code>。如果创建成功，客户端持有锁。否则，客户端可以使用 <code>watch</code> 标志读取 <code>znode</code>，以便在当前领导者死亡时得到通知。客户端在它死亡或显式删除 <code>znode</code> 时释放锁。</li><li>其他等待锁的客户端一旦观察到 <code>znode</code> 被删除，就会再次尝试获得锁。<br>伪代码如下:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WHILE TRUE:</span><br><span class="line">    IF CREATE(<span class="string">&quot;f&quot;</span>, data, ephemeral=TRUE): RETURN</span><br><span class="line">    IF EXIST(<span class="string">&quot;f&quot;</span>, watch=TRUE):</span><br><span class="line">        WAIT</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>这里在获取锁失败后还需要检测锁文件是否存在, 因为<code>CREATE</code>和<code>EXIST</code>之间可能其他客户端删除了锁文件</p></blockquote><p>这种简单的锁定协议虽然有效，但存在一些问题。首先，它会遭受羊群效应（<code>herd effect</code>）。如果有许多客户端等待获得锁，当锁释放时，他们都会争夺锁，尽管只有一个客户端可以获得锁。其次，它只实现了独占锁定。以下两个原语展示如何克服这两个问题。</p><h3 id="2-3-2-不具有羊群效应的锁"><a href="#2-3-2-不具有羊群效应的锁" class="headerlink" title="2.3.2 不具有羊群效应的锁"></a>2.3.2 不具有羊群效应的锁</h3><p>定义一个锁 <code>znode</code> <code>l</code> 来实现这样的锁。直观地，排列所有请求锁的客户端，每个客户端按请求到达的顺序获得锁。因此，希望建立锁的客户端会执行以下操作：</p><p><strong>加锁</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 n = create(l + &quot;/lock-&quot;, EPHEMERAL|SEQUENTIAL)</span><br><span class="line">2 C = getChildren(l, false)</span><br><span class="line">3 if n is the lowest znode in C, exit</span><br><span class="line">4 p = znode in C ordered just before n</span><br><span class="line">5 if exists(p, true) wait for watch event</span><br><span class="line">6 goto 2</span><br></pre></td></tr></table></figure><p><strong>解锁</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 delete(n)</span><br></pre></td></tr></table></figure><p>在加锁的第 1 行中使用 <code>SEQUENTIAL</code> 标志，按顺序排列客户端尝试获得锁的尝试。如果客户端的 <code>znode</code> 在第 3 行时具有最低的序列号，那么该客户端持有锁。否则，客户端等待删除拥有锁或在该客户端的 <code>znode</code> 之前将获得锁的 <code>znode</code>。通过只监视在客户端的 <code>znode</code> 之前的 <code>znode</code>，通过在释放锁或放弃锁请求时只唤醒一个进程来避免羊群效应。一旦客户端正在监视的 <code>znode</code> 消失，客户端必须检查它现在是否持有锁。（之前的锁请求可能被放弃，还有一个具有较低序列号的 <code>znode</code> 仍在等待或持有锁。）</p><p>释放锁就像删除代表锁请求的 <code>znode</code> <code>n</code> 一样简单。通过在创建时使用 EPHEMERAL 标志，崩溃的进程将自动清理它们可能拥有的任何锁请求或释放的锁。</p><p>这种锁定方案有以下优点：</p><ol><li>一个 <code>znode</code> 的移除只会使一个客户端唤醒，因为每个 <code>znode</code> 仅被一个其他客户端监视，所以没有羊群效应；</li><li>没有轮询或超时；</li><li>由于实现锁定的方式，可以通过浏览 <code>ZooKeeper</code> 数据来了解锁竞争的数量，打破锁，以及调试锁定问题。</li></ol><h3 id="2-3-3-读-写锁"><a href="#2-3-3-读-写锁" class="headerlink" title="2.3.3 读&#x2F;写锁"></a>2.3.3 读&#x2F;写锁</h3><p>为实现读&#x2F;写锁，需要稍微修改锁定程序，并且有单独的读锁和写锁程序。解锁程序与全局锁情况相同。</p><p><strong>写锁</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 n = create(l + &quot;/write-&quot;, EPHEMERAL|SEQUENTIAL)</span><br><span class="line">2 C = getChildren(l, false)</span><br><span class="line">3 if n is the lowest znode in C, exit</span><br><span class="line">4 p = znode in C ordered just before n</span><br><span class="line">5 if exists(p, true) wait for event</span><br><span class="line">6 goto 2</span><br></pre></td></tr></table></figure><p><strong>读锁</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 n = create(l + &quot;/read-&quot;, EPHEMERAL|SEQUENTIAL)</span><br><span class="line">2 C = getChildren(l, false)</span><br><span class="line">3 if no write znodes lower than n in C, exit</span><br><span class="line">4 p = write znode in C ordered just before n</span><br><span class="line">5 if exists(p, true) wait for event</span><br><span class="line">6 goto 3</span><br></pre></td></tr></table></figure><p>这种锁定程序与之前的锁略有不同。写锁只在命名上有所不同。由于读锁可以共享，第 3 和第 4 行略有不同，因为只有较早的写锁 <code>znode</code> 会阻止客户端获得读锁。看起来在多个客户端等待读锁时可能会有“羊群效应”，并且在删除序列号较低的“write-” <code>znode</code> 时得到通知；实际上，这是一种期望的行为，所有那些等待读锁的客户端应该被释放，因为他们现在可能持有锁。</p><h2 id="2-4-双重屏障"><a href="#2-4-双重屏障" class="headerlink" title="2.4 双重屏障"></a>2.4 双重屏障</h2><p>双重屏障使客户端能够同步计算的开始和结束。当足够多的进程（由屏障阈值定义）加入屏障时，进程开始他们的计算，并在他们完成后离开屏障。</p><ol><li>用一个称为 <code>b</code> 的 <code>znode</code> 在 <code>ZooKeeper</code> 中表示一个屏障。</li><li>每个进程 <code>p</code> 通过在入口处创建一个作为 <code>b</code> 的子节点的 <code>znode</code> 来注册，并在准备离开时注销（删除该子节点）。</li><li>当 <code>b</code> 的子节点数超过屏障阈值时，进程可以进入屏障。</li><li>当所有进程都移除了它们的子节点时，进程可以离开屏障。</li><li>使用 <code>watches</code> 高效等待进入和退出条件得到满足。</li><li>为了进入，进程监视 <code>b</code> 的一个 <code>ready</code> 子节点的存在，该节点将由导致子节点数超过屏障阈值的进程创建。为了离开，进程监视特定子节点的消失，并且只有在该 <code>znode</code> 被移除后才检查退出条件。</li></ol><h2 id="2-5-并发计数器"><a href="#2-5-并发计数器" class="headerlink" title="2.5 并发计数器"></a>2.5 并发计数器</h2><p>通过<code>ZooKeeper</code>提供的版本号, 可以在无锁的条件下实现一个并发计数器:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WHILE TRUE:</span><br><span class="line">    X, V = GETDATA(<span class="string">&quot;F&quot;</span>)</span><br><span class="line">    IF SETDATA(<span class="string">&quot;f&quot;</span>, X + <span class="number">1</span>, V):</span><br><span class="line">        BREAK</span><br></pre></td></tr></table></figure><p>在这个循环中先调用<code>GETDATA</code>读取一次数据并记录其版本号<code>V</code>, 然后调用<code>SETDATA</code>更新数据, 且这个函数只在办好匹配的情况下才更新数据, 如果版号不匹配则进入下一次循环</p><h1 id="3-ZooKeeper的实现"><a href="#3-ZooKeeper的实现" class="headerlink" title="3 ZooKeeper的实现"></a>3 <code>ZooKeeper</code>的实现</h1><h2 id="3-1-基本架构"><a href="#3-1-基本架构" class="headerlink" title="3.1 基本架构"></a>3.1 基本架构</h2><p><img src="/../../images/ZooKeeper-components.png" alt="ZooKeeper-components"></p><p>上图所示为<code>ZooKeeper </code>服务的组件: 收请求、准备执行请求的<code>request processor</code> 以及对需要多个服务器之间协调的请求（写请求）使用的一致性协议(<code>Atomic Broadcast</code>), 数据将保存在一个内存数据库中, 其包含包含完整的树结构。</p><p>其处理请求的逻辑如下：</p><ul><li><strong>写请求</strong>：需要协调的请求，将通过一致性协议来确保所有服务器都同意状态变更。之后，服务器将更改提交到 <code>ZooKeeper</code> 数据库，该数据库在整个集群的所有服务器之间完全复制。</li><li><strong>读请求</strong>：不需要协调的请求，服务器将直接从本地数据库读取状态并生成响应。</li></ul><h2 id="3-2-Request-Processor"><a href="#3-2-Request-Processor" class="headerlink" title="3.2 Request Processor"></a>3.2 <code>Request Processor</code></h2><p>在 <code>ZooKeeper</code> 的实现中，请求处理器（<code>Request Processor</code>）是负责处理客户端发来的写请求并将其转换为事务的组件。其实现包含了如下特性:</p><ol><li><p><strong>原子性消息层</strong>：<code>ZooKeeper</code> 的消息层是原子性的，这保证了本地副本之间永远不会出现数据分歧。虽然在任何时候，一些服务器可能已经应用了更多的事务。</p></li><li><p><strong>幂等事务</strong>：与来自客户端的请求不同，事务是幂等的，意味着多次执行相同的事务不会改变系统的状态。</p></li><li><p><strong>事务生成</strong>：当<code>Leader</code>服务器接收到写请求时，它会计算出当写操作应用时系统的状态，并将其转换为捕获这种新状态的事务。</p></li><li><p><strong>计算未来状态</strong>：必须计算未来的状态，因为可能有尚未应用到数据库的未完成事务。这意味着，系统的当前状态可能不完全反映所有排队事务的结果。</p></li><li><p><strong>条件写操作</strong>：例如，如果客户端执行了一个条件 <code>setData</code> 操作，且请求中的版本号与更新中的 znode 的未来版本号匹配，那么服务会生成一个包含新数据、新版本号和更新时间戳的 <code>setDataTXN</code>。</p></li><li><p><strong>错误处理</strong>：如果出现错误，如版本号不匹配或待更新的 znode 不存在，则生成一个 <code>errorTXN</code>。这样的错误事务可以用于向客户端指示操作失败的原因。</p></li></ol><p>通过这种方式，请求处理器保证只有当写请求能够成功应用到数据库的未来状态时，才会生成并广播事务。这种设计允许 <code>ZooKeeper</code> 在保持一致性的同时，优化读写操作的处理效率。请求处理器的幂等性质也确保了即使在出现网络重试或其他重复操作的情况下，不会对系统状态产生意外的影响。</p><h2 id="3-3-内存数据库"><a href="#3-3-内存数据库" class="headerlink" title="3.3 内存数据库"></a>3.3 内存数据库</h2><p><code>ZooKeeper</code> 的每个副本都在内存中维护了一个 <code>ZooKeeper</code> 状态的副本。当服务恢复自崩溃时，它需要恢复这个内部状态。如果要通过重放所有已交付的消息来恢复状态，在服务运行一段时间后，这将花费过长时间，因此 <code>ZooKeeper</code> 使用周期性的快照，并且只需要重新交付自快照开始以来的消息。</p><p>快照在 <code>ZooKeeper</code> 中被称为“模糊快照”（<code>fuzzy snapshots</code>），因为在进行快照时，<code>ZooKeeper</code> 不会锁定状态。相反，它会进行一次深度优先扫描，原子性地读取每个 <code>znode</code> 的数据和元数据，并将它们写入磁盘。由于在生成快照期间可能已经应用了一部分状态变更，所以得到的模糊快照可能不对应于 <code>ZooKeeper</code> 在任何时间点的状态。然而，由于状态变更是幂等的，我们可以重复应用它们，只要我们按照顺序应用这些状态变更。</p><h2 id="3-4-Client和Server的交互"><a href="#3-4-Client和Server的交互" class="headerlink" title="3.4 Client和Server的交互"></a>3.4 <code>Client</code>和<code>Server</code>的交互</h2><h3 id="3-4-1-写请求"><a href="#3-4-1-写请求" class="headerlink" title="3.4.1 写请求"></a>3.4.1 写请求</h3><p>在<code>ZooKeeper</code>中，写请求的处理过程是为了确保系统的一致性和数据的同步。这里详细说明写请求的处理：</p><ol><li><p><strong>写请求的提交</strong></p><ol><li><p><strong>客户端发起写请求</strong>：客户端向其连接的<code>ZooKeeper</code>服务器（可能是任何一个<code>follower</code>或者<code>leader</code>）发出一个写请求。</p></li><li><p><strong>请求转发至Leader</strong>：如果客户端连接的不是<code>leader</code>节点，该请求将被转发到<code>leader</code>节点。<code>ZooKeeper</code>集群中的所有写请求都必须由<code>leader</code>节点来协调。</p></li><li><p><strong>Leader预处理请求</strong>：<code>leader</code>节点接收到写请求后，它会为该请求分配一个全局唯一的事务ID，称为<code>zxid</code>。这个ID体现了写请求的顺序，保证了事务的处理顺序与到达顺序相同。</p></li><li><p><strong>提议（Proposal）</strong>：<code>leader</code>节点根据写请求创建一个提议（<code>proposal</code>）并将该提议发送给所有的<code>follower</code>节点。</p></li><li><p><strong>投票（Voting）</strong>：每个<code>follower</code>节点接收到提议后，会进行投票。如果<code>follower</code>节点同意该提议，它将发送一个“赞成”投票给<code>leader</code>。</p></li><li><p><strong>确认（Acknowledge）</strong>：<code>leader</code>节点收集足够多的“赞成”投票（超过半数的<code>follower</code>节点）后，该提议被认为是已经被接受。</p></li></ol></li><li><p><strong>写请求的执行</strong></p><ol><li><p><strong>提交（Commit）</strong>：一旦提议被接受，<code>leader</code>节点会发送一个提交消息给所有<code>follower</code>节点，指示它们将该写操作应用到它们的本地存储。</p></li><li><p><strong>本地写入</strong>：每个<code>follower</code>节点接收到提交消息后，将写操作应用到它们的本地副本上。</p></li><li><p><strong>响应客户端</strong>：写操作被成功应用到数据存储后，每个服务器（包括<code>leader</code>和<code>follower</code>）都会向发起写请求的客户端发送响应，告知写操作已经成功完成。</p></li></ol></li><li><p><strong>写请求的监视（<code>Watches</code>）和通知</strong></p><ol><li><p><strong>设置监视</strong>：客户端可以在节点上设置监视（<code>watch</code>），这样当该节点发生变化时，客户端会收到通知。</p></li><li><p><strong>通知过程</strong>：当写请求导致节点发生变化时（例如数据更新、节点创建或删除等），<code>ZooKeeper</code>服务器会触发监视事件，并向设置了监视的客户端发送通知。</p></li></ol></li></ol><p>通过上述步骤，<code>ZooKeeper</code>保障了写请求的顺序性、一致性和可靠性。此外，通过要求写操作在大多数节点上被提交，<code>ZooKeeper</code>还确保了数据的持久性和容错性。这些是<code>ZooKeeper</code>作为分布式协调服务的核心特性。</p><h3 id="3-4-2-读请求"><a href="#3-4-2-读请求" class="headerlink" title="3.4.2 读请求"></a>3.4.2 读请求</h3><p><strong>从服务视角看读请求</strong>:</p><ol><li>读请求在每个服务器本地处理，不需要磁盘活动或运行共识协议。</li><li>每个读请求都会被标记一个<code>zxid</code>（<code>ZooKeeper</code>事务ID），该ID指示服务器看到的最后一次事务，为读请求相对于写请求定义了部分顺序。</li><li>本地处理读取请求确保了极好的性能，因为这只是在本地服务器上的内存操作。</li></ol><p><strong>从<code>log</code>的视角看读请求</strong>:</p><p>如果<code>client</code>以某种顺序读某个数据, 那么读请求需要在<code>Log</code>的某个特定的点执行, 并且后续的读请求只允许在第一个读请求对应的<code>Log</code>位置或者更后的位置执行。</p><p>但是如果出现了故障呢? <code>client</code>在一个副本执行了一个读请求并看到了对应于<code>Log</code>中这个点的状态, 此后副本故障了, <code>client</code>切换到了一个新的副本并且发起了另一个读请求, 在新的副本的读请求，必须在之前读请求对应的<code>Log</code>点或者之后的点执行。如何实现呢? </p><p>答案是, 每个<code>Log</code>条目都会被<code>Leader</code>打上<code>zxid</code>的标签，这些标签就是<code>Log</code>对应的条目号。任何时候一个副本回复一个<code>client</code>的读请求，首先这个读请求是在<code>Log</code>的某个特定点执行的，其次回复里面会带上<code>zxid</code>，对应的就是<code>Log</code>中执行点的前一条<code>Log</code>条目号。<code>client</code>会记住最高的<code>zxid</code>，当<code>client</code>发出一个请求到一个相同或者不同的副本时，它会在它的请求中带上这个最高的<code>zxid</code>。这样，其他的副本就知道，应该至少在<code>Log</code>中这个点或者之后执行这个读请求。</p><blockquote><p>如果第二个副本并没有最新的<code>Log</code>，当它从<code>client</code>收到一个请求，<code>client</code>说，上一次我的读请求在其他副本Log的这个位置执行。那么在获取到对应这个位置的Log之前，这个副本不能响应客户端请求。</p></blockquote><h3 id="3-4-3-同步原语（Sync-Primitive）"><a href="#3-4-3-同步原语（Sync-Primitive）" class="headerlink" title="3.4.3 同步原语（Sync Primitive）"></a>3.4.3 同步原语（Sync Primitive）</h3><ul><li>对于需要最新读取信息的应用程序，<code>ZooKeeper</code>提供了<code>sync</code>原语。</li><li><code>sync</code>在领导者处理完所有挂起的写操作到其本地副本之后按顺序执行，并且是异步的。</li><li>为了获取最新的更新，客户端可以先调用<code>sync</code>然后再进行读操作，以确保读取反映了<code>sync</code>之前的任何更改。</li></ul><blockquote><p>实际上, 可以把<code>sync</code>看出空的写操作</p></blockquote><h3 id="3-4-4-实施细节"><a href="#3-4-4-实施细节" class="headerlink" title="3.4.4 实施细节"></a>3.4.4 实施细节</h3><ul><li>由于采用了基于领导者的算法，<code>sync</code>不需要原子广播；它只是在领导者和执行<code>sync</code>的服务器之间请求队列的末尾。</li><li>执行<code>sync</code>的服务器必须确信领导者仍然是领导者；否则，领导者会在排序<code>sync</code>之前发出一个空事务来提交。</li><li>系统设计避免在领导者负载下产生额外的广播流量，并通过超时设置来防止不必要的空事务。</li></ul><h3 id="3-4-5-客户端会话管理"><a href="#3-4-5-客户端会话管理" class="headerlink" title="3.4.5 客户端会话管理"></a>3.4.5 客户端会话管理</h3><ul><li><code>ZooKeeper</code>服务器以FIFO顺序处理客户端请求，响应包括它们相对的<code>zxid</code>。</li><li>无活动期间发送的心跳消息包括客户端连接的服务器所看到的最后一个<code>zxid</code>。</li><li>如果客户端连接到新服务器，服务器通过比较<code>zxid</code>来确保其视图至少像客户端的视图一样最新。</li><li>客户端可以确保找到一个具有系统最新视图的服务器，因为它们只看到已经复制到<code>ZooKeeper</code>服务器多数的更改，确保了持久性。</li></ul><h3 id="3-4-6-会话失败和超时"><a href="#3-4-6-会话失败和超时" class="headerlink" title="3.4.6 会话失败和超时"></a>3.4.6 会话失败和超时</h3><ul><li><code>ZooKeeper</code>使用超时来检测客户端会话失败；如果在会话超时期间没有服务器收到客户端的任何消息，则假定会话失败。</li><li>在活动低时期或在没有通信的足够时间过去后，客户端会发送心跳消息来避免会话超时。</li><li>客户端库在会话空闲时间达到会话超时的三分之一后发送心跳，并在超过会话超时的三分之二时间内没有从服务器收到消息时切换到新服务器。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本次课程介绍了&lt;code&gt;ZooKeeper&lt;/code&gt;, 并且我结合教授的课程和原论文总结了&lt;code&gt;ZooKeeper&lt;/code&gt;的关键知识点形成了本文&lt;/p&gt;
&lt;p&gt;课程主页: &lt;a href=&quot;https://pdos.csail.mit.edu/6.824/</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="ZooKeeper" scheme="http://example.com/tags/ZooKeeper/"/>
    
  </entry>
  
</feed>
