<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ToniBlog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-03-11T12:44:16.234Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>ToniXWD</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C/C++面经整理-1</title>
    <link href="http://example.com/2024/03/11/C++/C++%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86-1/"/>
    <id>http://example.com/2024/03/11/C++/C++%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86-1/</id>
    <published>2024-03-11T11:40:36.000Z</published>
    <updated>2024-03-11T12:44:16.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-如果类的数据成员不包含指针-是否可以使用memcmp逐字节比较2个对象"><a href="#1-如果类的数据成员不包含指针-是否可以使用memcmp逐字节比较2个对象" class="headerlink" title="1 如果类的数据成员不包含指针, 是否可以使用memcmp逐字节比较2个对象?"></a>1 如果类的数据成员不包含指针, 是否可以使用<code>memcmp</code>逐字节比较2个对象?</h2><p>不可以, 原因如下:</p><ol><li><p><strong>虚函数表指针</strong>：如果对象是多态的，即它有虚函数，它可能包含一个指向虚函数表的隐藏指针（通常称为 vptr）。由于虚函数表的地址可能因为对象的创建方式不同而不同（比如通过不同的派生类创建基类的对象），这会导致 <code>memcmp</code> 认为对象不相等，即使它们在逻辑上是相同的。</p></li><li><p><strong>填充字节和对齐</strong>：为了满足特定的对齐要求，编译器可能在对象的内存布局中插入填充字节。这些填充字节的值是未定义的，并且可能在不同的对象或相同对象的不同实例之间有所不同，导致 <code>memcmp</code> 返回不匹配的结果。</p></li><li><p><strong>浮点成员</strong>：对于包含浮点数成员的对象，浮点数的二进制表示可能会有多种，即使它们代表的是相同的值。例如，NaN（非数）有多种不同的二进制表示。</p></li></ol><h2 id="2-用-memset-this-0-sizeof-this-来将一个类对象的所有数据成员初始化为0-不考虑指针的正确性-是否正确"><a href="#2-用-memset-this-0-sizeof-this-来将一个类对象的所有数据成员初始化为0-不考虑指针的正确性-是否正确" class="headerlink" title="2 用 memset(this,0,sizeof(*this)) 来将一个类对象的所有数据成员初始化为0(不考虑指针的正确性), 是否正确?"></a>2 用 <code>memset(this,0,sizeof(*this))</code> 来将一个类对象的所有数据成员初始化为0(不考虑指针的正确性), 是否正确?</h2><p>不可以, 原因如下:</p><ol><li><p><strong>虚函数表</strong>：如果类中有虚函数，那么对象内存布局中会有一个指向虚函数表的指针（<code>vptr</code>）。使用 <code>memset</code> 清零会破坏这个指针，使得后续对虚函数的调用成为未定义行为。</p></li><li><p><strong>非标准布局</strong>：对于非标准布局的类型，成员可能不是连续存储的，<code>memset</code> 可能会覆盖成员之间的间隙，这些间隙可能由编译器用于内部目的或对齐。</p></li></ol><h2 id="3-实现一个引用计数的智能指针"><a href="#3-实现一个引用计数的智能指针" class="headerlink" title="3 实现一个引用计数的智能指针"></a>3 实现一个引用计数的智能指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">RefPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">RefPtr</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span> : ptr_(ptr), count_(new size_t(<span class="number">1</span>)) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果传入的是空指针，则将引用计数设置为0</span></span><br><span class="line">      *count_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 复制构造函数</span></span><br><span class="line">  <span class="built_in">RefPtr</span>(<span class="type">const</span> RefPtr &amp;other) : <span class="built_in">ptr_</span>(other.ptr_), <span class="built_in">count_</span>(other.count_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">      <span class="comment">// 如果指针非空，则增加引用计数</span></span><br><span class="line">      ++(*count_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 赋值运算符</span></span><br><span class="line">  RefPtr &amp;<span class="keyword">operator</span>=(<span class="type">const</span> RefPtr &amp;other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123; <span class="comment">// 防止自赋值</span></span><br><span class="line">      <span class="comment">// 减少当前对象的引用计数，如果变为0，则删除</span></span><br><span class="line">      <span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 复制数据</span></span><br><span class="line">      ptr_ = other.ptr_;</span><br><span class="line">      count_ = other.count_;</span><br><span class="line">      <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        <span class="comment">// 如果指针非空，则增加引用计数</span></span><br><span class="line">        ++(*count_);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  ~<span class="built_in">RefPtr</span>() &#123; <span class="built_in">release</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重载解引用操作符</span></span><br><span class="line">  T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重载箭头操作符</span></span><br><span class="line">  T *<span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取原始指针</span></span><br><span class="line">  <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T *ptr_;        <span class="comment">// 指向被引用计数管理的对象</span></span><br><span class="line">  <span class="type">size_t</span> *count_; <span class="comment">// 引用计数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr_ &amp;&amp; --(*count_) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> ptr_;</span><br><span class="line">      <span class="keyword">delete</span> count_;</span><br><span class="line">      ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">      count_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Test created\n&quot;</span>; &#125;</span><br><span class="line">  ~<span class="built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Test destroyed\n&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello, world!\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">RefPtr&lt;Test&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> Test())</span></span>; <span class="comment">// 创建一个Test对象</span></span><br><span class="line">  &#123;</span><br><span class="line">    RefPtr&lt;Test&gt; ptr2 = ptr1; <span class="comment">// 使用复制构造函数</span></span><br><span class="line">    ptr2-&gt;<span class="built_in">greet</span>();</span><br><span class="line">  &#125; <span class="comment">// ptr2超出作用域，但Test对象不会被删除，因为ptr1还在引用它</span></span><br><span class="line">  ptr1-&gt;<span class="built_in">greet</span>();</span><br><span class="line">&#125; <span class="comment">// ptr1超出作用域，Test对象将被删除</span></span><br></pre></td></tr></table></figure><h2 id="4-C-有哪些避免内存泄漏的手段"><a href="#4-C-有哪些避免内存泄漏的手段" class="headerlink" title="4 C++有哪些避免内存泄漏的手段?"></a>4 C++有哪些避免内存泄漏的手段?</h2><p>在 C++ 中防止内存泄露可以从编写代码的风格和习惯入手，同时还可以使用各种工具来帮助检测和分析内存泄露。以下是一些方法和工具：</p><h3 id="编写代码时的手段："><a href="#编写代码时的手段：" class="headerlink" title="编写代码时的手段："></a>编写代码时的手段：</h3><ol><li><p><strong>智能指针</strong>：避免裸指针, 使用 C++11 引入的智能指针（如 <code>std::unique_ptr</code>, <code>std::shared_ptr</code> 和 <code>std::weak_ptr</code>）可以帮助自动管理内存。这些智能指针通过自动调用析构函数来释放内存，从而减少内存泄露的风险。</p></li><li><p><strong>对象资源管理（RAII）</strong>：遵循资源获取即初始化 (RAII) 原则，资源在对象构造时获得，在析构时释放。这样可以确保在对象生命周期结束时资源总是被正确地释放。</p></li></ol><h3 id="工具分析："><a href="#工具分析：" class="headerlink" title="工具分析："></a>工具分析：</h3><ol><li><p><strong>静态分析工具</strong>：使用静态分析工具，如 <code>Clang Static Analyzer</code>, <code>Coverity, Cppcheck</code> 等，可以在编译时检测潜在的内存泄露问题。</p></li><li><p><strong>动态分析工具</strong>：动态分析工具在运行时分析程序的行为。这些工具包括：</p><ul><li><strong>Valgrind</strong>：一个广泛使用的 Linux 工具，能够检测内存泄露、缓冲区溢出等问题。</li><li><strong>AddressSanitizer</strong>：一个快速的内存错误检测器，可以检测出各种内存访问错误，集成在 LLVM&#x2F;Clang 和 GCC 编译器中。</li><li><strong>Dr. Memory</strong>：是一个适用于 Windows 和 Linux 的内存监视工具，功能类似于 Valgrind。</li></ul></li></ol><h2 id="5-Valgrind和Gdb的原理是什么"><a href="#5-Valgrind和Gdb的原理是什么" class="headerlink" title="5 Valgrind和Gdb的原理是什么?"></a>5 <code>Valgrind</code>和<code>Gdb</code>的原理是什么?</h2><h3 id="Valgrind-的实现原理"><a href="#Valgrind-的实现原理" class="headerlink" title="Valgrind 的实现原理"></a>Valgrind 的实现原理</h3><ol><li><p><strong>代码拦截和重编译</strong>：Valgrind 通过接管程序的执行来运行一种虚拟 CPU。当程序运行时，Valgrind 不直接执行原始的二进制代码，而是将其翻译成 Valgrind 自己的中间代码（VEX IR），这个过程称为动态重编译或即时（JIT）重编译。</p></li><li><p><strong>中间表示（IR）</strong>：程序的机器代码被翻译成 Valgrind 自己的中间表示形式，这种中间表示与具体的机器代码和处理器架构无关。</p></li><li><p><strong>仪器化</strong>：在将程序代码翻译成中间表示之后，Valgrind 插入额外的检查代码来仪器化原始代码，以便在运行时分析程序的行为。例如，Memcheck 会添加用于检测非法内存访问和内存泄漏的检查。</p></li><li><p><strong>运行时监控</strong>：Valgrind 的工具（如 Memcheck）会监控程序的所有内存访问行为，包括对栈（stack）、堆（heap）和静态&#x2F;全局数据的读写。通过这种监控，工具能够检测出内存错误。</p></li><li><p><strong>性能损失</strong>：由于 Valgrind 对程序进行了重编译和仪器化，这导致了很大的性能开销，使得程序运行速度比正常慢很多倍。</p></li></ol><h3 id="GDB-的实现原理"><a href="#GDB-的实现原理" class="headerlink" title="GDB 的实现原理"></a>GDB 的实现原理</h3><p>GDB 是一个源代码级调试器，用于定位和解决程序中的错误。GDB 的实现原理包括以下几个方面：</p><ol><li><p><strong>符号表解析</strong>：GDB 利用程序编译时产生的调试信息（如 DWARF 或 stabs），这些信息包含了原始源代码中变量、函数、行号等与编译后的机器指令之间的映射。</p></li><li><p><strong>进程控制和监视</strong>：GDB 使用操作系统提供的进程控制接口（例如 Linux 上的 <code>ptrace</code> 系统调用）来监视和控制目标程序的执行。通过这些接口，GDB 可以在特定的执行点停止程序，单步执行，检查和修改内存或寄存器的内容等。</p></li><li><p><strong>断点和观察点</strong>：GDB 实现断点功能通常是通过修改目标程序的内存，将要断点的位置替换为触发异常或中断的指令，从而在程序执行到该位置时暂停执行。</p></li><li><p><strong>堆栈检查</strong>：当程序暂停执行时，GDB 能够检查并显示当前的调用堆栈，包括每个堆栈帧中的参数、局部变量等。</p></li><li><p><strong>信号处理</strong>：GDB 可以捕获和处理目标程序接收到的信号，允许调试器在异常情况下控制程序的行为。</p></li><li><p><strong>远程调试</strong>：GDB 支持远程调试协议，允许开发者通过网络在一台机器上运行 GDB 服务器，而在另一台机器上运行 GDB 客户端来调试程序。</p></li></ol><h3 id="GDB是如何暂停程序执行的"><a href="#GDB是如何暂停程序执行的" class="headerlink" title="GDB是如何暂停程序执行的?"></a><code>GDB</code>是如何暂停程序执行的?</h3><p>在类 Unix 系统（如 Linux）上，GDB 通常使用 <code>ptrace</code> 系统调用来控制和监视另一个进程。以下是 GDB 暂停程序执行的一般步骤：</p><ol><li><p><strong>断点设置</strong>：GDB 设置断点时，会在目标位置替换一条指令（比如 x86 架构上的 <code>INT 3</code> 指令，它对应的字节码为 <code>0xCC</code>），这是一条会触发中断的机器指令。</p></li><li><p><strong>信号接收</strong>：当程序执行到这个位置时，处理器执行 <code>INT 3</code> 指令，导致操作系统生成一个 SIGTRAP 信号发送给程序。GDB 通过 <code>ptrace</code> 被告知这一信号。</p></li><li><p><strong>程序暂停</strong>：程序收到 SIGTRAP 信号后，默认行为是暂停执行（如果没有调试器，它可能会终止）。GDB 接管这个信号，转而进入调试器的控制下。</p></li><li><p><strong>用户交互</strong>：此时，GDB 可以显示当前的断点信息、堆栈、寄存器状态等，并等待用户输入进一步的调试命令，如单步执行、继续执行等。</p></li><li><p><strong>控制恢复</strong>：用户完成调试命令后，GDB 会通过 <code>ptrace</code> 控制程序继续执行，直至下一个断点或程序结束。</p></li></ol><p>在整个过程中，GDB 没有锁定任何内存页。它是通过中断和信号处理机制来暂停程序执行的。锁定内存页通常是指防止内存页被交换出物理内存（即交换到磁盘上），而这与 GDB 的暂停机制不同。</p><h3 id="GDB是如何获取调试进程的内存布局的"><a href="#GDB是如何获取调试进程的内存布局的" class="headerlink" title="GDB是如何获取调试进程的内存布局的?"></a><code>GDB</code>是如何获取调试进程的内存布局的?</h3><p>不同进程的页表和地址空间是不同的。操作系统为每个进程维护一个独立的虚拟地址空间，并通过页表将这些虚拟地址映射到物理内存地址。这是现代操作系统用于内存隔离和保护的基本机制。</p><p>当使用 GDB 调试一个进程时，GDB 实际上是在调试器进程的上下文中运行，而它需要访问和控制另一个进程的内存和状态。这是通过 <code>ptrace</code> 系统调用实现的。<code>ptrace</code> 允许一个进程（调试器）来观察和控制另一个进程（被调试的目标进程），并可以读取和写入目标进程的内存，读取其寄存器状态，以及改变执行流等。</p><p>当 GDB 使用 <code>ptrace</code> 来获取目标进程的堆栈内存信息时，它会进行如下步骤：</p><ol><li><p><strong>附加到进程</strong>：GDB 通过 <code>ptrace(PTRACE_ATTACH, ...)</code> 调用附加到目标进程。目标进程会被暂停，直到 GDB 发出进一步的指令。</p></li><li><p><strong>读取内存</strong>：当目标进程被 GDB 控制之后，GDB 可以使用 <code>ptrace</code> 的 <code>PTRACE_PEEKTEXT</code>、<code>PTRACE_PEEKDATA</code> 或类似的请求来读取进程的内存空间。操作系统会处理地址转换，允许 GDB 从调试器进程的上下文中以安全的方式访问目标进程的虚拟内存。</p></li><li><p><strong>获取堆栈信息</strong>：GDB 可以根据当前寄存器的状态（特别是堆栈指针寄存器）来获取堆栈的内容。GDB 知道如何解析目标进程的内存布局，它可以找到堆栈的位置，并读取堆栈上的内容。</p></li><li><p><strong>恢复执行</strong>：调试操作完成后，GDB 可以使用 <code>ptrace(PTRACE_DETACH, ...)</code> 来解除对目标进程的控制，允许它继续执行。</p></li></ol><p><code>ptrace</code> 提供的功能非常强大，它是许多调试器和系统监视工具的底层基础。通过操作系统提供的这些机制，调试器能够安全地访问和控制其他进程的地址空间，而不需要直接操作页表。这保证了系统的稳定性和安全性。</p><h2 id="6-如何自己实现一个malloc和free-来检查内存泄漏"><a href="#6-如何自己实现一个malloc和free-来检查内存泄漏" class="headerlink" title="6 如何自己实现一个malloc和free, 来检查内存泄漏?"></a>6 如何自己实现一个malloc和free, 来检查内存泄漏?</h2><h4 id="自定义-malloc-称为-my-malloc"><a href="#自定义-malloc-称为-my-malloc" class="headerlink" title="自定义 malloc (称为 my_malloc)"></a>自定义 <code>malloc</code> (称为 <code>my_malloc</code>)</h4><ol><li><strong>记录分配信息</strong>：为每次分配创建一个记录，包含分配的大小、分配的地址、调用 <code>my_malloc</code> 的文件和行号（通常通过宏传递）。</li><li><strong>管理记录</strong>：在一个<strong>红黑树</strong>或<strong>哈希表</strong>(按照地址排序)(如果不考虑效率, 可以使用链表来简化)中维护这些记录，以便可以追踪所有分配。</li><li><strong>分配内存</strong>：实际分配所请求的内存，可能需要额外的空间来存储管理信息（如大小和可能的魔数&#x2F;哨兵值，用于检测缓冲区溢出）。</li><li><strong>返回内存</strong>：返回指向分配内存的指针（注意偏移，如果在内存块前面存储了管理信息）。</li></ol><h4 id="自定义-free-称为-my-free"><a href="#自定义-free-称为-my-free" class="headerlink" title="自定义 free (称为 my_free)"></a>自定义 <code>free</code> (称为 <code>my_free</code>)</h4><ol><li><strong>查找记录</strong>：在释放内存之前，查找对应的分配记录。</li><li><strong>记录移除</strong>：从追踪数据结构中移除相应的分配记录。</li><li><strong>释放内存</strong>：释放相关的内存块。</li><li><strong>错误检查</strong>：如果释放了未知的或已经释放的内存，记录错误信息。</li></ol><h4 id="检测内存泄漏"><a href="#检测内存泄漏" class="headerlink" title="检测内存泄漏"></a>检测内存泄漏</h4><ol><li><strong>程序结束时</strong>：在程序结束时，遍历的内存分配记录数据结构。</li><li><strong>报告泄漏</strong>：对于任何仍然存在的记录，报告内存泄漏，包括分配的大小和分配时的位置（文件和行号）。</li><li><strong>清理记录</strong>：清理剩余的内存分配记录，以防程序正常退出时的内存泄漏。</li></ol><h3 id="进一步需求"><a href="#进一步需求" class="headerlink" title="进一步需求:"></a>进一步需求:</h3><p>实际中刚申请的内存没有释放是常见的, 但很久以前申请的内存还没有释放的危害是很大的, 在之前自定义的malloc中, 如何设法追踪很久以前分配的内存?</p><ol><li><p><strong>建立数据结构</strong>：</p><ul><li>一个大根堆（优先队列），按照时间戳排序。</li><li>一个红黑树或哈希表，用于存储当前所有的内存分配记录。</li></ul></li><li><p><strong>自定义 <code>malloc</code>（<code>my_malloc</code>）</strong>：</p><ul><li>每次分配内存时，创建一个包含时间戳、分配的大小、分配的地址等信息的记录节点。</li><li>将记录节点插入到红黑树或哈希表中，以便快速查找和删除操作。</li><li>创建一个包含时间戳和指向红黑树或哈希表中相应记录节点的指针的堆节点。</li><li>将堆节点插入到大根堆中。如果大根堆达到了固定容量，移除堆顶元素</li><li>返回分配的内存地址给调用者。</li></ul></li><li><p><strong>自定义 <code>free</code>（<code>my_free</code>）</strong>：</p><ul><li>释放内存时，使用传入的指针在红黑树或哈希表中查找对应的记录节点。</li><li>在找到记录节点后，删除红黑树或哈希表中的记录。</li><li>同时在大根堆中查找对应的堆节点并删除（<strong>从堆中查找数据可能比较复杂, 这里可以在红黑树的节点中再添加一个指向堆数据的指针来加速</strong>）。</li></ul></li><li><p><strong>检查内存泄漏</strong>：</p><ul><li>可以通过检查大根堆的内容来确定最旧的内存分配记录。</li><li>如果大根堆的堆顶元素（即最旧的内存分配记录）超出了设定的阈值，那么这可能表明存在内存泄漏。</li><li>可以设定定期检查或者根据特定事件（如内存分配请求）来触发检查。</li></ul></li><li><p><strong>内存分配记录的清理</strong>：</p><ul><li>确保在程序退出时清理所有内存分配记录，包括红黑树或哈希表和大根堆中的记录，以避免退出时造成的内存泄漏。</li></ul></li></ol><h2 id="7-虚函数表会不会占用sizeof的内存大小输出"><a href="#7-虚函数表会不会占用sizeof的内存大小输出" class="headerlink" title="7 虚函数表会不会占用sizeof的内存大小输出?"></a>7 虚函数表会不会占用<code>sizeof</code>的内存大小输出?</h2><p>会, 例如下面的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> _a) : <span class="built_in">a</span>(_a) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">int</span> &amp;<span class="title">get_a</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl; &#125;</span><br></pre></td></tr></table></figure><p>64位机器上输出是16, 是因为：</p><ul><li><code>int</code>类型的成员变量<code>a</code>占用4字节。</li><li>虚函数表指针（vptr）占用8字节。</li><li>为了内存对齐，编译器添加了额外的4字节的填充。</li></ul><p>这样，类<code>A</code>的总大小就是16字节。实际的内存布局和对齐方式可能因编译器的实现细节（如内存对齐策略）而异，但上述解释是大多数情况下的通常原因。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-如果类的数据成员不包含指针-是否可以使用memcmp逐字节比较2个对象&quot;&gt;&lt;a href=&quot;#1-如果类的数据成员不包含指针-是否可以使用memcmp逐字节比较2个对象&quot; class=&quot;headerlink&quot; title=&quot;1 如果类的数据成员不包含指针, 是</summary>
      
    
    
    
    <category term="C++随笔" scheme="http://example.com/categories/C-%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="面经" scheme="http://example.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.5840(6.824) Lab4: 分片KV数据库 4A</title>
    <link href="http://example.com/2024/03/03/MIT6.5840/lab4A/"/>
    <id>http://example.com/2024/03/03/MIT6.5840/lab4A/</id>
    <published>2024-03-03T02:10:46.000Z</published>
    <updated>2024-03-03T03:09:14.176Z</updated>
    
    <content type="html"><![CDATA[<p><em>最新的更新在博客 <a href="https://tonixwd.github.io/">ToniBlog</a></em></p><p>本文将介绍<code>lab4A</code>部分的实现, <code>lab4A</code>要求实现分片控制器, 其实就是<code>lab3</code>的翻版, 基本上可以照搬<code>lab3</code>。如果仅仅是为了通过测试，<code>lab4A</code>倒是极其简单，只需要每次更新<code>Group</code>后随机完成<code>Shard</code>的映射就好了, 但还要考虑将配置项的改动最小话, 还是有一些坑的。</p><p><code>Lab</code>文档见: <a href="http://nil.csail.mit.edu/6.5840/2023/labs/lab-shard.html">http://nil.csail.mit.edu/6.5840/2023/labs/lab-shard.html</a></p><p>我的代码: <a href="https://github.com/ToniXWD/MIT6.5840/tree/lab4A">https://github.com/ToniXWD/MIT6.5840/tree/lab4A</a></p><h1 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1 项目结构"></a>1 项目结构</h1><p>分片数据库的组成结构是：1个<code>controller</code> + 多个<code>replica groups</code>。<code>controller</code>将数据进行分片， 存储在不同的集群上， 每个集群都是一个<code>raft</code>集群, <code>controller</code>负责管理分片, 也就是管理配置项。<code>clients</code> 和 <code>servers</code> 都会询问 <code>controller</code> 最新的配置信息。 分片控制器需要具备如下的功能:</p><ol><li>为了负载均衡 -&gt; 能够迁移分片</li><li>需要处理请求和配置项更新几乎同时到达的情况</li><li>建议的实现: <code>raft</code>集群也要保存配置项</li><li>配置更新后, 新的负责某分片的<code>replica groups</code>需要从旧的<code>replica groups</code>复制旧分片</li></ol><p><code>Shard controller</code>使用下面的<code>RPC</code>来实现管理和查询:</p><ol><li><code>Join</code>:<ol><li>重新分片时尽量平均</li><li>重新分片时移动的分片尽量少</li><li>允许重用<code>GID</code></li></ol></li><li><code>Leave</code><ol><li>重新分片时尽量平均</li><li>重新分片时移动的分片尽量少</li></ol></li><li><code>Move</code><ol><li>将某个<code>shard</code>分配给某个<code>group</code></li></ol></li><li><code>Query</code> <ol><li>返回配置信息</li><li>必须反映在其之前做出的配置信息更改</li></ol></li></ol><p>主要的坑包括:</p><ol><li>需要滤除重复的<code>RPC</code>(照抄<code>lab3</code>即可)</li><li>执行碎片再平衡的状态机中的代码需要具有确定性(大坑)</li></ol><h1 id="2-实现思路"><a href="#2-实现思路" class="headerlink" title="2 实现思路"></a>2 实现思路</h1><p>由于我们的目标不仅仅是通过测例, 还需要完成下面2个目标:</p><ol><li>实现负载均衡<br> 实现负载均衡, 意味着所有的集群被映射的数量只差不能大于1(手动<code>Move</code>的情况除外), 因此需要对已经映射的集群号(<code>gid</code>)实现统计计数</li><li>最小化改动<br>新配置和旧配置之间的改动要最小化</li></ol><p>因此我的实现思路和逻辑如下:</p><h2 id="2-1-Join"><a href="#2-1-Join" class="headerlink" title="2.1 Join"></a>2.1 <code>Join</code></h2><ol><li>首先继承旧配置<code>lastConfig</code>创建新配置<code>newConfig</code></li><li>将要<code>Join</code>的<code>newGroups</code>追加到<code>newConfig.Groups</code>, 但需要注意下面的情况<ol><li><code>len(lastConfig.Groups) + len(newGroups) &lt;= NShards</code>, 此时无脑将<code>Join</code>的<code>newGroups</code>追加到<code>newConfig.Groups</code>即可</li><li><code>len(lastConfig.Groups) + len(newGroups) &gt; NShards</code>, 此时只需要将<code>newConfig.Groups</code>填充至<code>len(newConfig.Groups) == NShards</code>即可, 剩余的部分缓存起来, 记缓存区为<code>CachedGid</code></li></ol></li><li>统计<code>newConfig.Groups</code>中对<code>Shard</code>的映射次数, 映射次数最高的和映射次数最低的绝对值不能大于1, 由于新增了目前没有映射的<code>Join</code>的新集群, 此特性不可能满足, 因此需要:<ol><li>将目前对<code>Shard</code>的映射次数最少的<code>gid</code>剥夺一个映射, 被剥夺的这个映射本来是被映射到拥有<code>Shard</code>最多的一个<code>gid</code></li><li>更新映射次数统计信息, 直到映射次数最少的<code>gid</code>(也就是之前新加入的)大于等于映射平均值(<code>NShards / len(newConfig.Groups)</code>)即可</li></ol></li></ol><h2 id="2-2-Leave"><a href="#2-2-Leave" class="headerlink" title="2.2 Leave"></a>2.2 <code>Leave</code></h2><ol><li>首先继承旧配置<code>lastConfig</code>创建新配置<code>newConfig</code></li><li>从<code>newConfig.Groups</code>和<code>newConfig.CachedGid</code>中移除指定的<code>gid</code>(因为可能目前所有的<code>gid</code>数量大于<code>NShards</code>, 部分被暂存到了<code>CachedGid</code>), 被移除的<code>gid</code>在<code>newConfig.Shards</code>用0标记</li><li>如果<code>newConfig.CachedGid</code>还有剩余且<code>len(newConfig.Groups) &lt; NShards</code>, 将<code>newConfig.CachedGid</code>中的<code>gid</code>移动到<code>newConfig.Groups</code>使其填充满或者使<code>newConfig.CachedGid</code>为空</li><li>获取当前映射数量最少的<code>gid</code>的统计信息</li><li>在<code>newConfig.Shards</code>用0标记的位置用映射数量最少的<code>gid</code>代替, 每代替一次后需要重新统计</li></ol><h2 id="2-3-Move-Query"><a href="#2-3-Move-Query" class="headerlink" title="2.3 Move &amp;&amp; Query"></a>2.3 <code>Move &amp;&amp; Query</code></h2><p>这两个没啥坑, 就不说了</p><h1 id="3-易错点解析"><a href="#3-易错点解析" class="headerlink" title="3 易错点解析"></a>3 易错点解析</h1><ol><li><code>Go</code>的<code>map</code>的迭代顺序<br><code>Go</code>的<code>map</code>的迭代顺序是无序的, 即使其插入时的顺序和数据都是相同的, 但多次进行迭代, 其顺序不一致, 因此在多个副本上想保证确定性的话, 需要先对<code>map</code>的<code>key</code>获取切片并排序</li><li><code>gid</code>的数量和<code>NShards</code>的关系<br>由于每个<code>Shard</code>都会映射一个<code>gid</code>, 因此如果<code>gid</code>的数量大于<code>NShard</code>的话, 会存在有<code>gid</code>映射不到的情况, 这时我的处理是将其放到暂存区, 保证<code>Group</code>中的<code>gid</code>数量</li><li><code>map</code>的复制<br><code>Go</code>的<code>map</code>的复制是浅复制, 复制一个<code>map</code>时，只是复制了对底层数据结构的引用，而不是底层数据本身的副本。意味着如果在一个<code>map</code>中做出了改变（比如删除或添加键值对），这些改变会在所有对这个底层数据结构的引用中体现出来。因此，对原始<code>map</code>的修改会影响到复制后的<code>map</code>，因为它们都引用同一个数据结构。</li></ol><h1 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4 代码实现"></a>4 代码实现</h1><p>我自己实现的代码比较繁琐(很丑), 但逻辑其实很简单, 参见: <a href="https://github.com/ToniXWD/MIT6.5840/tree/lab4A">https://github.com/ToniXWD/MIT6.5840/tree/lab4A</a></p><h1 id="5-测试"><a href="#5-测试" class="headerlink" title="5 测试"></a>5 测试</h1><p><img src="/../../images/MIT6.5840/lab4A/lab4A-test.png" alt="lab4A-test"></p><p>此测试经过50次没有报错</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;最新的更新在博客 &lt;a href=&quot;https://tonixwd.github.io/&quot;&gt;ToniBlog&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;本文将介绍&lt;code&gt;lab4A&lt;/code&gt;部分的实现, &lt;code&gt;lab4A&lt;/code&gt;要求实现分片控制器, 其实就</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="Lab笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/Lab%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Go" scheme="http://example.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>清华大学开源操作系统训练营: rCore chapter4练习</title>
    <link href="http://example.com/2024/02/28/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/rCore-chapter4%E7%BB%83%E4%B9%A0/"/>
    <id>http://example.com/2024/02/28/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/rCore-chapter4%E7%BB%83%E4%B9%A0/</id>
    <published>2024-02-28T06:03:30.000Z</published>
    <updated>2024-02-27T07:16:12.372Z</updated>
    
    <content type="html"><![CDATA[<p><strong>练习实验书</strong>: <a href="https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter4/7exercise.html">https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter4/7exercise.html</a></p><p><strong>我的代码</strong>: <a href="https://github.com/LearningOS/2023a-rcore-ToniXWD">https://github.com/LearningOS/2023a-rcore-ToniXWD</a></p><h1 id="1-编程作业"><a href="#1-编程作业" class="headerlink" title="1 编程作业"></a>1 编程作业</h1><blockquote><blockquote><ol><li>重写 <code>sys_get_time</code> 和 <code>sys_task_info</code></li><li>实现 <code>mmap</code> 和 <code>munmap</code> 两个系统调用，通过所有测例</li></ol></blockquote></blockquote><h2 id="1-1-重写-sys-get-time-和-sys-task-info"><a href="#1-1-重写-sys-get-time-和-sys-task-info" class="headerlink" title="1.1 重写 sys_get_time 和 sys_task_info"></a>1.1 重写 <code>sys_get_time</code> 和 <code>sys_task_info</code></h2><p>这一部分的实现很简单, 引入虚拟内存和页表后无非就是内核无法直接使用系统调用传递的地址了, 需要将这个用户空间的虚拟地址做一层手动翻译, 这样的方法已经为我们提供了: <code>translated_struct_ptr</code>, 因此实现很简单:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_get_time</span>(_ts: *<span class="keyword">mut</span> TimeVal, _tz: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    trace!(<span class="string">&quot;kernel: sys_get_time&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">us</span> = <span class="title function_ invoke__">get_time_us</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ts</span> = <span class="title function_ invoke__">translated_struct_ptr</span>(<span class="title function_ invoke__">current_user_token</span>(), _ts);</span><br><span class="line">    *ts = TimeVal &#123;</span><br><span class="line">        sec: us / <span class="number">1_000_000</span>,</span><br><span class="line">        usec: us % <span class="number">1_000_000</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_task_info</span>(_ti: *<span class="keyword">mut</span> TaskInfo) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    trace!(<span class="string">&quot;kernel: sys_task_info NOT IMPLEMENTED YET!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ti</span> = <span class="title function_ invoke__">translated_struct_ptr</span>(<span class="title function_ invoke__">current_user_token</span>(), _ti);</span><br><span class="line"></span><br><span class="line">    *ti = TaskInfo &#123;</span><br><span class="line">        status: TaskStatus::Running,</span><br><span class="line">        syscall_times: <span class="title function_ invoke__">get_sys_call_times</span>(),</span><br><span class="line">        time: <span class="title function_ invoke__">get_task_run_times</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-实现-mmap-和-munmap"><a href="#1-2-实现-mmap-和-munmap" class="headerlink" title="1.2 实现 mmap 和 munmap"></a>1.2 实现 <code>mmap</code> 和 <code>munmap</code></h2><blockquote><blockquote><p><code>mmap</code> 在 <code>Linux</code> 中主要用于在内存中映射文件， 本次实验简化它的功能，仅用于申请内存</p></blockquote></blockquote><h3 id="1-2-1-MemorySet结构体"><a href="#1-2-1-MemorySet结构体" class="headerlink" title="1.2.1 MemorySet结构体"></a>1.2.1 <code>MemorySet</code>结构体</h3><p>由于<code>mmap</code>要在地址空间中添加新的映射, 因此无非就是在<code>MemorySet</code>中添加一块映射的内存区域, 先看看每个内存地址空间本来的结构:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// address space</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MemorySet</span> &#123;</span><br><span class="line">    page_table: PageTable,</span><br><span class="line">    areas: <span class="type">Vec</span>&lt;MapArea&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>areas</code>存放的是本地址空间的多个逻辑段, 每个逻辑段的地址是连续的, 但<code>mmap</code>是动态申请地址空间的, 多次调用会创建多哥不连续的内存区域, 因此不适合存放在<code>areas</code>, 因此创建一个新的成员存放:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// address space</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MemorySet</span> &#123;</span><br><span class="line">    page_table: PageTable,</span><br><span class="line">    areas: <span class="type">Vec</span>&lt;MapArea&gt;,</span><br><span class="line">    map_tree: BTreeMap&lt;VirtPageNum, FrameTracker&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>map_tree</code>还是<code>RAII</code>的思想, <code>munmap</code>调用时, 会将页帧从<code>map_tree</code>中释放, 触发<code>drop trait</code>使内存页分配器回收内存页</p><h3 id="1-2-2-MemorySet-mmap-MemorySet-unmmap"><a href="#1-2-2-MemorySet-mmap-MemorySet-unmmap" class="headerlink" title="1.2.2 MemorySet::mmap &amp;&amp; MemorySet::unmmap"></a>1.2.2 <code>MemorySet::mmap</code> &amp;&amp; <code>MemorySet::unmmap</code></h3><p>有了上述的数据结构, <code>mmap</code>时只需要调用<code>frame_alloc</code>分配一个新的内存页即可:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"><span class="comment">/// mmap</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mmap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, start: <span class="type">usize</span>, len: <span class="type">usize</span>, port: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">va_start</span>: VirtAddr = start.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="keyword">if</span> !va_start.<span class="title function_ invoke__">aligned</span>() &#123;</span><br><span class="line">        debug!(<span class="string">&quot;unmap fail don&#x27;t aligned&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">va_start</span>: VirtPageNum = va_start.<span class="title function_ invoke__">into</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">flags</span> = PTEFlags::<span class="title function_ invoke__">from_bits</span>(port <span class="keyword">as</span> <span class="type">u8</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">if</span> port &amp; <span class="number">0b0000_0001</span> != <span class="number">0</span> &#123;</span><br><span class="line">        flags |= PTEFlags::R;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> port &amp; <span class="number">0b0000_0010</span> != <span class="number">0</span> &#123;</span><br><span class="line">        flags |= PTEFlags::W;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> port &amp; <span class="number">0b0000_0100</span> != <span class="number">0</span> &#123;</span><br><span class="line">        flags |= PTEFlags::X;</span><br><span class="line">    &#125;</span><br><span class="line">    flags |= PTEFlags::U;</span><br><span class="line">    flags |= PTEFlags::V;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">va_end</span>: VirtAddr = (start + len).<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">va_end</span>: VirtPageNum = va_end.<span class="title function_ invoke__">ceil</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// println!(</span></span><br><span class="line">    <span class="comment">//     &quot;start = &#123;:x&#125; &amp;&amp; va_star = &#123;&#125; &amp;&amp; va_end = &#123;&#125;&quot;,</span></span><br><span class="line">    <span class="comment">//     start, va_start.0, va_end.0</span></span><br><span class="line">    <span class="comment">// );</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> va_start != va_end &#123;</span><br><span class="line">        <span class="comment">// println!(&quot;map va_start = &#123;&#125;&quot;, va_start.0);</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(pte) = <span class="keyword">self</span>.page_table.<span class="title function_ invoke__">translate</span>(va_start) &#123;</span><br><span class="line">            <span class="keyword">if</span> pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">                <span class="comment">// println!(&quot;mmap found exit va_start &#123;&#125;&quot;, va_start.0);</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(ppn) = <span class="title function_ invoke__">frame_alloc</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.page_table.<span class="title function_ invoke__">map</span>(va_start, ppn.ppn, flags);</span><br><span class="line">            <span class="keyword">self</span>.map_tree.<span class="title function_ invoke__">insert</span>(va_start, ppn);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        va_start.<span class="title function_ invoke__">step</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unmmap</code>则更简单, 从<code>map_tree</code>中删除即可, 这会自动触发<code>drop trait</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"><span class="comment">/// unmap</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmmap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, start: <span class="type">usize</span>, len: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">va_start</span>: VirtAddr = start.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="keyword">if</span> !va_start.<span class="title function_ invoke__">aligned</span>() &#123;</span><br><span class="line">        debug!(<span class="string">&quot;unmap fail don&#x27;t aligned&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">va_start</span>: VirtPageNum = va_start.<span class="title function_ invoke__">into</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">va_end</span>: VirtAddr = (start + len).<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">va_end</span>: VirtPageNum = va_end.<span class="title function_ invoke__">ceil</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> va_start != va_end &#123;</span><br><span class="line">        <span class="comment">// println!(&quot;unmap va_start = &#123;&#125;&quot;, va_start.0);</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(item) = <span class="keyword">self</span>.page_table.<span class="title function_ invoke__">translate</span>(va_start) &#123;</span><br><span class="line">            <span class="keyword">if</span> !item.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">                debug!(<span class="string">&quot;unmap on no map vpn&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.page_table.<span class="title function_ invoke__">unmap</span>(va_start);</span><br><span class="line">        <span class="keyword">self</span>.map_tree.<span class="title function_ invoke__">remove</span>(&amp;va_start);</span><br><span class="line">        va_start.<span class="title function_ invoke__">step</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-简答作业"><a href="#2-简答作业" class="headerlink" title="2 简答作业"></a>2 简答作业</h1><h2 id="2-1-请列举-SV39-页表页表项的组成，描述其中的标志位有何作用？"><a href="#2-1-请列举-SV39-页表页表项的组成，描述其中的标志位有何作用？" class="headerlink" title="2.1 请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？"></a>2.1 请列举 <code>SV39</code> 页表页表项的组成，描述其中的标志位有何作用？</h2><p><img src="/../../../images/LearningOS/ch4-translate.png" alt="ch4-translate"></p><p>如上图所示, 每个页表项是<code>PPN</code> + <code>Flags</code>组成, <code>PPN</code>指向下一级页表的物理页地址, <code>Flags</code>为各种标志位:</p><ul><li><strong>V</strong>: 页表项是否有效</li><li><strong>R&#x2F;W&#x2F;X</strong>: 控制对应页是否具有读、写、执行权限。这些权限位为操作系统实现内存保护提供了机制。</li><li><strong>U</strong>: 控制页的访问级别，标明用户空间是否可以访问。</li><li><strong>G</strong>: 全局位用于性能优化，它允许某些页表项在多个上下文之间共享，减少TLB刷新。</li><li><strong>A&#x2F;D</strong>: 访问和脏位用于页面替换策略，帮助操作系统确定哪些页面是活跃的，哪些页面可以被换出内存。</li><li><strong>RSW</strong>: 保留位， 留给自定义的实现， 常用于实现<strong>COW</strong>写时复制，用于实现<code>fork</code>系统调用时的内存效率优化。</li></ul><h2 id="2-2-缺页"><a href="#2-2-缺页" class="headerlink" title="2.2 缺页"></a>2.2 <strong>缺页</strong></h2><p>缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断， 告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程</p><h3 id="2-2-1-请问哪些异常可能是缺页导致的？"><a href="#2-2-1-请问哪些异常可能是缺页导致的？" class="headerlink" title="2.2.1 请问哪些异常可能是缺页导致的？"></a>2.2.1 请问哪些异常可能是缺页导致的？</h3><ul><li>访问了一个没有映射的虚拟地址。</li><li>访问了映射了虚拟地址但尚未加载到物理内存的页面。</li><li>访问违反了权限的页面，如对只读页面进行写操作。</li></ul><h3 id="2-2-2-发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。"><a href="#2-2-2-发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。" class="headerlink" title="2.2.2 发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。"></a>2.2.2 发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。</h3><ul><li><strong>PC (Program Counter)</strong>: 保存发生异常指令的地址。</li><li><strong>stval&#x2F;utval (Store&#x2F;Trap Value Register)</strong>: 保存造成异常的虚拟地址。</li><li><strong>satp (Supervisor Address Translation and Protection Register)</strong>: 包含页表的基址和一些控制位，用于地址转换。</li></ul><h3 id="2-2-3-Lazy"><a href="#2-2-3-Lazy" class="headerlink" title="2.2.3 Lazy"></a>2.2.3 <code>Lazy</code></h3><p>缺页有两个常见的原因，其一是 <code>Lazy</code> 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 <code>os</code> 并不会马上这样做， 而是会保存 .<code>text</code> 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。<br>这样做有哪些好处？</p><ul><li>减少了初始化时的加载时间，加快了程序启动速度。</li><li>仅加载实际使用的内存页面，节省了物理内存资源。</li><li>避免了不必要的I&#x2F;O操作，提高了系统整体性能。</li></ul><h3 id="2-2-4-估算页表内存消耗"><a href="#2-2-4-估算页表内存消耗" class="headerlink" title="2.2.4 估算页表内存消耗"></a>2.2.4 估算页表内存消耗</h3><p>其实，我们的 <code>mmap</code> 也可以采取 <code>Lazy</code> 策略，比如：一个用户进程先后申请了 10G 的内存空间， 然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。<br>处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？</p><ol><li>每个页表项占用8字节，对于10G内存：</li><li>一级页表（PTEs）: <code>10G / 4K</code>（每页大小）&#x3D; <code>2560K</code> 页表项 &#x3D; <code>2560K * 8</code> 字节。</li><li>二级页表（PTEs）: <code>2560K / 512</code>（每级页表条目数）&#x3D; <code>5K</code> 页表项 &#x3D; <code>5K * 8</code> 字节。</li><li>三级页表（PTEs）: <code>5K / 512</code> &#x3D; <code>10</code> 页表项 &#x3D; <code>10 * 8</code> 字节。</li><li>总计约为<code>2560K * 8</code>字节 加上较小的二级和三级页表大小，数量级在几 M 字节。</li></ol><h3 id="2-2-5-实现Lazy"><a href="#2-2-5-实现Lazy" class="headerlink" title="2.2.5 实现Lazy"></a>2.2.5 实现<code>Lazy</code></h3><p>请简单思考如何才能实现 <code>Lazy</code> 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。</p><ul><li>在进程开始时，只为虚拟地址空间分配页表结构，不分配实际的物理页面。</li><li>页面第一次被访问时，通过缺页中断处理函数分配物理页面，并更新页表项。</li><li>缺页处理时，查找磁盘上相应的数据（如果之前已经映射），然后加载到内存中。</li></ul><h3 id="2-2-6-Swap"><a href="#2-2-6-Swap" class="headerlink" title="2.2.6 Swap"></a>2.2.6 <code>Swap</code></h3><p>缺页的另一个常见原因是 <code>swap</code> 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。<br>此时页面失效如何表现在页表项(PTE)上？</p><ul><li>有效位(<code>V</code>): 如果页面被换出到磁盘，页表项的有效位会被清除。</li><li>使用<code>RSW</code>位来存储额外的状态信息，区分真正的无效的页表项和被换到磁盘上的页表项</li></ul><h2 id="2-3-双页表与单页表"><a href="#2-3-双页表与单页表" class="headerlink" title="2.3 双页表与单页表"></a>2.3 双页表与单页表</h2><p>为了防范侧信道攻击，我们的 <code>o</code>s 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单&#x2F;双的说法仅为自创的通俗说法，并无这个名词概念，详情见 <a href="https://en.wikipedia.org/wiki/Kernel_page-table_isolation"><code>KPTI</code></a> )</p><ol><li><p>在单页表情况下，如何更换页表？<br>单页表不需要切换, 因为页表已经包含了用户空间和内核空间的映射。但是，当切换进程时，需要更换页表以加载新进程的地址空间。通过更新 <code>satp</code>寄存器来完成，这个寄存器包含了当前活动页表的物理地址。</p></li><li><p>单页表情况下，如何控制用户态无法访问内核页面？<br>内核页表的页表项不设置<code>U</code>位即可</p></li><li><p>单页表有何优势？<br>陷入内核时不需要切换页表, 同时仍然可以用硬件完成地址翻译, 效率更高</p></li><li><p>双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？</p><ol><li>双页表实现下，上下文切换和陷入内核都需要切换页表</li><li>单页表实现下, 切换不同的进程时才需要切换页表</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;练习实验书&lt;/strong&gt;: &lt;a href=&quot;https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter4/7exercise.html&quot;&gt;https://learningos.cn/rCore-Tu</summary>
      
    
    
    
    <category term="训练营笔记" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
    
    <category term="清华大学开源操作系统训练营2023" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A52023/"/>
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="riscv" scheme="http://example.com/tags/riscv/"/>
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>清华大学开源操作系统训练营: rCore chapter4笔记</title>
    <link href="http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/</id>
    <published>2024-02-20T13:22:29.000Z</published>
    <updated>2024-03-03T03:13:03.270Z</updated>
    
    <content type="html"><![CDATA[<p>本文不会将原本<code>rCore文档</code>的内容重复太多, 主要是补充学习过程中遇到的知识点, 因此还需结合原文使用, 原文在后面的链接中</p><p>这一章引入了页表和虚拟内存。回顾之前构建的<code>OS</code>, 其内核和应用是共用一份地址空间的。这也就意味着， 某个应用程序可以任意访问其他应用程序甚至内核的代码和数据， 这是不安全的， 并且， 编写应用程序的程序员还需要显式地指定链接的地址。因此， 虚拟内存应运而生。同时， 引入虚拟内存后， 还需要重新设计上下文切换和进程控制快, 因此这一章的代码相对复杂。</p><p>本章的内容包括:</p><ol><li>基于<code>SV39</code>引入虚拟内存和页表</li><li>重新设计进程控制块结构体</li><li>重新设计上下文切换</li></ol><p>完整版官方文档： <a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/index.html">https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/index.html</a></p><p>精简版文档： <a href="https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter4/index.html">https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter4/index.html</a></p><h1 id="1-引入虚拟内存"><a href="#1-引入虚拟内存" class="headerlink" title="1 引入虚拟内存"></a>1 引入虚拟内存</h1><h2 id="1-1-虚拟地址空间的概念"><a href="#1-1-虚拟地址空间的概念" class="headerlink" title="1.1 虚拟地址空间的概念"></a>1.1 虚拟地址空间的概念</h2><p>文档中对地址空间的介绍已经很完善了, 这里只做简要总结:</p><p><img src="/../../../images/LearningOS/ch4-address-space.png" alt="ch4-address-space"></p><p>上图摘自官方文档, 根据这个图简单介绍什么是地址空间</p><ol><li>为什么叫<strong>虚拟地址空间</strong>?<br>因为地址不是真正的物理内存地址, 而是需要经过一系列操作映射到物理地址。想象一下， 编写不同C语言程序时，我们的数据可以防止同样的地址中， 但这些不同的应用都可以同时运行，显然他们不是同一个物理地址</li><li>如何转化为<strong>物理地址</strong>？<br>通过硬件单元<code>MMU</code>进行转化, <code>MMU</code>会根据一个映射表查询虚拟地址对应的物理地址, 这个映射表就叫<strong>页表</strong>, 根页表的地址存放在指定的寄存器中, <code>riscv</code>中是<code>satp</code>寄存器</li><li>如何实现隔离<ol><li><code>U</code>表示用户态是否可以访问, <code>U</code>标记实现了内核和应用程序之间的隔离</li><li>每个应用程序有自己的页表, 并且页表项中的<code>V</code>标记位表示页表项是否有效, 不属于应用程序的地址没有设置<code>V</code>标记, 这实现了应用程序间的隔离</li></ol></li></ol><h2 id="1-2-分页管理"><a href="#1-2-分页管理" class="headerlink" title="1.2 分页管理"></a>1.2 分页管理</h2><p>由于地址的数量是近乎无限的, 不可能以每一个地址为粒度进行映射, 因此将<code>4096</code>个字节作为一个映射单位, 这就是<strong>分页</strong>的概念, 除了这个原因外, 分页还有一个好处就是<strong>方便在硬盘和内存之间加载和替换数据</strong>, 因为一次硬盘的<code>IO</code>是昂贵的, 因此一次硬盘的<code>IO</code>应当包含足够大的空间, 通常也就是一个扇区, 大小通常也是<code>4096</code>个字节。</p><blockquote><blockquote><p>目前的<code>rCore</code>没有文件系统, 因此虚拟内存的分页也没有在硬盘和内存中进行加载和替换的功能, 只是实现虚拟内存的抽象罢了</p></blockquote></blockquote><p>虚拟内存中的分页机制可以用一个贴近生活的比喻来理解：假设你有一本非常厚的书（这里的书就像是一个程序需要的内存空间），书架（物理内存）的空间有限，你不能同时把所有的书放在书架上。所以，你决定只把当前正在阅读的几页（活跃的内存页）放在书架上，而把其他的页暂时存放在一个大箱子里（硬盘上的交换空间）。当你想读书中的其他部分时，你会从箱子里取出你需要的页，并把不再需要的页放回箱子里。</p><p><strong>虚拟内存分页机制：</strong></p><ol><li><p><strong>分页的基本概念</strong>：<br>就像上面的比喻中，分页机制将虚拟内存分割成许多固定大小的块，每一块称为一个“页”或“页面”。同样地，物理内存也被分割成同样大小的块，称为“页帧”或“物理页”。</p></li><li><p><strong>页表映射</strong>：<br>为了追踪哪些虚拟页对应于物理内存中的哪些页帧，操作系统维护着一张映射表，这就是所谓的页表。当程序尝试访问其虚拟内存中的数据时，操作系统查看页表来找出那个虚拟页在物理内存中的位置。</p></li><li><p><strong>内存访问</strong>：<br>当程序访问一个虚拟地址时，这个地址被分成两部分：页号和页内偏移。页号用于在页表中查找对应的物理页帧，而页内偏移决定了在这个页帧内的具体位置。</p></li><li><p><strong>缺页中断</strong>：<br>如果程序需要访问的页当前不在物理内存中（也就是说，它在硬盘的交换空间里），这会触发一个叫做缺页中断（page fault）的事件。操作系统随后会选择一个物理页（如果需要，可能会将当前的内容保存到硬盘上），并从硬盘上加载所需的虚拟页到这个物理页中，然后更新页表，并重新开始执行刚才中断的指令。</p></li><li><p><strong>页替换算法</strong>：<br>当物理内存满了，而需要加载新的页时，操作系统必须决定哪些页将被移出物理内存以为新页腾出空间。这涉及到页替换算法，如最近最少使用（LRU）、先进先出（FIFO）等，用于选择被替换的页。</p></li></ol><p>通过这种分页机制，操作系统可以非常高效地管理内存，即使物理内存有限，程序也可以使用比物理内存大得多的地址空间。这样不仅提高了内存的使用效率，也简化了程序员的工作，因为他们不需要关心内存的物理限制，只需要关注于程序的逻辑结构。</p><p>最后贴上官方文档的图:</p><p><img src="/../../../images/LearningOS/ch4-page.png" alt="ch4-page"></p><p>页表中包含3个部分:</p><ol><li>映射的物理页号</li><li>页的操作权限</li></ol><blockquote><blockquote><p>图中的<code>FrameNumber</code>实际上在页表中是没有的</p></blockquote></blockquote><h2 id="1-3-SV39分页介绍"><a href="#1-3-SV39分页介绍" class="headerlink" title="1.3 SV39分页介绍"></a>1.3 <code>SV39</code>分页介绍</h2><p>这里介绍如何实现映射, 这里采用的是<code>riscv</code>的<code>SV39</code>分页机制:</p><p>首先看看虚拟地址和物理地址的格式:</p><p><img src="/../../../images/LearningOS/ch4-vaddr-paddr.png" alt="ch4-vaddr-paddr"></p><ol><li>虚拟地址被分为39位，意味着虚拟地址空间的大小可以达到2<sup>39</sup>字节，即512GB。其中低12位是页内的偏移量, 高27位可以分为3份, 每份9位, 表示的是在各级页表中的索引(如果看不懂就去看后面给出的地址翻译流程图)</li><li>物理地址的低12位表示一个页内的偏移, <code>12-55</code>位表示了页号</li></ol><p>下面是详细的<code>SV39分</code>页机制：</p><ol><li><p><strong>三级页表结构</strong>：在SV39分页模式下，地址翻译使用三级页表。这意味着虚拟地址被分为四部分：<code>VPN[2]、VPN[1]、VPN[0]</code>和页内偏移。这里的VPN代表虚拟页号（Virtual Page Number），不同级别的页表项（PTE）由不同的VPN部分索引。</p></li><li><p><strong>页大小</strong>：SV39通常使用4KB的页大小，这是最常见的页大小，但也支持大页，如2MB和1GB的大页。因为地址是8字节, 因此一个存放页表项的页就包含了<code>4096/1024</code>&#x3D;<code>512</code>个页表项</p></li><li><p><strong>地址转换</strong>：虚拟地址转换为物理地址的过程涉及查找三级页表。首先使用VPN[2]在一级页表中查找，得到二级页表的地址；然后使用VPN[1]在二级页表中查找，得到三级页表的地址；最后使用VPN[0]在三级页表中查找，得到物理页号（PPN）。页内偏移保持不变，直接用于定位物理页内的具体地址。</p></li><li><p><strong>地址翻译缓存（TLB）</strong>：由于地址翻译过程可能相当耗时，因为它涉及到多次内存访问，RISC-V处理器通常会使用<code>TLB</code>来缓存最近的地址翻译结果，来加快地址翻译速度。</p></li></ol><p>接下来是地址翻译的流程, 摘自<code>MIT6.S081</code>:</p><p><img src="/../../../images/LearningOS/ch4-translate.png" alt="ch4-translate"></p><ol><li><code>L2</code>是根页表的索引, 2<sup>9</sup> &#x3D; 512正好能表示所有的索引, 根页表的页表项记录了<code>L1</code>对应页表的物理页号<code>PPN</code></li><li>用之前拿到的物理页号<code>PPN</code>找到<code>L1</code>对应页表的物理页, 用同样的思路找到索引<code>L1</code>的页表项, 其记录了<code>L0</code>对应页表的物理页号<code>PPN</code></li><li>用之前的<code>PPN</code>, 结合索引<code>L0</code>拿到实际的数据页的页号<code>PPN</code></li><li>用最终得到的页号<code>PPN</code>找到数据页, 使用页内便宜<code>OffSet</code>就找到了最终的物理地址</li></ol><h2 id="1-4-SV39分页的代码实现"><a href="#1-4-SV39分页的代码实现" class="headerlink" title="1.4 SV39分页的代码实现"></a>1.4 <code>SV39</code>分页的代码实现</h2><p>文档中详细地介绍了页表和地址空间相关数据结构, 这里不详细展开了, 很多内容都是涉及页表号、地址之间的转化以及地址转货为结构体或切片的方法，比较繁琐。 这里只介绍我认为其中比较重要的代码</p><h3 id="1-4-1-页帧分配器"><a href="#1-4-1-页帧分配器" class="headerlink" title="1.4.1 页帧分配器"></a>1.4.1 页帧分配器</h3><p>这里管理内存既然是以页为单位的，自然需要一个页分配器，分配的页的单位称为页框：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    current: <span class="type">usize</span>,</span><br><span class="line">    end: <span class="type">usize</span>,</span><br><span class="line">    recycled: <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, l: PhysPageNum, r: PhysPageNum) &#123;</span><br><span class="line">        <span class="keyword">self</span>.current = l.<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.end = r.<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// trace!(&quot;last &#123;&#125; Physical Frames.&quot;, self.end - self.current);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的结构体中, 物理页号区间 <code>[ current , end )</code> 此前均 从未 被分配出去过，而容器 <code>recycled</code> 以后入先出的方式保存了被回收的物理页号,<br>具体分配和回收的方法如下:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">FrameAllocator</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">alloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;PhysPageNum&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">dealloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, ppn: PhysPageNum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FrameAllocator</span> <span class="keyword">for</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            current: <span class="number">0</span>,</span><br><span class="line">            end: <span class="number">0</span>,</span><br><span class="line">            recycled: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">alloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;PhysPageNum&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(ppn) = <span class="keyword">self</span>.recycled.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(ppn.<span class="title function_ invoke__">into</span>())</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">self</span>.current == <span class="keyword">self</span>.end &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.current += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>((<span class="keyword">self</span>.current - <span class="number">1</span>).<span class="title function_ invoke__">into</span>())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">dealloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, ppn: PhysPageNum) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ppn</span> = ppn.<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// validity check</span></span><br><span class="line">        <span class="keyword">if</span> ppn &gt;= <span class="keyword">self</span>.current || <span class="keyword">self</span>.recycled.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">any</span>(|&amp;v| v == ppn) &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Frame ppn=&#123;:#x&#125; has not been allocated!&quot;</span>, ppn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// recycle</span></span><br><span class="line">        <span class="keyword">self</span>.recycled.<span class="title function_ invoke__">push</span>(ppn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配和回收页帧逻辑都很简单:</p><ol><li>分配时优先从<code>recycled</code>中重复利用回收的页帧, 否则对<code>current</code>自增完成分配</li><li>回收时将其放入<code>recycled</code></li></ol><p>这里有一个很有意思的地方, 就是实际分配时是在前面的<code>StackFrameAllocator</code>基础上再再进行了一层封装:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Allocate a physical page frame in FrameTracker style</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">frame_alloc</span>() <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;FrameTracker&gt; &#123;</span><br><span class="line">    FRAME_ALLOCATOR</span><br><span class="line">        .<span class="title function_ invoke__">exclusive_access</span>()</span><br><span class="line">        .<span class="title function_ invoke__">alloc</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(FrameTracker::new)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Deallocate a physical page frame with a given ppn</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">frame_dealloc</span>(ppn: PhysPageNum) &#123;</span><br><span class="line">    FRAME_ALLOCATOR.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">dealloc</span>(ppn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="comment">/// physical page number</span></span><br><span class="line">    <span class="keyword">pub</span> ppn: PhysPageNum,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">frame_dealloc</span>(<span class="keyword">self</span>.ppn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还是熟悉的 <code>RAII</code> 的思想，将一个物理页帧的生命周期绑定到一个 <code>FrameTracker</code> 变量上，当其生命周期结束时, 使用自定义的<code>drop</code>方法将其回收到<code>StackFrameAllocator</code>的<code>recycle</code>容器中, 这种思想和方法以后还会看到</p><h3 id="1-4-2-页表的查询"><a href="#1-4-2-页表的查询" class="headerlink" title="1.4.2 页表的查询"></a>1.4.2 页表的查询</h3><p>页表的方法很多, 这里我只列出自己认为比较重要的方法, 首先就是查询页表的方法:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Find PageTableEntry by VirtPageNum, create a frame for a 4KB page table if not exist</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">find_pte_create</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">for</span> (i, idx) <span class="keyword">in</span> idxs.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = &amp;<span class="keyword">mut</span> ppn.<span class="title function_ invoke__">get_pte_array</span>()[*idx];</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">            result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(frame.ppn, PTEFlags::V);</span><br><span class="line">            <span class="keyword">self</span>.frames.<span class="title function_ invoke__">push</span>(frame);</span><br><span class="line">        &#125;</span><br><span class="line">        ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// Find PageTableEntry by VirtPageNum</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">find_pte</span>(&amp;<span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">for</span> (i, idx) <span class="keyword">in</span> idxs.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = &amp;<span class="keyword">mut</span> ppn.<span class="title function_ invoke__">get_pte_array</span>()[*idx];</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">            result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>find_pte_create</code>和<code>find_pte</code>逻辑类似, 都是实现了之前<code>MIT6.S081</code>中地址翻译的过程, 这里就不重复其过程了</p><h3 id="1-4-3-页表的创建与拆除"><a href="#1-4-3-页表的创建与拆除" class="headerlink" title="1.4.3 页表的创建与拆除"></a>1.4.3 页表的创建与拆除</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Create a new page table</span></span><br><span class="line">    <span class="comment">/// set the map between virtual page number and physical page number</span></span><br><span class="line">    <span class="meta">#[allow(unused)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte_create</span>(vpn).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">assert!</span>(!pte.<span class="title function_ invoke__">is_valid</span>(), <span class="string">&quot;vpn &#123;:?&#125; is mapped before mapping&quot;</span>, vpn);</span><br><span class="line">        *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(ppn, flags | PTEFlags::V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// remove the map between virtual page number and physical page number</span></span><br><span class="line">    <span class="meta">#[allow(unused)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte</span>(vpn).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">assert!</span>(pte.<span class="title function_ invoke__">is_valid</span>(), <span class="string">&quot;vpn &#123;:?&#125; is invalid before unmapping&quot;</span>, vpn);</span><br><span class="line">        *pte = PageTableEntry::<span class="title function_ invoke__">empty</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>页表的创建与拆除就是调用<code>find_pte_create</code>或<code>find_pte</code>, 然后设置页表项完成映射或拆除映射</p><h1 id="2-基于虚拟内存的地址空间"><a href="#2-基于虚拟内存的地址空间" class="headerlink" title="2 基于虚拟内存的地址空间"></a>2 基于虚拟内存的地址空间</h1><h2 id="2-1-地址空间结构体"><a href="#2-1-地址空间结构体" class="headerlink" title="2.1 地址空间结构体"></a>2.1 地址空间结构体</h2><p>完成了虚拟内存的实现后, 下一步是基于虚拟内存实现地址空间的抽象, 在<code>rCore</code>中, 地址空间被进一步划分为多个逻辑段:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MemorySet</span> &#123;</span><br><span class="line">    page_table: PageTable,</span><br><span class="line">    areas: <span class="type">Vec</span>&lt;MapArea&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里, <code>MemorySet</code>就是一个地址空间, 其中有多个逻辑段存放于一个容器<code>Vec</code>中, 这里也是<code>RAII</code>的思想</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MapArea</span> &#123;</span><br><span class="line">    vpn_range: VPNRange,</span><br><span class="line">    data_frames: BTreeMap&lt;VirtPageNum, FrameTracker&gt;,</span><br><span class="line">    map_type: MapType,</span><br><span class="line">    map_perm: MapPermission,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MapArea</code>的<code>vpn_range</code>表示虚拟页号的返回, <code>data_frames</code>同样是将<code>FrameTracker</code>的生命周期绑定到<code>BTreeMap</code>中</p><p>接下来, 只介绍<code>MemorySet</code>和<code>MapArea</code>中比较关键的方法, 因为所有的方法太繁杂了…</p><h2 id="2-2-新建和拆除MapArea映射"><a href="#2-2-新建和拆除MapArea映射" class="headerlink" title="2.2 新建和拆除MapArea映射"></a>2.2 新建和拆除<code>MapArea</code>映射</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map_one</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, vpn: VirtPageNum) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ppn</span>: PhysPageNum;</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.map_type &#123;</span><br><span class="line">        MapType::Identical =&gt; &#123;</span><br><span class="line">            ppn = <span class="title function_ invoke__">PhysPageNum</span>(vpn.<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MapType::Framed =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            ppn = frame.ppn;</span><br><span class="line">            <span class="keyword">self</span>.data_frames.<span class="title function_ invoke__">insert</span>(vpn, frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pte_flags</span> = PTEFlags::<span class="title function_ invoke__">from_bits</span>(<span class="keyword">self</span>.map_perm.bits).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    page_table.<span class="title function_ invoke__">map</span>(vpn, ppn, pte_flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[allow(unused)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmap_one</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, vpn: VirtPageNum) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.map_type == MapType::Framed &#123;</span><br><span class="line">        <span class="keyword">self</span>.data_frames.<span class="title function_ invoke__">remove</span>(&amp;vpn);</span><br><span class="line">    &#125;</span><br><span class="line">    page_table.<span class="title function_ invoke__">unmap</span>(vpn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map_one</code>的思路如下:</p><ol><li>新建一个虚拟页到物理页的映射<ol><li>如果映射类型是<code>MapType::Framed</code>: 从 <code>FRAME_ALLOCATOR</code> 处分配一个物理页<code>frame,</code> 并将 <code>vpn</code> 和 <code>frame</code> 插入到 <code>data_frames</code> 中</li><li>如果映射类型是<code>MapType::Identical</code>, <code>ppn</code>和<code>vpn</code>相等</li></ol></li><li>无论是那种类型, 都在<code>page_table</code>中插入 <code>vpn</code> 到 <code>ppn</code> 的映射</li></ol><p><code>unmap_one</code>也是调用<code>PageTable</code>的<code>unmap</code>方法, 思路类似</p><p>这里可以看到, <code>MapArea</code>只是逻辑上管理一个虚拟地址段的数据结构, 真正的映射实现还是通过外部提供的<code>PageTable</code>的<code>map</code>实现, 正因如此, <code>MapArea</code>需要被托管到上层的结构体进行管理</p><p>最后, <code>map_one</code>和<code>unmap_one</code>只是映射和拆除单一的虚拟页, 因此, 如果在地址空间的所有虚拟页中调用这2个方法, 就完成了整个地址空间的建立和拆除:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">vpn</span> <span class="keyword">in</span> <span class="keyword">self</span>.vpn_range &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">map_one</span>(page_table, vpn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[allow(unused)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">vpn</span> <span class="keyword">in</span> <span class="keyword">self</span>.vpn_range &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">unmap_one</span>(page_table, vpn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-内核地址空间"><a href="#2-3-内核地址空间" class="headerlink" title="2.3 内核地址空间"></a>2.3 内核地址空间</h2><h3 id="2-3-1-内核地址空间概述"><a href="#2-3-1-内核地址空间概述" class="headerlink" title="2.3.1 内核地址空间概述"></a>2.3.1 内核地址空间概述</h3><p><img src="/../../../images/LearningOS/ch4-kernel-space.png" alt="ch4-kernel-space"><img src="/../../../images/LearningOS/ch4-kernel-space-2.png" alt="ch4-kernel-space-2"></p><p>上图摘自官方文档, 第一张图是内核的高地址空间, 第二章图是内核的低地址空间, 和之前<code>ch3</code>类似, 不同的应用程序拥有自己的内核栈, 不同内核栈之间拥有保护页, 说到这里, 那之前<code>ch3</code>的没有引入虚拟内存的内核地址空间不是和现在没啥区别吗? 确实, 因为这里内核地址空间采用的是<strong>恒等映射</strong>, 也就是内核的虚拟地址和实际物理地址完全相同, 这样也便于内核精确地控制内存。</p><p>但区别还是有的，也就是跳板 <code>Trampoline</code>, 这会在后文中介绍</p><h3 id="2-3-2-应用地址空间概述"><a href="#2-3-2-应用地址空间概述" class="headerlink" title="2.3.2 应用地址空间概述"></a>2.3.2 应用地址空间概述</h3><p><img src="/../../../images/LearningOS/ch4-user-space.png" alt="ch4-user-space"><br>上图摘自官方文档, 和之前的内容相比, 现在的地址克难攻坚在顶层多了<code>Trampoline</code>和<code>TrapContext</code>, 这涉及到引入虚拟内存后的上下文切换, 后面会详细描述</p><blockquote><blockquote><p>其实地址空间这一部分, 最复杂的是解析<code>elf</code>的工作, 这一部分<code>rCore</code>目前直接使用了第三方库实现, 没有深入</p></blockquote></blockquote><h1 id="3-引入虚拟内存后的上下文切换"><a href="#3-引入虚拟内存后的上下文切换" class="headerlink" title="3 引入虚拟内存后的上下文切换"></a>3 引入虚拟内存后的上下文切换</h1><p>这一部分才是我们这一章节的最核心的内容</p><h2 id="3-1-思考和ch3的变化"><a href="#3-1-思考和ch3的变化" class="headerlink" title="3.1 思考和ch3的变化"></a>3.1 思考和<code>ch3</code>的变化</h2><p>回忆<code>ch3</code>的上下文切换, 其在<code>trap</code>中将不同任务的上下文信息保存在自己的内核栈中, 我们注意到在<code>trap.S</code>中有这样的汇编代码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__alltraps:</span><br><span class="line">    csrrw sp, sscratch, sp</span><br></pre></td></tr></table></figure><p>在陷入<code>trap</code>时, 应用程序将用户栈指针和内核栈指针交换, 然后将上下文信息存储在了内核栈上, 这在内核和用户公用一套地址空间时看起来是否自然, 但现在的问题是, 内核和用户的地址空间不一样, 换句话说就是<code>satp</code>中的根页表地址不一样。因此陷入内核时需要将内核地址空间的根页表地址(<code>token</code>)写入<code>satp</code>, 因此需要一个寄存器存储原来用户空间的<code>token</code>, 同时用户栈的指针也需要被存储, 但我们只有一个 <code>sscratch</code> 寄存器可用来进行周转。因此我们没有办法像原来一样将应用程序的上下文信息保存在内核栈中</p><h2 id="3-2-从新的trap-S分析TrapContext和Trampoline"><a href="#3-2-从新的trap-S分析TrapContext和Trampoline" class="headerlink" title="3.2 从新的trap.S分析TrapContext和Trampoline"></a>3.2 从新的<code>trap.S</code>分析<code>TrapContext</code>和<code>Trampoline</code></h2><p>先分析新的<code>trap.S</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">.altmacro</span><br><span class="line">.macro SAVE_GP n</span><br><span class="line">    sd x\n, \n*8(sp)</span><br><span class="line">.endm</span><br><span class="line">.macro LOAD_GP n</span><br><span class="line">    ld x\n, \n*8(sp)</span><br><span class="line">.endm</span><br><span class="line">    .section .text.trampoline</span><br><span class="line">    .globl __alltraps</span><br><span class="line">    .globl __restore</span><br><span class="line">    .align 2</span><br><span class="line">__alltraps:</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    <span class="comment"># now sp-&gt;*TrapContext in user space, sscratch-&gt;user stack</span></span><br><span class="line">    <span class="comment"># save other general purpose registers</span></span><br><span class="line">    sd x1, 1*8(sp)</span><br><span class="line">    <span class="comment"># skip sp(x2), we will save it later</span></span><br><span class="line">    sd x3, 3*8(sp)</span><br><span class="line">    <span class="comment"># skip tp(x4), application does not use it</span></span><br><span class="line">    <span class="comment"># save x5~x31</span></span><br><span class="line">    .<span class="built_in">set</span> n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        SAVE_GP %n</span><br><span class="line">        .<span class="built_in">set</span> n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    <span class="comment"># we can use t0/t1/t2 freely, because they have been saved in TrapContext</span></span><br><span class="line">    csrr t0, sstatus</span><br><span class="line">    csrr t1, sepc</span><br><span class="line">    sd t0, 32*8(sp)</span><br><span class="line">    sd t1, 33*8(sp)</span><br><span class="line">    <span class="comment"># read user stack from sscratch and save it in TrapContext</span></span><br><span class="line">    csrr t2, sscratch</span><br><span class="line">    sd t2, 2*8(sp)</span><br><span class="line">    <span class="comment"># load kernel_satp into t0</span></span><br><span class="line">    ld t0, 34*8(sp)</span><br><span class="line">    <span class="comment"># load trap_handler into t1</span></span><br><span class="line">    ld t1, 36*8(sp)</span><br><span class="line">    <span class="comment"># move to kernel_sp</span></span><br><span class="line">    ld sp, 35*8(sp)</span><br><span class="line">    <span class="comment"># switch to kernel space</span></span><br><span class="line">    csrw satp, t0</span><br><span class="line">    sfence.vma</span><br><span class="line">    <span class="comment"># jump to trap_handler</span></span><br><span class="line">    jr t1</span><br><span class="line"></span><br><span class="line">__restore:</span><br><span class="line">    <span class="comment"># a0: *TrapContext in user space(Constant); a1: user space token</span></span><br><span class="line">    <span class="comment"># switch to user space</span></span><br><span class="line">    csrw satp, a1</span><br><span class="line">    sfence.vma</span><br><span class="line">    csrw sscratch, a0</span><br><span class="line">    <span class="built_in">mv</span> sp, a0</span><br><span class="line">    <span class="comment"># now sp points to TrapContext in user space, start restoring based on it</span></span><br><span class="line">    <span class="comment"># restore sstatus/sepc</span></span><br><span class="line">    ld t0, 32*8(sp)</span><br><span class="line">    ld t1, 33*8(sp)</span><br><span class="line">    csrw sstatus, t0</span><br><span class="line">    csrw sepc, t1</span><br><span class="line">    <span class="comment"># restore general purpose registers except x0/sp/tp</span></span><br><span class="line">    ld x1, 1*8(sp)</span><br><span class="line">    ld x3, 3*8(sp)</span><br><span class="line">    .<span class="built_in">set</span> n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        LOAD_GP %n</span><br><span class="line">        .<span class="built_in">set</span> n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    <span class="comment"># back to user stack</span></span><br><span class="line">    ld sp, 2*8(sp)</span><br><span class="line">    sret</span><br></pre></td></tr></table></figure><p>这里先只分析<code>__alltraps</code>的代码:</p><p>通过注释我们看出, 此时的<code>sscratch</code>存储的是用户态下<code>TrapContext</code>的地址, 这里需要尤其注意, 尽管我们现在进入的内核模式(硬件会自动设置一些<code>csr</code>寄存器), 但是我们目前的地址空间还没有发送变化, 相关寄存器还是用户态时的内容, 也就是说, 此时我们是将上下文地址存储到了用户的地址空间中的一段连续的内存中, 这个区域也就是之前图中的<code>trapContext</code></p><p>存储完成后, 从<code>trapContext</code>的固定位置读取内核的<code>token</code>和内核栈的地址, 重新设置<code>sp</code>后并调用<code>sfence.vma</code>完成地址空间的切换, 这里的问题在于, 完成地址空间切换后, 我们的<code>pc</code>还是指向<code>__alltraps</code>的最后一句<code>jr t1</code>吗?</p><p>首先这是必要的, 不然操作系统就没法玩了。但由于地址空间发生了切换，要实现这一点，**<code>trap.S</code>中的代码在内核地址空间和用户地址空间必须是相同的映射吗, 这一块映射的地址段就是<code>Trampoline</code>**</p><p>接下来看看映射<code>Trampoline</code>的方法:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">map_trampoline</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.page_table.<span class="title function_ invoke__">map</span>(</span><br><span class="line">        VirtAddr::<span class="title function_ invoke__">from</span>(TRAMPOLINE).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        PhysAddr::<span class="title function_ invoke__">from</span>(strampoline <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        PTEFlags::R | PTEFlags::X,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是<code>map_trampoline</code>方法直接被一个地址空间映射, 不属于一个<code>MapArea</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new_kernel</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">memory_set</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">new_bare</span>();</span><br><span class="line">        <span class="comment">// map trampoline</span></span><br><span class="line">        memory_set.<span class="title function_ invoke__">map_trampoline</span>();</span><br><span class="line">        <span class="comment">// map kernel sections</span></span><br><span class="line">        info!(<span class="string">&quot;.text [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, stext <span class="keyword">as</span> <span class="type">usize</span>, etext <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        info!(<span class="string">&quot;.rodata [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, srodata <span class="keyword">as</span> <span class="type">usize</span>, erodata <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        info!(<span class="string">&quot;.data [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, sdata <span class="keyword">as</span> <span class="type">usize</span>, edata <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        info!(</span><br><span class="line">            <span class="string">&quot;.bss [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>,</span><br><span class="line">            sbss_with_stack <span class="keyword">as</span> <span class="type">usize</span>, ebss <span class="keyword">as</span> <span class="type">usize</span></span><br><span class="line">        );</span><br><span class="line">        info!(<span class="string">&quot;mapping .text section&quot;</span>);</span><br><span class="line">        memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">            MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">                (stext <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">                (etext <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">                MapType::Identical,</span><br><span class="line">                MapPermission::R | MapPermission::X,</span><br><span class="line">            ),</span><br><span class="line">            <span class="literal">None</span>,</span><br><span class="line">        );</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-引入虚拟内存后的任务控制"><a href="#4-引入虚拟内存后的任务控制" class="headerlink" title="4 引入虚拟内存后的任务控制"></a>4 引入虚拟内存后的任务控制</h1><h2 id="4-1-任务控制块"><a href="#4-1-任务控制块" class="headerlink" title="4.1 任务控制块"></a>4.1 任务控制块</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskControlBlock</span> &#123;</span><br><span class="line">    <span class="comment">/// Save task context</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Maintain the execution status of the current process</span></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Application address space</span></span><br><span class="line">    <span class="keyword">pub</span> memory_set: MemorySet,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The phys page number of trap context</span></span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The size(top addr) of program which is loaded from elf file</span></span><br><span class="line">    <span class="keyword">pub</span> base_size: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入虚拟内存后, 需要添加地址空间<code>MemorySet</code>的结构体以及每个任务的<code>trap context</code>的物理页号, 这样以来, 内核才可以在任务控制时获取其<code>trap</code>的上下文信息</p><h2 id="4-2-任务运行的实例"><a href="#4-2-任务运行的实例" class="headerlink" title="4.2 任务运行的实例"></a>4.2 任务运行的实例</h2><p>其实<code>TaskControlBlock</code>很多地方都尽量修改, 但在理解了上下文切换的变化和挑板页<code>Trampoline</code>的原理后, 看看官方文档很容易理解, 就不展开了</p><p>这里还是以一个我画的流程图的形式来总结引入虚拟内存的变化, 这里从运行第一个程序开始<br><img src="/../../../images/LearningOS/ch4-switch.png" alt="ch4-switch.png"></p><p>图例说明:</p><ol><li>红色表示内核函数</li><li>蓝色表示用户函数或用户地址空间的内存段</li><li>紫色表示跳板页的中间状态</li></ol><p>注意, 这里上下文切换时, <code>App0</code>的<code>TaskContext</code>有2次使用:</p><ol><li><code>__alltraps</code>时使用了<code>TaskContext</code>:<br>这里的目的是切换<code>App0</code>的用户上下文和内核上下文</li><li><code>App0</code>切换到<code>App1</code>的<code>__switch</code>时使用了<code>TaskContext</code>:<br>这里是保存<code>App0</code>在内核态时的寄存器和内核栈指针, 也就是切换的是<code>App0</code>的内核态上下文和<code>App1</code>的上下文, 在这里<code>App1</code>的上下文是用户上下文, 因为<code>APP1</code>也是第一次运行, 但之运行一段时间后的上下文切换则不一定, 可能切换到某个<code>App</code>之前让出<code>Cpu</code>时执行到<code>__switch</code>的内核上下文, 例如这里的<code>App0</code></li></ol><p>这里由于太拥挤了, 没有画出<code>App0</code>之后恢复执行的流程, 这里简单说明一下:</p><ol><li>某一时刻另外的<code>App</code>因执行结束或者让出<code>CPU</code>, 又进入了<code>run_next_task</code></li><li>这次<code>run_next_task</code>选择下一个<code>task</code>是<code>App0</code></li><li>由于<code>App0</code>的<code>TaskContext</code>保存了上一次其在内核中被切换的上下文: 执行<code>run_next_task</code>时的返回地址<code>ra</code>, <code>ra</code>被加载后将按照下面的路径返回:<code>__switch</code> -&gt; <code>run_next_task</code> -&gt; <code>suspend_current_and_run_next</code> -&gt; <code>trap_handler</code></li><li>此后执行: <code>trap_return</code> -&gt; <code>__restore</code> -&gt; <code>之前让出CPu的用户代码</code>, 这个过程中的最后一步中, 之前恢复的<code>sepc</code>会在<code>sret</code>返回时会被加载到<code>pc</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文不会将原本&lt;code&gt;rCore文档&lt;/code&gt;的内容重复太多, 主要是补充学习过程中遇到的知识点, 因此还需结合原文使用, 原文在后面的链接中&lt;/p&gt;
&lt;p&gt;这一章引入了页表和虚拟内存。回顾之前构建的&lt;code&gt;OS&lt;/code&gt;, 其内核和应用是共用一份地址空间的</summary>
      
    
    
    
    <category term="训练营笔记" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
    
    <category term="清华大学开源操作系统训练营2023" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A52023/"/>
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="riscv" scheme="http://example.com/tags/riscv/"/>
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>清华大学开源操作系统训练营: rCore chapter3笔记</title>
    <link href="http://example.com/2024/02/15/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch3%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/02/15/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch3%E7%AC%94%E8%AE%B0/</id>
    <published>2024-02-15T00:18:24.000Z</published>
    <updated>2024-02-21T16:16:04.678Z</updated>
    
    <content type="html"><![CDATA[<p>本文不会将原本<code>rCore文档</code>的内容重复太多, 主要是补充学习过程中遇到的知识点, 因此还需结合原文使用, 原文在后面的链接中</p><p>这一章在之前的章节中更进一步, 实现了任务调度的功能, 也就是任务不再是之前的批处理系统那样一个接一个地运行, 而是受到<code>OS</code>的调度。为了实现这一目标， 本章实现了下面的功能或机制：</p><ol><li>将应用程序加载到不同的内存位置， 并且同时存在于内存中</li><li>内核添加上下文相关的数据结构，存储应用调度时的上下文信息，基于这些数据结构实现上下文切换函数</li><li>通过时钟中断实现抢占式调度</li></ol><p>完整版官方文档： <a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter3/index.html">https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter3/index.html</a></p><p>精简版文档： <a href="https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter3/index.html">https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter3/index.html</a></p><h1 id="1-应用程序数据结构"><a href="#1-应用程序数据结构" class="headerlink" title="1 应用程序数据结构"></a>1 应用程序数据结构</h1><h2 id="1-1-应用程序加载位置"><a href="#1-1-应用程序加载位置" class="headerlink" title="1.1 应用程序加载位置"></a>1.1 应用程序加载位置</h2><p>这一过程相比之前的章节变化很小，就是将不同的应用程序链接到了操作系统的不同的位置，应用程序加载的位置是一个基址加上指定的偏移量。</p><h2 id="1-2-应用程序的栈"><a href="#1-2-应用程序的栈" class="headerlink" title="1.2 应用程序的栈"></a>1.2 应用程序的栈</h2><p>这一由于我们需要实现任务的切换，应用程序运行的<strong>上下文</strong>包括了各种寄存器、函数调用栈等， 这些应用程序在应用程序被切换时需要被保存好，保存的位置通常是应用程序的内核栈，因此应用程序需要在上一章的基础上添加内核栈。</p><p>项目代码中，内核栈的初始化是咋<code>init_app_cx</code>中完成的:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/loader.rs</span></span><br><span class="line"><span class="keyword">static</span> KERNEL_STACK: [KernelStack; MAX_APP_NUM] = [KernelStack &#123;</span><br><span class="line">    data: [<span class="number">0</span>; KERNEL_STACK_SIZE],</span><br><span class="line">&#125;; MAX_APP_NUM];</span><br><span class="line"><span class="keyword">static</span> USER_STACK: [UserStack; MAX_APP_NUM] = [UserStack &#123;</span><br><span class="line">    data: [<span class="number">0</span>; USER_STACK_SIZE],</span><br><span class="line">&#125;; MAX_APP_NUM];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init_app_cx</span>(app_id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    KERNEL_STACK[app_id].<span class="title function_ invoke__">push_context</span>(TrapContext::<span class="title function_ invoke__">app_init_context</span>(</span><br><span class="line">        <span class="title function_ invoke__">get_base_i</span>(app_id),</span><br><span class="line">        USER_STACK[app_id].<span class="title function_ invoke__">get_sp</span>(),</span><br><span class="line">    ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, 每个程序有一个自己的<strong>内核栈和用户栈</strong>, 其内存空间就是一个全局变量数组的与<code>app</code>序号相同的索引处, 在初始化栈时, 每个应用程序的栈顶存放了其上下文信息(后面的章节会介绍)和用户栈指针。</p><h1 id="2-上下文切换"><a href="#2-上下文切换" class="headerlink" title="2 上下文切换"></a>2 上下文切换</h1><p>这一部分是非常重要的概念，其思想几乎适用于所有的操作系统而不仅仅是<code>rCore</code></p><h2 id="2-1-什么是上下文切换"><a href="#2-1-什么是上下文切换" class="headerlink" title="2.1 什么是上下文切换?"></a>2.1 什么是上下文切换?</h2><p><strong>上下文</strong>指的是一个进程或线程(这里我们还没有实现进程或者线程, 但是我们的应用程序可以类比进程)可以执行所需的所有信息的集合, 包括CPU寄存器的值、程序计数器（PC），堆栈指针以及操作系统为该进程或线程维护的内存分配信息等。</p><p>当操作系统执行任务切换（<code>context switch</code>）时，它会保存当前任务的上下文，并加载另一个任务的上下文，以便恢复该任务的执行, 这一过程称为<strong>上下文切换</strong>, 步骤包括:</p><ol><li><strong>保存CPU状态</strong>：保存当前执行任务的所有CPU寄存器，包括程序计数器和堆栈指针。</li><li><strong>保存进程状态</strong>：将当前进程的其他状态信息（如打开的文件描述符、进程的权限、记账信息等）保存到进程控制块（PCB）。</li><li><strong>加载新的进程状态</strong>：从另一个进程的PCB中读取其CPU寄存器和其他状态信息，并将其恢复到CPU和内存中。</li><li><strong>恢复执行</strong>：开始或恢复执行选定的新进程。</li></ol><h2 id="2-2-什么时候会上下文切换"><a href="#2-2-什么时候会上下文切换" class="headerlink" title="2.2 什么时候会上下文切换?"></a>2.2 什么时候会上下文切换?</h2><p>上面介绍了上下文切换, 但实际上我们的上下文切换是何时发生的呢? 其发生的原因在本章实现的<code>OS</code>中有2中:</p><ol><li>应用程序主动通过<code>yield</code>让出<code>CPU</code></li><li>应用程序运行了过长的时间, 被操作系统抢占(后面章节会介绍)</li></ol><h2 id="2-3-上下文切换的实现"><a href="#2-3-上下文切换的实现" class="headerlink" title="2.3 上下文切换的实现"></a>2.3 上下文切换的实现</h2><h3 id="2-3-1-数据结构"><a href="#2-3-1-数据结构" class="headerlink" title="2.3.1 数据结构"></a>2.3.1 数据结构</h3><p>直接先贴代码:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/context.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskContext</span> &#123;</span><br><span class="line">    <span class="comment">/// Ret position after task switching</span></span><br><span class="line">    ra: <span class="type">usize</span>,</span><br><span class="line">    <span class="comment">/// Stack pointer</span></span><br><span class="line">    sp: <span class="type">usize</span>,</span><br><span class="line">    <span class="comment">/// s0-11 register, callee saved</span></span><br><span class="line">    s: [<span class="type">usize</span>; <span class="number">12</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TaskContext</span> &#123;</span><br><span class="line">    <span class="comment">/// Create a new empty task context</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">zero_init</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            ra: <span class="number">0</span>,</span><br><span class="line">            sp: <span class="number">0</span>,</span><br><span class="line">            s: [<span class="number">0</span>; <span class="number">12</span>],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Create a new task context with a trap return addr and a kernel stack pointer</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">goto_restore</span>(kstack_ptr: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">__restore</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            ra: __restore <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">            sp: kstack_ptr,</span><br><span class="line">            s: [<span class="number">0</span>; <span class="number">12</span>],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TaskContext</code>这个结构体就是保存上下文的结构体, 保存的结构体包括<code>s0-s11</code>寄存器, 栈指针<code>sp</code>, 返回地址<code>ra</code>。<br>另外需要注意的是， 程序还没运行时，其上下文信息中的<code>ra</code>是上一章介绍的从<code>trap</code>恢复的<code>__restore</code>, 这和之前的逻辑是一样的</p><h3 id="2-3-2-switch函数"><a href="#2-3-2-switch函数" class="headerlink" title="2.3.2 __switch函数"></a>2.3.2 <code>__switch</code>函数</h3><p><code>__switch</code>函数完成了上下文切换, 其是由汇编代码编写的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.altmacro</span><br><span class="line">.macro SAVE_SN n</span><br><span class="line">    sd s\n, (\n+2)*8(a0)</span><br><span class="line">.endm</span><br><span class="line">.macro LOAD_SN n</span><br><span class="line">    ld s\n, (\n+2)*8(a1)</span><br><span class="line">.endm</span><br><span class="line">    .section .text</span><br><span class="line">    .globl __switch</span><br><span class="line">__switch:</span><br><span class="line">    <span class="comment"># __switch(</span></span><br><span class="line">    <span class="comment">#     current_task_cx_ptr: *mut TaskContext,</span></span><br><span class="line">    <span class="comment">#     next_task_cx_ptr: *const TaskContext</span></span><br><span class="line">    <span class="comment"># )</span></span><br><span class="line">    <span class="comment"># save kernel stack of current task</span></span><br><span class="line">    sd sp, 8(a0)</span><br><span class="line">    <span class="comment"># save ra &amp; s0~s11 of current execution</span></span><br><span class="line">    sd ra, 0(a0)</span><br><span class="line">    .<span class="built_in">set</span> n, 0</span><br><span class="line">    .rept 12</span><br><span class="line">        SAVE_SN %n</span><br><span class="line">        .<span class="built_in">set</span> n, n + 1</span><br><span class="line">    .endr</span><br><span class="line">    <span class="comment"># restore ra &amp; s0~s11 of next execution</span></span><br><span class="line">    ld ra, 0(a1)</span><br><span class="line">    .<span class="built_in">set</span> n, 0</span><br><span class="line">    .rept 12</span><br><span class="line">        LOAD_SN %n</span><br><span class="line">        .<span class="built_in">set</span> n, n + 1</span><br><span class="line">    .endr</span><br><span class="line">    <span class="comment"># restore kernel stack of next task</span></span><br><span class="line">    ld sp, 8(a1)</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>这段汇编代码的<code>a0</code> 和 <code>a1</code> 是函数参数寄存器，在<code>RISC-V</code>调用约定中用来传递第一个和第二个参数。在<code>__switch</code>函数中，它们分别代表<code>current_task_cx_ptr</code>（当前任务上下文指针）和<code>next_task_cx_ptr</code>（下一个任务上下文指针）。</p><ul><li><p><code>sd sp, 8(a0)</code>：存储当前任务的堆栈指针（<code>sp</code>）到<code>current_task_cx_ptr</code>所指向的结构体的第二个位置（假设结构体的起始位置为0，每个存储单元为8字节，栈指针保存在偏移量为8字节的位置）。</p></li><li><p><code>sd ra, 0(a0)</code>：存储当前任务的返回地址（<code>ra</code>）到<code>current_task_cx_ptr</code>所指向的结构体的起始位置。</p></li><li><p><code>.set n, 0</code> 和 <code>.rept 12</code> 循环：这是一个宏循环，它重复执行12次，用于保存寄存器<code>s0</code>到<code>s11</code>的值。<code>SAVE_SN</code>是一个宏，用于保存寄存器<code>s0</code>到<code>s11</code>到<code>current_task_cx_ptr</code>所指向的结构体中，对应的偏移量从16字节开始，每次增加8字节。</p></li><li><p><code>ld ra, 0(a1)</code>：加载下一个任务的返回地址到<code>ra</code>寄存器，这个地址来自<code>next_task_cx_ptr</code>所指向的结构体的起始位置。</p></li><li><p><code>.set n, 0</code> 和 <code>.rept 12</code> 循环：这是另一个宏循环，用于从<code>next_task_cx_ptr</code>所指向的结构体中恢复寄存器<code>s0</code>到<code>s11</code>的值。<code>LOAD_SN</code>宏执行相应的加载操作。</p></li><li><p><code>ld sp, 8(a1)</code>：加载下一个任务的堆栈指针到<code>sp</code>寄存器，这个堆栈指针来自<code>next_task_cx_ptr</code>所指向的结构体的第二个位置。</p></li><li><p><code>ret</code>：返回指令，它会跳转到<code>ra</code>寄存器中的地址，这里是下一个任务的继续执行点。</p></li></ul><p>这段汇编代码的主要任务是保存当前执行环境的关键状态（堆栈指针和寄存器），然后恢复下一个任务的状态，从而实现任务之间的切换。</p><h1 id="3-任务调度"><a href="#3-任务调度" class="headerlink" title="3 任务调度"></a>3 任务调度</h1><h2 id="3-1-数据结构"><a href="#3-1-数据结构" class="headerlink" title="3.1 数据结构"></a>3.1 数据结构</h2><p>本章引入了<code>TASK_MANAGER</code>这个全局变量来实现任务的调度, 其结构体为:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskManager</span> &#123;</span><br><span class="line">    num_app: <span class="type">usize</span>,</span><br><span class="line">    inner: UPSafeCell&lt;TaskManagerInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskManagerInner</span> &#123;</span><br><span class="line">    tasks: [TaskControlBlock; MAX_APP_NUM],</span><br><span class="line">    current_task: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其使用<code>current_task</code>标记当前运行的结构体</p><p>每个任务用<code>TaskControlBlock</code>标记:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskControlBlock</span> &#123;</span><br><span class="line">    <span class="comment">/// The task status in it&#x27;s lifecycle</span></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line">    <span class="comment">/// The task context</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// The status of a task</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, PartialEq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">TaskStatus</span> &#123;</span><br><span class="line">    <span class="comment">/// uninitialized</span></span><br><span class="line">    UnInit,</span><br><span class="line">    <span class="comment">/// ready to run</span></span><br><span class="line">    Ready,</span><br><span class="line">    <span class="comment">/// running</span></span><br><span class="line">    Running,</span><br><span class="line">    <span class="comment">/// exited</span></span><br><span class="line">    Exited,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一部分很同意理解, 就是将任务的状态和上下文记录在一起, 以便于任务调度</p><h2 id="3-2-任务调度"><a href="#3-2-任务调度" class="headerlink" title="3.2 任务调度"></a>3.2 任务调度</h2><p>调度任务的过程就是找到当前任务的上下文(或者第一个任务运行时的初始化的上下文)和下一个任务的上下文, 将其作为参数传递给<code>__switch</code>函数, 其发生场景有3种:</p><ol><li><p>第一次运行程序:</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/mod.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">run_first_task</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task0</span> = &amp;<span class="keyword">mut</span> inner.tasks[<span class="number">0</span>];</span><br><span class="line">    task0.task_status = TaskStatus::Running;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">next_task_cx_ptr</span> = &amp;task0.task_cx <span class="keyword">as</span> *<span class="keyword">const</span> TaskContext;</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(inner);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">_unused</span> = TaskContext::<span class="title function_ invoke__">zero_init</span>();</span><br><span class="line">    <span class="comment">// before this, we should drop local variables that must be dropped manually</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __switch(&amp;<span class="keyword">mut</span> _unused <span class="keyword">as</span> *<span class="keyword">mut</span> TaskContext, next_task_cx_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;unreachable in run_first_task!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里是选择序号为0的程序运行</p></li><li><p>程序主动让出<code>CPU</code>或被抢占</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/mod.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">suspend_current_and_run_next</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">mark_current_suspended</span>();</span><br><span class="line">    <span class="title function_ invoke__">run_next_task</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// Change the status of current `Running` task into `Ready`.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">mark_current_suspended</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">current</span> = inner.current_task;</span><br><span class="line">    inner.tasks[current].task_status = TaskStatus::Ready;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>程序运行结束</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// os/src/task/mod.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exit_current_and_run_next</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">mark_current_exited</span>();</span><br><span class="line">    <span class="title function_ invoke__">run_next_task</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// Change the status of current `Running` task into `Exited`.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">mark_current_exited</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">current</span> = inner.current_task;</span><br><span class="line">    inner.tasks[current].task_status = TaskStatus::Exited;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>其中<code>run_next_task</code>最终会调用下面的函数<code>run_next_task</code>方法:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">run_next_task</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(next) = <span class="keyword">self</span>.<span class="title function_ invoke__">find_next_task</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">current</span> = inner.current_task;</span><br><span class="line">        inner.tasks[next].task_status = TaskStatus::Running;</span><br><span class="line">        inner.current_task = next;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">current_task_cx_ptr</span> = &amp;<span class="keyword">mut</span> inner.tasks[current].task_cx <span class="keyword">as</span> *<span class="keyword">mut</span> TaskContext;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">next_task_cx_ptr</span> = &amp;inner.tasks[next].task_cx <span class="keyword">as</span> *<span class="keyword">const</span> TaskContext;</span><br><span class="line">        <span class="title function_ invoke__">drop</span>(inner);</span><br><span class="line">        <span class="comment">// before this, we should drop local variables that must be dropped manually</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            __switch(current_task_cx_ptr, next_task_cx_ptr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// go back to user mode</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;All applications completed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其过程包括:</p><ol><li><code>find_next_task</code>选择一个就绪的任务</li><li>标记这个就绪的任务为<code>TaskStatus::Running</code></li><li>传递2个任务的上下文结构体给<code>__switch</code>完成上下文切换</li></ol><h1 id="4-抢占"><a href="#4-抢占" class="headerlink" title="4 抢占"></a>4 抢占</h1><p>截止到目前, 大部分多任务调度的机制已经实现, 但还缺少抢占的机制实现</p><h2 id="4-1-时钟中断"><a href="#4-1-时钟中断" class="headerlink" title="4.1 时钟中断"></a>4.1 时钟中断</h2><p>时钟中断是操作系统实现抢占式多任务处理的关键机制。它允许操作系统定期从当前执行的任务（或线程）中断开，以便操作系统的调度器可以决定是否继续执行当前任务或切换到另一个任务。这种机制确保了所有任务都有机会在处理器上运行，进而使得操作系统能够提供一个看似同时运行多个任务的环境, 并且避免了一个应用程序运行时间过长的场景。中断的主要作用有：</p><ol><li><strong>公平的CPU时间分配</strong>：确保所有任务都有公平的机会使用CPU，根据它们的优先级和CPU时间需求进行调度。</li><li><strong>响应性</strong>：即使一个任务在执行一个长时间的操作，时钟中断也确保系统保持响应，因为操作系统可以在两个连续的时钟中断之间切换到其他任务。</li><li><strong>多任务处理</strong>：允许多个任务看似同时进行，提高了系统的利用率和吞吐量。</li></ol><h2 id="4-2-时钟中断的工作原理"><a href="#4-2-时钟中断的工作原理" class="headerlink" title="4.2 时钟中断的工作原理"></a>4.2 时钟中断的工作原理</h2><ol><li><p><strong>硬件时钟</strong>：硬件时钟（通常是一个定时器设备）被配置为在固定的时间间隔发出信号。这个时间间隔可以是毫秒级别，具体取决于操作系统的设计和配置。</p></li><li><p><strong>中断信号</strong>：当硬件时钟达到预设的时间间隔时，它会向处理器发送一个中断信号。这个信号提示处理器当前正在执行的指令流应该被暂时中断。在我们的代码中， 我们进行了如下设置：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Set the next timer interrupt</span></span><br><span class="line"> <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_next_trigger</span>() &#123;</span><br><span class="line">     <span class="title function_ invoke__">set_timer</span>(<span class="title function_ invoke__">get_time</span>() + CLOCK_FREQ / TICKS_PER_SEC);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> <code>set_timer</code>是<code>rustsbi</code>提供的中断设置接口, 其可以实则指定时间的中断</p></li><li><p><strong>中断服务例程（ISR）</strong>：处理器接收到中断信号后，会跳转执行一个特定的中断服务例程。这个ISR是由操作系统提供的，并且在中断向量表中有一个特定的入口。在许多处理器架构和操作系统中，<strong>中断服务例程（ISR）和异常处理程序通常通过一个统一的入口点处理，这个入口点被称为陷阱（trap）处理程序，也就是在我们的项目中存储在<code>stvec</code>中的<code>__alltraps</code></strong>, 我们可以在<code>os/src/trap/mod.rs</code>中看到下面的初始化:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>() &#123;</span><br><span class="line">     <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">         <span class="keyword">fn</span> <span class="title function_">__alltraps</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">unsafe</span> &#123;</span><br><span class="line">         stvec::<span class="title function_ invoke__">write</span>(__alltraps <span class="keyword">as</span> <span class="type">usize</span>, TrapMode::Direct);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 换句话说</p></li><li><p><strong>中断异常处理</strong>：在<code>ISR</code>中，操作系统的调度器可以检测当前运行的任务是否应该继续运行，或者是另一个任务的运行优先级更高。如果决定进行任务切换，操作系统会保存当前任务的状态（上下文切换），然后加载下一个任务的状态并开始执行它。目前我们的中断是时钟中断, 实际上还有更多类型的中断, 不是每一个中断都和上下文切换相关, 比如有的中断只是外设鼠标或键盘的硬件中断</p></li><li><p><strong>返回正常执行</strong>：完成调度决策和任何必要的任务切换后，<code>ISR</code>结束，并指示处理器恢复到中断前的状态，继续执行被中断的任务或开始执行新的任务。</p></li></ol><h2 id="4-3-引入中断后的任务调度"><a href="#4-3-引入中断后的任务调度" class="headerlink" title="4.3 引入中断后的任务调度"></a>4.3 引入中断后的任务调度</h2><h3 id="4-3-1-中断机制的初始化"><a href="#4-3-1-中断机制的初始化" class="headerlink" title="4.3.1 中断机制的初始化"></a>4.3.1 中断机制的初始化</h3><p>中断相关的初始化很简单, 就是在<code>rust_main</code>中调用<code>set_next_trigger</code>设置一次中断时间。</p><h3 id="4-3-2-任务调度"><a href="#4-3-2-任务调度" class="headerlink" title="4.3.2 任务调度"></a>4.3.2 任务调度</h3><p>由于中断使用的入口就是<code>__alltraps</code>，因此我们只需要关注<code>__alltraps</code>调用的<code>trap_handler</code>即可:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">trap_handler</span>(cx: &amp;<span class="keyword">mut</span> TrapContext) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> TrapContext &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scause</span> = scause::<span class="title function_ invoke__">read</span>(); <span class="comment">// get trap cause</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stval</span> = stval::<span class="title function_ invoke__">read</span>(); <span class="comment">// get extra value</span></span><br><span class="line">                               <span class="comment">// trace!(&quot;into &#123;:?&#125;&quot;, scause.cause());</span></span><br><span class="line">    <span class="keyword">match</span> scause.<span class="title function_ invoke__">cause</span>() &#123;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::UserEnvCall) =&gt; &#123;</span><br><span class="line">            <span class="comment">// jump to next instruction anyway</span></span><br><span class="line">            cx.sepc += <span class="number">4</span>;</span><br><span class="line">            <span class="comment">// get system call return value</span></span><br><span class="line">            cx.x[<span class="number">10</span>] = <span class="title function_ invoke__">syscall</span>(cx.x[<span class="number">17</span>], [cx.x[<span class="number">10</span>], cx.x[<span class="number">11</span>], cx.x[<span class="number">12</span>]]) <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::StoreFault) | Trap::<span class="title function_ invoke__">Exception</span>(Exception::StorePageFault) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] PageFault in application, bad addr = &#123;:#x&#125;, bad instruction = &#123;:#x&#125;, kernel killed it.&quot;</span>, stval, cx.sepc);</span><br><span class="line">            <span class="title function_ invoke__">exit_current_and_run_next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::IllegalInstruction) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] IllegalInstruction in application, kernel killed it.&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">exit_current_and_run_next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Interrupt</span>(Interrupt::SupervisorTimer) =&gt; &#123;</span><br><span class="line">            <span class="title function_ invoke__">set_next_trigger</span>();</span><br><span class="line">            <span class="title function_ invoke__">suspend_current_and_run_next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Unsupported trap &#123;:?&#125;, stval = &#123;:#x&#125;!&quot;</span>,</span><br><span class="line">                scause.<span class="title function_ invoke__">cause</span>(),</span><br><span class="line">                stval</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, <code>match</code>多了一个<code>SupervisorTimer</code>分支, 处理方式就是简单地再次设置下一次中断时间, 并且挂起当前任务, 找下一个任务运行</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>之前说了这么多, 可能思路还是比较乱, 比如<code>trap</code>和中断之前的处理调用逻可能不清楚, 这里我梳理了下面的流程图:</p><p><img src="/../../../images/LearningOS/ch3-switch.png" alt="ch3-switch"></p><p>可以看到, <code>task0</code>第一次主动让出CPU, 通过<code>ecall</code>简介调用了<code>_switch</code>, 调用的序号为10, 后来在序号19时, <code>task0</code>又从<code>_switch</code>中返回, <strong>这也是<code>_switch</code>的一个核心性质: 调用时和返回时可能经历了多个控制流(不同的线程或进程)</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文不会将原本&lt;code&gt;rCore文档&lt;/code&gt;的内容重复太多, 主要是补充学习过程中遇到的知识点, 因此还需结合原文使用, 原文在后面的链接中&lt;/p&gt;
&lt;p&gt;这一章在之前的章节中更进一步, 实现了任务调度的功能, 也就是任务不再是之前的批处理系统那样一个接一个地运行</summary>
      
    
    
    
    <category term="训练营笔记" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
    
    <category term="清华大学开源操作系统训练营2023" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A52023/"/>
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="riscv" scheme="http://example.com/tags/riscv/"/>
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>清华大学开源操作系统训练营: rCore chapter2笔记</title>
    <link href="http://example.com/2024/02/12/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch2%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/02/12/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch2%E7%AC%94%E8%AE%B0/</id>
    <published>2024-02-12T09:28:26.000Z</published>
    <updated>2024-02-21T16:16:04.678Z</updated>
    
    <content type="html"><![CDATA[<p>本文不会将原本<code>rCore文档</code>的内容重复太多, 主要是补充学习过程中遇到的知识点, 因此还需结合原文使用, 原文在后面的链接中</p><p>之前的章节仅仅是一个裸机运行的应用程序, 这一章节通过特权级的引入实现了S态下的<code>OS</code>和U态下的<code>app</code>, <code>app</code>通过系统调用访问<code>OS</code>, <code>OS</code>通过<code>SBI</code>提供的服务完成系统调用, 不过这一章节没有实现进程或线程切换, 而是将程序一个接一个地运行直到结束。</p><p>完整版官方文档： <a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/index.html">https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/index.html</a></p><p>精简版文档： <a href="https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter2/index.html">https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter2/index.html</a></p><h1 id="1-整体流程"><a href="#1-整体流程" class="headerlink" title="1 整体流程"></a>1 整体流程</h1><p>本章的目的是实现批处理系统，文档中称为<code>邓氏鱼OS</code>, 其内容包括:</p><ol><li>编写<code>Rust应用程序</code>, 并使用链接脚本调整内存布局</li><li>为<code>OS</code>实现系统调用</li><li>将应用程序从<code>efl</code>转化为<code>binary</code>, 和<code>OS</code>的代码链接到一起</li><li>实现批处理的任务调度</li><li>引入用户栈和内核栈</li></ol><h1 id="2-特权级"><a href="#2-特权级" class="headerlink" title="2 特权级"></a>2 特权级</h1><h2 id="2-1-特权级的概念"><a href="#2-1-特权级的概念" class="headerlink" title="2.1 特权级的概念"></a>2.1 特权级的概念</h2><p>下面这摘自官方文档张图展示了<code>riscv</code>中不同的特权级:</p><p><img src="/../../../images/LearningOS/ch2-PrivilegeStack.png" alt="PrivilegeStack"></p><p>RISC-V 定义了以下四个特权级别：</p><ol><li><p><strong>用户级别（User-Level or U-Mode）</strong>:<br>就是图中的<code>App</code>所在的级别, 用户级别是最低的特权级别，普通的应用程序在这个级别上运行。在这个级别上，程序不能直接访问硬件资源，如控制I&#x2F;O和管理内存等。用户级别的代码需要通过<strong>系统调用</strong>（<code>syscalls</code>）与更高特权级别的软件交互来请求服务。而<code>syscalls</code>就是应用程序二进制接口, 图中的<code>ABI</code>。程序在用户级别也称为用户态</p></li><li><p><strong>监督者级别（Supervisor-Level or S-Mode）</strong>:<br>监督者级别是操作系统内核通常运行的特权级别。它允许直接控制和管理硬件资源，包括内存管理单元（MMU）、中断处理等。大多数操作系统的内核，如<code>Linux</code>，会在<code>S-Mode</code>下运行。程序在用户级别也称为内核态。操作系统在态下其实也需要想&#x3D;向更低一级的机器模式提出函数请求，这就是<strong>SBI</strong>所做的事情</p></li><li><p><strong>机器级别（Machine-Level or M-Mode）</strong>:<br>机器级别是最高的特权级别，提供对RISC-V硬件的完全控制。它用于引导系统、处理最底层的中断和异常，以及配置系统的安全和保护设置。固件和监控程序，如我们使用的<code>RustSBI</code>（通常在M-Mode下运行。</p></li><li><p><strong>超级用户级别（Hypervisor-Level or H-Mode）</strong>:<br>超级用户级别是为虚拟化环境设计的特权级别，在<code>RISC-V</code>体系结构中是一个可选的特权级别。它允许运行一个超级监控器（<code>hypervisor</code>），在单个物理硬件平台上虚拟化和管理多个独立的操作系统实例。<code>rCore</code>中不涉及这个级别</p></li></ol><h2 id="2-2-特权级的切换"><a href="#2-2-特权级的切换" class="headerlink" title="2.2 特权级的切换"></a>2.2 特权级的切换</h2><p>官网中的这张图清晰地说明了应用程序如何进行特权级切换:</p><p><img src="/../../../images/LearningOS/ch2-EnvironmentCallFlow.png" alt="EnvironmentCallFlow"></p><p>这张图其实还揭示了另一个细节: 不同特权级的内存空间通常是不一样的, 这就和我们常说的用户栈和内核栈联系起来了</p><h2 id="2-3-特权级切换指令和寄存器"><a href="#2-3-特权级切换指令和寄存器" class="headerlink" title="2.3 特权级切换指令和寄存器"></a>2.3 特权级切换指令和寄存器</h2><h3 id="2-3-1-什么时候会发生特权级切换"><a href="#2-3-1-什么时候会发生特权级切换" class="headerlink" title="2.3.1 什么时候会发生特权级切换?"></a>2.3.1 什么时候会发生特权级切换?</h3><p>在RISC-V中，特权级切换通常在以下场景中发生：</p><ol><li><p><strong>系统调用（System Calls）</strong>：当用户程序需要操作系统提供的服务时，如文件操作、内存分配等，它会执行一个<code>ecall</code>指令来触发一个异常，导致处理器从用户模式（U-Mode）切换到监督者模式（S-Mode）或机器模式（<code>M-Mode</code>），这样操作系统可以安全地提供这些服务。</p></li><li><p><strong>中断（Interrupts）</strong>：当外部设备需要处理器的注意时，它会发送一个中断信号。处理器响应中断信号也会导致特权级切换，通常是从较低的特权级别切换到机器模式（<code>M-Mode</code>），以便中断服务程序可以运行并处理中断。</p></li><li><p><strong>异常（Exceptions）</strong>：当程序执行非法操作（如除以零、访问无权限的内存区域）时，或者出现硬件错误，就会发生异常。这将导致从当前特权级别切换到更高的特权级别，以便异常处理程序可以被执行来处理这些问题。</p></li><li><p><strong>特权级返回（Return from Trap）</strong>：当中断或异常处理完成后，通过执行<code>mret</code>、<code>sret</code>或<code>uret</code>指令返回到发生中断或异常之前的特权级别。如果异常无法被正常处理, 则可能退出不会返回用户态, 而是在更高的特权级中尽显处理(<em>关机蓝屏等就是这些更改特权级处理异常的方式</em>)</p></li></ol><p>通过上述情形可以我们可以看出, 异常控制流(区别与一般的函数控制)和特权级切换有下面的好处:</p><ol><li>保护系统和硬件不收错误的程序的损坏</li><li>提供一层抽象, 便于开发</li></ol><h3 id="2-3-2-特权级切换指令和寄存器"><a href="#2-3-2-特权级切换指令和寄存器" class="headerlink" title="2.3.2 特权级切换指令和寄存器"></a>2.3.2 特权级切换指令和寄存器</h3><ol><li><p>特权级切换指令</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td><strong><code>ecall</code></strong></td><td><strong>从用户态或监督者态触发一个环境调用异常，请求操作系统服务</strong></td></tr><tr><td><code>ebreak</code></td><td>触发一个断点异常，用于调试</td></tr><tr><td><code>mret</code></td><td>从机器模式退出中断或异常处理程序并返回到之前的特权级别</td></tr><tr><td><strong><code>sret</code></strong></td><td><strong>从监督者模式退出中断或异常处理程序并返回到之前的特权级别</strong></td></tr><tr><td><code>uret</code></td><td>从用户模式退出中断或异常处理程序并返回到之前的特权级别</td></tr></tbody></table></li><li><p>特权级切换相关寄存器</p><table><thead><tr><th>寄存器</th><th>描述</th></tr></thead><tbody><tr><td><code>mstatus</code></td><td>保存机器模式的全局状态，包括全局中断使能位和特权级切换的状态</td></tr><tr><td><code>ustatus</code></td><td><code>mstatus</code> 的子集，用于保存用户模式的状态信息</td></tr><tr><td><code>mtvec</code></td><td>保存中断和异常处理例程的基地址（机器模式）</td></tr><tr><td><code>utvec</code></td><td>保存用户模式下中断和异常处理例程的基地址</td></tr><tr><td><code>mepc</code></td><td>保存发生异常时的程序计数器值（机器模式）</td></tr><tr><td><code>uepc</code></td><td>保存用户模式下发生异常时的程序计数器值</td></tr><tr><td><code>mcause</code></td><td>保存最后一次异常或中断的原因（机器模式）</td></tr><tr><td><code>ucause</code></td><td>保存用户模式下最后一次异常或中断的原因</td></tr><tr><td><strong><code>sstatus</code></strong></td><td><strong><code>mstatus</code> 的子集，用于保存监督者模式的状态信息</strong></td></tr><tr><td><strong><code>scause</code></strong></td><td><strong>保存监督者模式下最后一次异常或中断的原因</strong></td></tr><tr><td><strong><code>sepc</code></strong></td><td><strong>保存监督者模式下发生异常时的程序计数器值</strong></td></tr><tr><td><strong><code>stval</code></strong></td><td><strong>给出 <code>Trap</code> 附加信息</strong></td></tr><tr><td><strong><code>stvec</code></strong></td><td><strong>保存监督者模式下中断和异常处理例程的基地址</strong></td></tr></tbody></table></li></ol><h1 id="3-特权级切换"><a href="#3-特权级切换" class="headerlink" title="3 特权级切换"></a>3 特权级切换</h1><h2 id="3-1-系统调用"><a href="#3-1-系统调用" class="headerlink" title="3.1 系统调用"></a>3.1 系统调用</h2><p><code>riscv</code>中的系统调用很简单, 相关的代码我们之前也已经见到过:</p><ol><li>把系统调用的参数按照顺序放在<code>a0~a6</code>寄存器后</li><li>把系统调用号放在<code>a7</code>寄存器</li><li>调用<code>ecall</code>触发系统调用</li><li>在<code>a0</code>处获得系统调用的返回值</li></ol><p>系统调用可以使用<code>Rust</code>内联汇编实现:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::arch::asm;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">syscall</span>(id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>: <span class="type">isize</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(</span><br><span class="line">            <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">inlateout</span>(<span class="string">&quot;x10&quot;</span>) args[<span class="number">0</span>] =&gt; ret,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x11&quot;</span>) args[<span class="number">1</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x12&quot;</span>) args[<span class="number">2</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x17&quot;</span>) id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述汇编代码看不懂, 可以看我的上一篇<code>rCode</code>的笔记中关于内联汇编的介绍</p><h2 id="3-2-特权级切换"><a href="#3-2-特权级切换" class="headerlink" title="3.2 特权级切换"></a>3.2 特权级切换</h2><p>系统调用会发生特权级切换, 特权级切换由于执行环境发生了变化, 要求我们在恢复原来的特权级时(例如从内核态返回用户态), 恢复执行环境的上下文。</p><p>发生特权级切换(执行<code>ecall</code>), 此处以陷入<code>S</code>态为例, 时硬件会帮我们做如下工作:</p><ol><li><code>sstatus</code> 的 <code>SPP</code> 字段会被修改为 <code>CPU</code> 当前的特权级</li><li><code>sepc</code> 会被修改为 <code>Trap</code> 处理完成后默认会执行的下一条指令的地址。</li><li><code>scause</code>&#x2F;<code>stval</code> 分别会被修改成这次 <code>Trap</code> 的原因以及相关的附加信息。</li><li><code>CPU</code> 会跳转到 <code>stvec</code> 所设置的 <code>Trap</code> 处理入口地址，并将当前特权级设置为 <code>S</code> ，然后从<code>Trap</code> 处理入口地址处开始执行。</li></ol><p>上述是硬件自动完成的, 如果有其他的寄存器由于陷入内核态后会被使用, 需要提前被保存, 通常会手动保存在栈里, 这些工作可能是<code>stvec</code>一开始就执行的工作</p><p>当使用<code>sret</code>返回用户态时, 系统会帮我们做下面的工作:</p><ol><li><code>CPU</code> 会将当前的特权级按照 <code>sstatus</code> 的 <code>SPP</code> 字段设置为 <code>U</code> 或者 <code>S</code> ；</li><li><code>CPU</code> 会跳转到 <code>sepc</code> 寄存器指向的那条指令，然后继续执行。</li></ol><p>这里特别说明一下<code>sstatus</code> 的 <code>SPP</code>字段如何设置:</p><ol><li><p>调用 <code>ecall</code> 时：</p><ul><li>当从用户模式（U模式）执行 <code>ecall</code> 并陷入到监督者模式（S模式）时，<code>sstatus</code> 寄存器的 <code>SPP</code> 字段会被设置为 0，表示异常发生前处于用户模式。</li><li>如果是从其他特权级别执行 <code>ecall</code>（例如，在 RISC-V 中还有机器模式 M），<code>SPP</code> 字段会被设置为对应于那个特权级别的值。</li></ul></li><li><p>调用 <code>sret</code> 时：</p><ul><li><code>sret</code> 指令用于从监督者模式（S模式）返回到之前的特权级别。在执行 <code>sret</code> 指令时，<code>SPP</code> 字段的值会被用来决定返回到哪个特权级别（U模式或S模式），并且执行 <code>sret</code> 之后，<code>SPP</code> 字段会被清零。</li><li>如果 <code>SPP</code> 是 0，则在执行 <code>sret</code> 后 CPU 返回到用户模式（U模式）。</li><li>如果 <code>SPP</code> 是 1，则在执行 <code>sret</code> 后 CPU 返回到监督者模式（S模式）。</li></ul></li></ol><h1 id="4-用户代码"><a href="#4-用户代码" class="headerlink" title="4 用户代码"></a>4 用户代码</h1><h2 id="4-1-用户代码概览"><a href="#4-1-用户代码概览" class="headerlink" title="4.1 用户代码概览"></a>4.1 用户代码概览</h2><p>用户代码很简单, 项目源码中有4个用户程序:</p><ol><li><p><code>ch2b_bad_address.rs</code></p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> user_lib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 由于 rustsbi 的问题，该程序无法正确退出</span></span><br><span class="line"><span class="comment">/// &gt; rustsbi 0.2.0-alpha.1 已经修复，可以正常退出</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="meta">#[allow(clippy::zero_ptr)]</span></span><br><span class="line">        (<span class="number">0x0</span> <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>).<span class="title function_ invoke__">write_volatile</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;FAIL: T.T\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 该程序向0地址处写入, 预期会触发<code>page fault</code>并退出</p></li><li><p><code>ch2b_bad_instructions.rs</code></p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> user_lib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 由于 rustsbi 的问题，该程序无法正确退出</span></span><br><span class="line"><span class="comment">/// &gt; rustsbi 0.2.0-alpha.1 已经修复，可以正常退出</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        core::arch::asm!(<span class="string">&quot;sret&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;FAIL: T.T\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 该程序在<code>U模式</code>下使用<code>sret</code>, 应当是非法指令</p></li><li><p><code>ch2b_bad_register.rs</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> user_lib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 由于 rustsbi 的问题，该程序无法正确退出</span></span><br><span class="line"><span class="comment">/// &gt; rustsbi 0.2.0-alpha.1 已经修复，可以正常退出</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sstatus</span>: <span class="type">usize</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        core::arch::asm!(<span class="string">&quot;csrr &#123;&#125;, sstatus&quot;</span>, <span class="title function_ invoke__">out</span>(reg) sstatus);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;(-_-) I get sstatus:&#123;:x&#125;\nFAIL: T.T\n&quot;</span>, sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 该程序在<code>U模式</code>下访问<code>csr</code>寄存器<code>sstatus</code>, 应当也是非法指令</p></li><li><p><code>ch2b_hello_world.rs</code></p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> user_lib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 正确输出：</span></span><br><span class="line"><span class="comment">/// Hello world from user mode program!</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Hello, world from user mode program!&quot;</span>);</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 该程序是唯一正常输出的程序</p></li></ol><h2 id="4-2-用户库user-lib"><a href="#4-2-用户库user-lib" class="headerlink" title="4.2 用户库user_lib"></a>4.2 用户库<code>user_lib</code></h2><p>上述的代码都使用了<code>user_lib</code>库, 也就是<code>user/src</code>下的<code>rust</code>项目, 其作用就是封装了了多个系统调用函数, 每个系统调用都使用对应的系统调用号、参数或地址调用<a href="#3-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><strong>3 系统调用</strong></a>中的<code>syscall</code>函数, 例如:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_exit</span>(exit_code: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_EXIT, [exit_code <span class="keyword">as</span> <span class="type">usize</span>, <span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;sys_exit never returns!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_sleep</span>(sleep_ms: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_SLEEP, [sleep_ms, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_yield</span>() <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_YIELD, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="5-内核代码"><a href="#5-内核代码" class="headerlink" title="5 内核代码"></a>5 内核代码</h1><h2 id="5-1-内核代码和用户代码的链接"><a href="#5-1-内核代码和用户代码的链接" class="headerlink" title="5.1 内核代码和用户代码的链接"></a>5.1 内核代码和用户代码的链接</h2><p>这章的内核系统是和用户代码链接到一起的, 也就是说不存在从文件系统加载<code>elf</code>文件这样的步骤, 毕竟在学习<code>OS</code>的起步阶段, 文件系统离我们还挺遥远的, 具体而言, <code>os/src/main.rs</code>中的这句代码实现了用户代码的链接:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;link_app.S&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><blockquote><p><code>link_app.S</code>是构建脚本<code>build.rs</code>生成的, 其将用户仓库的编译文件夹<code>bin</code>目录下的二进制文件整整合到一起, 名创建各个<code>app</code>的符号</p></blockquote></blockquote><h2 id="5-2-内核的调度"><a href="#5-2-内核的调度" class="headerlink" title="5.2 内核的调度"></a>5.2 内核的调度</h2><h3 id="5-2-1-调度器的数据结构"><a href="#5-2-1-调度器的数据结构" class="headerlink" title="5.2.1 调度器的数据结构"></a>5.2.1 调度器的数据结构</h3><p>内核调度是按照顺序一个接一个地调用用户应用, 其主要数据结构为:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AppManager</span> &#123;</span><br><span class="line">    num_app: <span class="type">usize</span>,</span><br><span class="line">    current_app: <span class="type">usize</span>,</span><br><span class="line">    app_start: [<span class="type">usize</span>; MAX_APP_NUM + <span class="number">1</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文档中还介绍了<code>Rust</code>相关的语法知识, 后面的章节会整理出来</p><h3 id="5-2-2-加载程序"><a href="#5-2-2-加载程序" class="headerlink" title="5.2.2 加载程序"></a>5.2.2 加载程序</h3><p>最重要的调度函数是<code>load_app</code>, 其功能就是加载程序, 实际上并不是从文件系统加载, 而是从内核的某一个区段进行复制:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">load_app</span>(&amp;<span class="keyword">self</span>, app_id: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> app_id &gt;= <span class="keyword">self</span>.num_app &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;All applications completed!&quot;</span>);</span><br><span class="line">        <span class="keyword">use</span> crate::board::QEMUExit;</span><br><span class="line">        crate::board::QEMU_EXIT_HANDLE.<span class="title function_ invoke__">exit_success</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;[kernel] Loading app_&#123;&#125;&quot;</span>, app_id);</span><br><span class="line">    <span class="comment">// clear app area</span></span><br><span class="line">    core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, APP_SIZE_LIMIT).<span class="title function_ invoke__">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">app_src</span> = core::slice::<span class="title function_ invoke__">from_raw_parts</span>(</span><br><span class="line">        <span class="keyword">self</span>.app_start[app_id] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>,</span><br><span class="line">        <span class="keyword">self</span>.app_start[app_id + <span class="number">1</span>] - <span class="keyword">self</span>.app_start[app_id],</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">app_dst</span> = core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, app_src.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    app_dst.<span class="title function_ invoke__">copy_from_slice</span>(app_src);</span><br><span class="line">    <span class="comment">// Memory fence about fetching the instruction memory</span></span><br><span class="line">    <span class="comment">// It is guaranteed that a subsequent instruction fetch must</span></span><br><span class="line">    <span class="comment">// observes all previous writes to the instruction memory.</span></span><br><span class="line">    <span class="comment">// Therefore, fence.i must be executed after we have loaded</span></span><br><span class="line">    <span class="comment">// the code of the next app into the instruction memory.</span></span><br><span class="line">    <span class="comment">// See also: riscv non-priv spec chapter 3, &#x27;Zifencei&#x27; extension.</span></span><br><span class="line">    asm!(<span class="string">&quot;fence.i&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以从代码看出, 所有的<code>app</code>都是在<code>APP_BASE_ADDRESS</code>地址处运行的, <strong>每个<code>app</code>运行前都需要将其从其二进制代码的地址处复制到<code>APP_BASE_ADDRESS</code>地址处</strong>, 这也是<code>load_app</code>的核心工作</p><h2 id="5-3-Trap上下文切换"><a href="#5-3-Trap上下文切换" class="headerlink" title="5.3 Trap上下文切换"></a>5.3 <code>Trap</code>上下文切换</h2><h3 id="5-3-1-用户栈和内核栈"><a href="#5-3-1-用户栈和内核栈" class="headerlink" title="5.3.1 用户栈和内核栈"></a>5.3.1 用户栈和内核栈</h3><p>正如之前的<a href="#32-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%88%87%E6%8D%A2">3 特权级切换</a>中说明, 特权级切换时需要用栈来保存上下文信息, 因此需要定义内核栈和用户栈:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/batch.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> USER_STACK_SIZE: <span class="type">usize</span> = <span class="number">4096</span> * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> KERNEL_STACK_SIZE: <span class="type">usize</span> = <span class="number">4096</span> * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(align(4096))]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">KernelStack</span> &#123;</span><br><span class="line">    data: [<span class="type">u8</span>; KERNEL_STACK_SIZE],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(align(4096))]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UserStack</span> &#123;</span><br><span class="line">    data: [<span class="type">u8</span>; USER_STACK_SIZE],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> KERNEL_STACK: KernelStack = KernelStack &#123; data: [<span class="number">0</span>; KERNEL_STACK_SIZE] &#125;;</span><br><span class="line"><span class="keyword">static</span> USER_STACK: UserStack = UserStack &#123; data: [<span class="number">0</span>; USER_STACK_SIZE] &#125;;</span><br></pre></td></tr></table></figure><h3 id="5-3-2-上下文信息"><a href="#5-3-2-上下文信息" class="headerlink" title="5.3.2 上下文信息"></a>5.3.2 上下文信息</h3><p>本来不打算分析代码, 但这里的代码贯穿了整个<code>OS</code>, 所以特别介绍一下:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> riscv::register::sstatus::&#123;<span class="keyword">self</span>, Sstatus, SPP&#125;;</span><br><span class="line"><span class="comment">/// Trap Context</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TrapContext</span> &#123;</span><br><span class="line">    <span class="comment">/// general regs[0..31]</span></span><br><span class="line">    <span class="keyword">pub</span> x: [<span class="type">usize</span>; <span class="number">32</span>],</span><br><span class="line">    <span class="comment">/// CSR sstatus      </span></span><br><span class="line">    <span class="keyword">pub</span> sstatus: Sstatus,</span><br><span class="line">    <span class="comment">/// CSR sepc</span></span><br><span class="line">    <span class="keyword">pub</span> sepc: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TrapContext</span> &#123;</span><br><span class="line">    <span class="comment">/// set stack pointer to x_2 reg (sp)</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_sp</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, sp: <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x[<span class="number">2</span>] = sp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// init app context</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">app_init_context</span>(entry: <span class="type">usize</span>, sp: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sstatus</span> = sstatus::<span class="title function_ invoke__">read</span>(); <span class="comment">// CSR sstatus</span></span><br><span class="line">        sstatus.<span class="title function_ invoke__">set_spp</span>(SPP::User); <span class="comment">//previous privilege mode: user mode</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cx</span> = <span class="keyword">Self</span> &#123;</span><br><span class="line">            x: [<span class="number">0</span>; <span class="number">32</span>],</span><br><span class="line">            sstatus,</span><br><span class="line">            sepc: entry, <span class="comment">// entry point of app</span></span><br><span class="line">        &#125;;</span><br><span class="line">        cx.<span class="title function_ invoke__">set_sp</span>(sp); <span class="comment">// app&#x27;s user stack pointer</span></span><br><span class="line">        cx <span class="comment">// return initial Trap Context of app</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段 <code>Rust</code> 代码定义了<code>TrapContext</code> 的结构体，它用于保存程序的上下文，即在发生异常或中断时需要保存的状态信息，以便之后能够恢复执行, 包括通用寄存器、特殊控制状态寄存器（如 <code>sstatus</code> 和 <code>sepc</code>）等。同时实现了每个<code>app</code>的上下文初始化方法</p><h3 id="5-3-3-app调度"><a href="#5-3-3-app调度" class="headerlink" title="5.3.3 app调度"></a>5.3.3 <code>app</code>调度</h3><p>上面的上下文在什么时候回被访问呢? 首先看看调度<code>app</code>的函数:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run_next_app</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">app_manager</span> = APP_MANAGER.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">current_app</span> = app_manager.<span class="title function_ invoke__">get_current_app</span>();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        app_manager.<span class="title function_ invoke__">load_app</span>(current_app);</span><br><span class="line">    &#125;</span><br><span class="line">    app_manager.<span class="title function_ invoke__">move_to_next_app</span>();</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(app_manager);</span><br><span class="line">    <span class="comment">// before this we have to drop local variables related to resources manually</span></span><br><span class="line">    <span class="comment">// and release the resources</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">__restore</span>(cx_addr: <span class="type">usize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __restore(KERNEL_STACK.<span class="title function_ invoke__">push_context</span>(TrapContext::<span class="title function_ invoke__">app_init_context</span>(</span><br><span class="line">            APP_BASE_ADDRESS,</span><br><span class="line">            USER_STACK.<span class="title function_ invoke__">get_sp</span>(),</span><br><span class="line">        )) <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Unreachable in batch::run_current_app!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, <code>load_app</code>已经通过<code>load_app</code>将指定的内容加载到了内存的固定位置, 然后运行这个程序调用的是<code>__restore</code>, 这是什么? 这是<code>trap.S</code>中用汇编代码写的上下文切换时的保存和回复寄存器的函数, 接下来将仔细解读</p><h3 id="5-3-4-Trap恢复上下文"><a href="#5-3-4-Trap恢复上下文" class="headerlink" title="5.3.4 Trap恢复上下文"></a>5.3.4 <code>Trap</code>恢复上下文</h3><p>首先, 还是贴出<code>trap.S</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">.altmacro</span><br><span class="line">.macro SAVE_GP n</span><br><span class="line">    sd x\n, \n*8(sp)</span><br><span class="line">.endm</span><br><span class="line">.macro LOAD_GP n</span><br><span class="line">    ld x\n, \n*8(sp)</span><br><span class="line">.endm</span><br><span class="line">    .section .text</span><br><span class="line">    .globl __alltraps</span><br><span class="line">    .globl __restore</span><br><span class="line">    .align 2</span><br><span class="line">__alltraps:</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    <span class="comment"># now sp-&gt;kernel stack, sscratch-&gt;user stack</span></span><br><span class="line">    <span class="comment"># allocate a TrapContext on kernel stack</span></span><br><span class="line">    addi sp, sp, -34*8</span><br><span class="line">    <span class="comment"># save general-purpose registers</span></span><br><span class="line">    sd x1, 1*8(sp)</span><br><span class="line">    <span class="comment"># skip sp(x2), we will save it later</span></span><br><span class="line">    sd x3, 3*8(sp)</span><br><span class="line">    <span class="comment"># skip tp(x4), application does not use it</span></span><br><span class="line">    <span class="comment"># save x5~x31</span></span><br><span class="line">    .<span class="built_in">set</span> n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        SAVE_GP %n</span><br><span class="line">        .<span class="built_in">set</span> n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    <span class="comment"># we can use t0/t1/t2 freely, because they were saved on kernel stack</span></span><br><span class="line">    csrr t0, sstatus</span><br><span class="line">    csrr t1, sepc</span><br><span class="line">    sd t0, 32*8(sp)</span><br><span class="line">    sd t1, 33*8(sp)</span><br><span class="line">    <span class="comment"># read user stack from sscratch and save it on the kernel stack</span></span><br><span class="line">    csrr t2, sscratch</span><br><span class="line">    sd t2, 2*8(sp)</span><br><span class="line">    <span class="comment"># set input argument of trap_handler(cx: &amp;mut TrapContext)</span></span><br><span class="line">    <span class="built_in">mv</span> a0, sp</span><br><span class="line">    call trap_handler</span><br><span class="line"></span><br><span class="line">__restore:</span><br><span class="line">    <span class="comment"># case1: start running app by __restore</span></span><br><span class="line">    <span class="comment"># case2: back to U after handling trap</span></span><br><span class="line">    <span class="built_in">mv</span> sp, a0</span><br><span class="line">    <span class="comment"># now sp-&gt;kernel stack(after allocated), sscratch-&gt;user stack</span></span><br><span class="line">    <span class="comment"># restore sstatus/sepc</span></span><br><span class="line">    ld t0, 32*8(sp)</span><br><span class="line">    ld t1, 33*8(sp)</span><br><span class="line">    ld t2, 2*8(sp)</span><br><span class="line">    csrw sstatus, t0</span><br><span class="line">    csrw sepc, t1</span><br><span class="line">    csrw sscratch, t2</span><br><span class="line">    <span class="comment"># restore general-purpuse registers except sp/tp</span></span><br><span class="line">    ld x1, 1*8(sp)</span><br><span class="line">    ld x3, 3*8(sp)</span><br><span class="line">    .<span class="built_in">set</span> n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        LOAD_GP %n</span><br><span class="line">        .<span class="built_in">set</span> n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    <span class="comment"># release TrapContext on kernel stack</span></span><br><span class="line">    addi sp, sp, 34*8</span><br><span class="line">    <span class="comment"># now sp-&gt;kernel stack, sscratch-&gt;user stack</span></span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    sret</span><br></pre></td></tr></table></figure><p>该 <code>trap.S</code>用于处理中断和异常。代码中定义了两个全局入口点：<code>__alltraps</code> 用于在中断或异常发生时保存上下文，<code>__restore</code> 用于恢复上下文并返回到用户态或继续执行应用程序。</p><ol><li><p><code>__alltraps</code> 入口点</p><ol><li><code>csrrw sp, sscratch, sp</code>：交换 <code>sscratch</code> 和 <code>sp</code> 的值。<code>sscratch</code> 通常用来暂存用户栈指针，在发生异常时切换到内核栈。</li><li><code>addi sp, sp, -34*8</code>：在内核栈上分配 <code>TrapContext</code> 结构体所需的空间。</li><li>保存通用寄存器到内核栈上。跳过 <code>sp</code>（x2）和 <code>tp</code>（x4），因为 <code>sp</code> 会在后面单独保存，而 <code>tp</code>（线程指针）可能不被应用使用。</li><li>使用 <code>csrr</code> 指令读取 <code>sstatus</code> 和 <code>sepc</code> 寄存器的值，并保存到栈上。</li><li>从 <code>sscratch</code> 寄存器读取用户栈指针，保存到内核栈上。</li><li>将栈指针 <code>sp</code> 的值移到 <code>a0</code> 寄存器，作为 <code>trap_handler</code> 函数的参数（<code>cx: &amp;mut TrapContext</code>）。</li><li>调用 <code>trap_handler</code> 函数处理异常。</li></ol></li><li><p><code>__restore</code> 入口点</p><ol><li><code>mv sp, a0</code>：恢复 <code>sp</code> 寄存器的值，<code>a0</code> 中包含了指向 <code>TrapContext</code> 的指针。</li><li>从内核栈上加载 <code>sstatus</code>、<code>sepc</code> 和用户栈指针到临时寄存器 <code>t0</code>、<code>t1</code> 和 <code>t2</code>。</li><li>使用 <code>csrw</code> 指令恢复 <code>sstatus</code>、<code>sepc</code> 和 <code>sscratch</code> 寄存器的值。</li><li>从内核栈上恢复其他通用寄存器的值（除了 <code>sp</code> 和 <code>tp</code>）。</li><li><code>addi sp, sp, 34*8</code>：释放在内核栈上分配的 <code>TrapContext</code> 空间。</li><li>再次交换 <code>sscratch</code> 和 <code>sp</code> 的值，恢复用户栈指针到 <code>sp</code>。</li><li>执行 <code>sret</code> 指令返回到用户态或应用程序。</li></ol></li></ol><p>另一个值得注意的点是, <code>__restore</code> 在两种情况下被使用，它既是异常处理完毕后恢复应用程序状态的入口点，也是应用程序第一次开始执行时的入口点。在应用程序第一次开始执行时，<code>__restore</code> 这一步并不是在 “恢复” 任何先前的状态，因为此时还没有任何状态可以恢复。相反，它是在初始化应用程序的执行环境, 具体而言需要再栈中压入构造的<code>Trap Context</code>。在这种情况下，栈上加载的内容（如 <code>sstatus</code>、<code>sepc</code> 和 <code>sscratch</code>）是由操作系统预先设定好的，而不是由之前的应用程序执行状态保存的。这些值会设置为允许应用程序在用户模式下执行的正确状态，并确保了程序计数器（<code>sepc</code>）指向应用程序的入口点。</p><h2 id="5-4-Trap-Handler"><a href="#5-4-Trap-Handler" class="headerlink" title="5.4 Trap Handler"></a>5.4 <code>Trap Handler</code></h2><p>还是先贴出代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/trap/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">trap_handler</span>(cx: &amp;<span class="keyword">mut</span> TrapContext) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> TrapContext &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scause</span> = scause::<span class="title function_ invoke__">read</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stval</span> = stval::<span class="title function_ invoke__">read</span>();</span><br><span class="line">    <span class="keyword">match</span> scause.<span class="title function_ invoke__">cause</span>() &#123;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::UserEnvCall) =&gt; &#123;</span><br><span class="line">            cx.sepc += <span class="number">4</span>;</span><br><span class="line">            cx.x[<span class="number">10</span>] = <span class="title function_ invoke__">syscall</span>(cx.x[<span class="number">17</span>], [cx.x[<span class="number">10</span>], cx.x[<span class="number">11</span>], cx.x[<span class="number">12</span>]]) <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::StoreFault) |</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::StorePageFault) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] PageFault in application, kernel killed it.&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">run_next_app</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::IllegalInstruction) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] IllegalInstruction in application, kernel killed it.&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">run_next_app</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Unsupported trap &#123;:?&#125;, stval = &#123;:#x&#125;!&quot;</span>, scause.<span class="title function_ invoke__">cause</span>(), stval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>trap handler</code>根据<code>scause</code>分类处理, 目前实现了:</p><ol><li>系统调用陷入<code>S</code>态时执行系统调用</li><li>非法指令和页错误直接运行下一个程序</li><li>其余情况直接<code>panic</code></li></ol><p>分发的系统调用目前实现还比较简单, 因为此时还没有页表, 我们的地址都是物理地址, 因此不需要地址转换, 所以没啥好说的, 看项目代码就是了</p><h2 id="5-5-流程图"><a href="#5-5-流程图" class="headerlink" title="5.5 流程图"></a>5.5 流程图</h2><p>下面是我整理的一个示意图, 展示了特权级切换的流程:</p><p><img src="/../../../images/LearningOS/ch2-batchOS.png" alt="switch-process"></p><p>红色表示<code>S</code>态的函数, 蓝色表示<code>U</code>态的函数</p><h1 id="6-补充知识"><a href="#6-补充知识" class="headerlink" title="6 补充知识"></a>6 补充知识</h1><h2 id="6-1-Rust补充知识"><a href="#6-1-Rust补充知识" class="headerlink" title="6.1 Rust补充知识"></a>6.1 <code>Rust</code>补充知识</h2><h3 id="6-1-1-RefCell"><a href="#6-1-1-RefCell" class="headerlink" title="6.1.1 RefCell"></a>6.1.1 <code>RefCell</code></h3><p>在项目代码中, 我们封装了<code>RefCell</code>形成了<code>UPSafeCell</code>, 那么<code>RefCell</code>是什么?</p><p>官方的描述是: <code>RefCell&lt;T&gt;</code> 提供了内部可变性。这意味着即使在 <code>RefCell&lt;T&gt;</code> 的引用是不可变的情况下，也可以改变它所包含的值。这违反了 Rust 的借用规则——即通常情况下，不能同时拥有可变和不可变引用，以及不可变引用不能用来改变值。</p><p>简单来说，就是<code>Rust</code>的编译器检查太严格了, 当我们编写底层代码时, 编译时想绕过不可变借用的检查就可以使用<code>RefCell</code>。尤其是这样一个场景： <strong>当需要在一个不可变的引用上修改数据时</strong>。</p><p>不过绕过编译器检查还有运行期检查， <code>RefCell&lt;T&gt;</code> 使用运行时检查来确保借用规则，这是与编译时检查相对的（如通过 <code>&amp;</code> 和 <code>&amp;mut</code> 引用实现的）。从 <code>RefCell&lt;T&gt;</code> 中借用值时，如果违反了借用规则（例如，尝试进行两个可变借用或同时进行一个可变借用和任意数量的不可变借用），它会导致程序在运行时 <code>panic</code>。</p><p>下面是 <code>RefCell&lt;T&gt;</code> 的一个简单例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过value.borrow_mut()来借用可变引用。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">value_borrow_mut</span> = value.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">    *value_borrow_mut += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这时，value已经被可变地借用，所以尝试再次借用会导致panic！</span></span><br><span class="line">    <span class="comment">// 下面的行如果取消注释，将会在运行时产生panic。</span></span><br><span class="line">    <span class="comment">// let value_borrow_mut2 = value.borrow_mut();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;value: &#123;&#125;&quot;</span>, value_borrow_mut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个可变引用离开作用域，所以可以再次借用。</span></span><br><span class="line">    <span class="title function_ invoke__">drop</span>(value_borrow_mut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在可以再次借用，因为之前的可变引用已经结束。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value_borrow</span> = value.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;value: &#123;&#125;&quot;</span>, value_borrow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-2-bitflags"><a href="#6-1-2-bitflags" class="headerlink" title="6.1.2 bitflags"></a>6.1.2 <code>bitflags</code></h3><p>我们看到项目代码中使用<code>bitflags!</code>宏来创建各种掩码并进行掩码操作，官方地说就是创建一个或多个位标志的集合。这些位标志通常用于表示一组开关或状态，每个开关或状态可以独立开启或关闭，通常用于配置选项或权限设置等场景。&#96;</p><p><code>bitflags</code>是社区包，需要在<code>Cargo.toml</code>文件中添加<code>bitflags crate</code>作为依赖。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">bitflags</span> = <span class="string">&quot;1.0&quot;</span></span><br></pre></td></tr></table></figure><p>下面是一个标志位使用的案例:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入`bitflags`宏</span></span><br><span class="line"><span class="keyword">use</span> bitflags::bitflags;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用`bitflags!`宏定义一个名为`Flags`的位标志类型</span></span><br><span class="line"><span class="built_in">bitflags!</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Flags</span>: <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> FLAG_A = <span class="number">0b00000001</span>;</span><br><span class="line">        <span class="keyword">const</span> FLAG_B = <span class="number">0b00000010</span>;</span><br><span class="line">        <span class="keyword">const</span> FLAG_C = <span class="number">0b00000100</span>;</span><br><span class="line">        <span class="keyword">const</span> FLAG_D = <span class="number">0b00001000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个新的Flags实例，初始没有任何标志设置</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">flags</span> = Flags::<span class="title function_ invoke__">empty</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置FLAG_A和FLAG_C</span></span><br><span class="line">    flags.<span class="title function_ invoke__">insert</span>(Flags::FLAG_A | Flags::FLAG_C);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查FLAG_B是否被设置</span></span><br><span class="line">    <span class="keyword">if</span> flags.<span class="title function_ invoke__">contains</span>(Flags::FLAG_B) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Flag B is set.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Flag B is not set.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除FLAG_A</span></span><br><span class="line">    flags.<span class="title function_ invoke__">remove</span>(Flags::FLAG_A);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换FLAG_D的状态</span></span><br><span class="line">    flags.<span class="title function_ invoke__">toggle</span>(Flags::FLAG_D);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有设置的标志</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Current flags: &#123;:?&#125;&quot;</span>, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>Flags</code>是一个包含四个位标志的新类型：<code>FLAG_A</code>、<code>FLAG_B</code>、<code>FLAG_C</code>和<code>FLAG_D</code>。</li><li>每个标志都赋予了不同的位模式，使得它们可以独立设置和清除。</li><li><code>Flags::empty()</code>创建了一个没有任何标志设置的<code>Flags</code>实例。</li><li><code>insert</code>方法用来设置特定的标志。</li><li><code>contains</code>方法用来检查特定的标志是否已经设置。</li><li><code>remove</code>方法用来清除特定的标志。</li><li><code>toggle</code>方法用来切换特定标志的状态。</li></ul><h3 id="6-1-3-lazy-static"><a href="#6-1-3-lazy-static" class="headerlink" title="6.1.3 lazy_static"></a>6.1.3 <code>lazy_static</code></h3><p><code>lazy_static</code>主要用于这样的需求: 想要创建一个全局变量, 但其初始化的值在编写代码时还不知道, 需要稍后初始化。在<code>Rust</code>中, 如果创建全局变量后再初始化会很繁琐, <code>lazy_static</code>简化了以上需求的操作难度</p><p>使用 <code>lazy_static</code> 创建的静态变量是线程安全的，并且保证只初始化一次。初始化发生在变量首次被访问的时候，并且如果初始化过程中发生了 <code>panic</code>，后续尝试访问该变量将会导致 <code>panic</code>。</p><p>下面是一个 <code>lazy_static</code> 的简单例子：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">lazy_static</span> = <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> lazy_static;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> MY_MAP: HashMap&lt;<span class="type">u32</span>, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">m</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        m.<span class="title function_ invoke__">insert</span>(<span class="number">0</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        m.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        m</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The entry for `0` is \&quot;&#123;&#125;\&quot;.&quot;</span>, MY_MAP.<span class="title function_ invoke__">get</span>(&amp;<span class="number">0</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>MY_MAP</code> 是一个 <code>HashMap</code>，它在首次被 <code>main</code> 函数中的 <code>println!</code> 宏访问时被创建和初始化。由于 <code>lazy_static</code> 保证了线程安全和只初始化一次，<code>MY_MAP</code> 可以在程序的任何地方安全地使用，就像其他静态变量一样。</p><h3 id="6-1-4-drain"><a href="#6-1-4-drain" class="headerlink" title="6.1.4 drain"></a>6.1.4 <code>drain</code></h3><p><code>drain</code>是<code>String</code>类型的方法，用来移除并遍历字符串的一部分内容。<code>drain</code> 方法会在原地修改 <code>String</code>，并返回一个迭代器，该迭代器提供被移除部分的字符。</p><p>使用 <code>drain</code> 方法时，需要指定一个范围来表明想要从字符串中移除哪些字符。范围是采用字节索引而非字符索引，这意味着必须确保范围的边界落在有效的<code>UTF-8字</code>符边界上，否则程序会在运行时<code>panic</code></p><p>以下是一个使用 <code>drain</code> 方法的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="comment">// 移除字符串中的 &quot;world&quot; 部分</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">drained</span>: <span class="type">String</span> = s.<span class="title function_ invoke__">drain</span>(<span class="number">7</span>..<span class="number">12</span>).<span class="title function_ invoke__">collect</span>(); <span class="comment">// world</span></span><br><span class="line">    <span class="comment">// 输出被移除的部分</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Drained part: &#123;&#125;&quot;</span>, drained);</span><br><span class="line">    <span class="comment">// 输出修改后的字符串</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Remaining string: &#123;&#125;&quot;</span>, s); <span class="comment">// &quot;Hello, !</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-5-项目代码中使用过的宏"><a href="#6-1-5-项目代码中使用过的宏" class="headerlink" title="6.1.5 项目代码中使用过的宏"></a>6.1.5 项目代码中使用过的宏</h3><p>下面是我整理的项目代码中使用的<code>rust</code>宏的含义, 这些宏大概了解其作用就可以, 在需要用时知道查什么关键字即可:<br>以下是对所提供的 Rust 属性和宏的解释，整理成 Markdown 表格的形式：</p><table><thead><tr><th>宏&#x2F;属性</th><th>解释</th></tr></thead><tbody><tr><td><code>#[repr(align(4096))]</code></td><td>设置结构体或枚举的内存对齐方式为 4096 字节。</td></tr><tr><td><code>#![feature(panic_info_message)]</code></td><td>允许使用实验性的 <code>panic_info_message</code> 功能，此功能允许访问 panic 信息中的消息内容。</td></tr><tr><td><code>#[macro_use]</code></td><td>允许在当前作用域中使用外部 <code>crate</code> 中定义的宏。</td></tr><tr><td><code>use core::arch::global_asm;</code></td><td>引入 <code>global_asm!</code> 宏，允许在 <code>Rust</code> 代码中嵌入全局汇编指令。</td></tr><tr><td><code>#[path = &quot;boards/qemu.rs&quot;]</code> <code>mod board</code>;</td><td>指定模块文件的路径，这里是将模块文件定位到 <code>boards/qemu.rs</code>。</td></tr><tr><td><code>#[no_mangle]</code></td><td>禁用名称修饰，确保编译器生成的函数名称与在 <code>Rust</code> 中声明的名称相同。</td></tr><tr><td><code>#[inline(always)]</code></td><td>告诉编译器总是内联一个函数，无论编译器优化策略如何。</td></tr><tr><td><code>#[linkage = &quot;weak&quot;]</code></td><td>指定符号的链接强度为弱链接，允许在多个对象文件中定义相同的全局符号而不会导致链接错误，链接器将选择其中一个定义。</td></tr><tr><td><code>#[link_section = &quot;.text.entry&quot;]</code></td><td>指定函数或静态变量应该放置在特定的链接段中，在这个例子中是一个名为 <code>.text.entry</code> 的段。</td></tr><tr><td><code>#[repr(C)]</code></td><td>设置结构体或枚举的内存布局为 C 语言风格，这在与 C 代码交互时非常有用，因为它能保证字段在内存中的布局与 C 结构体相同。</td></tr><tr><td><code>#![feature(linkage)]</code></td><td>允许使用实验性的 <code>linkage</code> 属性，这个属性用于控制符号的链接方式。</td></tr><tr><td><code>#![feature(alloc_error_handler)]</code></td><td>允许自定义全局内存分配错误处理器。</td></tr><tr><td><code>#![no_std]</code></td><td>表明当前的程序或库不会链接到 <code>Rust</code> 的标准库 <code>std</code>，通常用于裸机或嵌入式编程中，其中资源受限，只能依赖核心库 <code>core</code>。</td></tr><tr><td><code>#![no_main]</code></td><td>禁用 <code>Rust</code> 默认的入口点，这通常用在裸机或操作系统开发中，因为在这些情况下开发者需要自定义入口点。</td></tr></tbody></table><h3 id="6-1-6-build-rs构建脚本"><a href="#6-1-6-build-rs构建脚本" class="headerlink" title="6.1.6 build.rs构建脚本"></a>6.1.6 <code>build.rs</code>构建脚本</h3><p><code>Rust</code> 中，<code>build.rs</code> 是一个特殊的脚本，被称为”构建脚本”（build script）。它在项目构建过程的开始阶段被 <code>Cargo</code>执行。构建脚本通常用于编译时计算或生成代码、构建或链接非 <code>Rust</code> 代码（例如 C 库），或自动生成 <code>Rust</code> 代码之前的某些配置。</p><ol><li>构建脚本是可选的，只有当项目需要在编译前执行特定的任务时才会使用到。这个脚本必须是一个有效的 <code>Rust</code> 程序，<code>Cargo</code> 会将其编译并执行。</li><li>当运行 <code>cargo build</code> 或相关的 <code>Cargo</code> 构建命令时，<code>Cargo</code> 会在编译项目的其余部分之前运行 <code>build.rs</code> 脚本。如果构建脚本执行成功，它可能会通过创建一个 <code>OUT_DIR</code> 环境变量来生成文件，Rust 代码可以在编译时通过 <code>include!</code> 或其他宏来访问这些文件。</li><li>如果 <code>build.rs</code> 脚本生成了编译器指令，它们将作为标准输出打印，并被 Cargo 捕获。这些指令可以包括链接库、设置环境变量、传递编译器标志等。</li></ol><p>在本项目中, <code>build.rs</code>用于生成<code>link_app.S</code>汇编文件, 将<code>user</code>项目编译的二进制文件引入进来：</p><h2 id="6-2-riscv汇编代码补充知识"><a href="#6-2-riscv汇编代码补充知识" class="headerlink" title="6.2 riscv汇编代码补充知识"></a>6.2 riscv汇编代码补充知识</h2><h3 id="6-2-1-变量声明与二进制文件嵌入"><a href="#6-2-1-变量声明与二进制文件嵌入" class="headerlink" title="6.2.1 变量声明与二进制文件嵌入"></a>6.2.1 变量声明与二进制文件嵌入</h3><p>这次新增的<code>riscv</code>汇编代码主要是<code>link_app.S</code>这个文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">    .align 3</span><br><span class="line">    .section .data</span><br><span class="line">    .global _num_app</span><br><span class="line">_num_app:</span><br><span class="line">    .quad 7</span><br><span class="line">    .quad app_0_start</span><br><span class="line">    .quad app_1_start</span><br><span class="line">    .quad app_2_start</span><br><span class="line">    .quad app_3_start</span><br><span class="line">    .quad app_4_start</span><br><span class="line">    .quad app_5_start</span><br><span class="line">    .quad app_6_start</span><br><span class="line">    .quad app_6_end</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_0_start</span><br><span class="line">    .global app_0_end</span><br><span class="line">app_0_start:</span><br><span class="line">    .incbin <span class="string">&quot;../user/build/bin/ch2b_bad_address.bin&quot;</span></span><br><span class="line">app_0_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_1_start</span><br><span class="line">    .global app_1_end</span><br><span class="line">app_1_start:</span><br><span class="line">    .incbin <span class="string">&quot;../user/build/bin/ch2b_bad_instructions.bin&quot;</span></span><br><span class="line">app_1_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_2_start</span><br><span class="line">    .global app_2_end</span><br><span class="line">app_2_start:</span><br><span class="line">    .incbin <span class="string">&quot;../user/build/bin/ch2b_bad_register.bin&quot;</span></span><br><span class="line">app_2_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_3_start</span><br><span class="line">    .global app_3_end</span><br><span class="line">app_3_start:</span><br><span class="line">    .incbin <span class="string">&quot;../user/build/bin/ch2b_hello_world.bin&quot;</span></span><br><span class="line">app_3_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_4_start</span><br><span class="line">    .global app_4_end</span><br><span class="line">app_4_start:</span><br><span class="line">    .incbin <span class="string">&quot;../user/build/bin/ch2b_power_3.bin&quot;</span></span><br><span class="line">app_4_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_5_start</span><br><span class="line">    .global app_5_end</span><br><span class="line">app_5_start:</span><br><span class="line">    .incbin <span class="string">&quot;../user/build/bin/ch2b_power_5.bin&quot;</span></span><br><span class="line">app_5_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_6_start</span><br><span class="line">    .global app_6_end</span><br><span class="line">app_6_start:</span><br><span class="line">    .incbin <span class="string">&quot;../user/build/bin/ch2b_power_7.bin&quot;</span></span><br><span class="line">app_6_end:</span><br></pre></td></tr></table></figure><p>上述汇编代码定义类每一个<code>app</code>的起始位置的符号, 设计的新的语法如下:</p><ol><li><code>.quad</code><br>用于定义一个或多个8字节大小的数据元素。每个<code>.quad</code> 表示一个64位（即8字节）的值。这个指令常被用于分配内存空间，并初始化数据段中的常量值。这段代码中,<code>_num_app</code>位置后的<code>quad</code>记录了这7个<code>app</code>的开始位置</li><li><code>.incbin</code><br>直接在当前位置包含（嵌入）一个二进制文件的内容。还可以指定文件中的位置和长度, 例如: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.incbin <span class="string">&quot;data.bin&quot;</span>, 100, 50</span><br></pre></td></tr></table></figure> 这句的含义是: 包含 <code>data.bin</code> 文件从第 100 个字节开始的接下来的 50 个字节</li></ol><h2 id="6-2-2-宏定义"><a href="#6-2-2-宏定义" class="headerlink" title="6.2.2 宏定义"></a>6.2.2 宏定义</h2><p>我们在<code>trap.S</code>中看到了下面的宏定义代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.altmacro</span><br><span class="line">.macro SAVE_GP n</span><br><span class="line">    sd x\n, \n*8(sp)</span><br><span class="line">.endm</span><br><span class="line">.macro LOAD_GP n</span><br><span class="line">    ld x\n, \n*8(sp)</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure><p><code>.altmacro</code> 指令用于开启或关闭“替代宏语法模式”（alternate macro syntax mode）当<code>altmacro</code> 指令出现在文件中时，它会切换当前的宏处理模式。如果在 <code>.altmacro</code> 出现之前是标准宏模式，那么之后就会切换到替代宏模式；反之亦然。</p><p>在替代宏模式下，可以使用 <code>\()</code> 来对参数进行求值，允许宏内部对参数进行算术运算。此外，还可以使用更复杂的字符串处理功能，比如连接字符串或使用条件表达式。</p><p>在这里，<code>.altmacro</code> 可能是用来确保宏定义中的 <code>\n</code> 参数可以正常地被替换和计算。在 <code>.altmacro</code> 模式下，宏 <code>SAVE_GP</code> 和 <code>LOAD_GP</code> 中的 <code>\n</code> 会在宏展开时被实际传递的参数值所替换，并计算出正确的偏移量。</p><p>例如，如果使用 <code>SAVE_GP 2</code>，替代宏模式会确保宏展开为 <code>sd x2, 16(sp)</code>，这会将 <code>x2</code> 寄存器的内容保存到栈指针（<code>sp</code>）地址加上 16 字节处的内存位置（因为 <code>2 * 8 = 16</code>）。同理，<code>LOAD_GP</code> 宏则用于从相同的内存位置将数据加载回 <code>x2</code> 寄存器。</p><h2 id="6-3-stvec的模式"><a href="#6-3-stvec的模式" class="headerlink" title="6.3 stvec的模式"></a>6.3 <code>stvec</code>的模式</h2><p><code>stvec</code> 存储处理器在发生异常或中断时跳转到的异常处理基地址（<code>trap handler</code>的入口地址）。<code>stvec</code> 寄存器有两种模式：</p><ol><li><code>Direct Mode</code> (直接模式)<br>在直接模式下，当异常发生时，处理器会跳转到 <code>stvec</code> 寄存器中设置的地址开始执行异常处理程序。所有的异常和中断都会导致处理器跳转到这个单一的入口点，然后由异常处理程序根据异常原因码来处理不同的情况。</li><li><code>Vectored Mode</code> (向量模式)<br>在向量模式下，<code>stvec</code> 寄存器中的地址是中断向量表的基地址。当异常发生时，处理器会根据异常类型的不同来计算跳转地址。每种异常类型有一个固定的偏移量，处理器会将这个偏移量加到基地址上，计算得到对应的异常处理程序的地址，并跳转到该地址执行。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文不会将原本&lt;code&gt;rCore文档&lt;/code&gt;的内容重复太多, 主要是补充学习过程中遇到的知识点, 因此还需结合原文使用, 原文在后面的链接中&lt;/p&gt;
&lt;p&gt;之前的章节仅仅是一个裸机运行的应用程序, 这一章节通过特权级的引入实现了S态下的&lt;code&gt;OS&lt;/code</summary>
      
    
    
    
    <category term="训练营笔记" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
    
    <category term="清华大学开源操作系统训练营2023" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A52023/"/>
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="riscv" scheme="http://example.com/tags/riscv/"/>
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>CMU15445 2022 project1: 缓存池(可扩展哈希+LRU-K)</title>
    <link href="http://example.com/2024/02/12/CMU15445/proj1/"/>
    <id>http://example.com/2024/02/12/CMU15445/proj1/</id>
    <published>2024-02-12T06:51:11.000Z</published>
    <updated>2024-02-21T16:16:04.637Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍第一个<code>project: buffer poll</code>的实现思路<br>由于课程老师不允许放出自己的代码实现, 因此我只会涉及大概的实现思路, 而不涉及代码细节</p><p>官方<code>project</code>文档: <a href="https://15445.courses.cs.cmu.edu/fall2022/project1/">https://15445.courses.cs.cmu.edu/fall2022/project1/</a></p><h1 id="1-项目目标"><a href="#1-项目目标" class="headerlink" title="1 项目目标"></a>1 项目目标</h1><p>本项目要实现的缓存池结构如下:</p><ol><li>实现一个可扩展哈希表, 将数据库中的一个<code>page</code>从磁盘缓存到内存中, 并且维持从<code>page_id</code>到<code>page</code>得到映射关系</li><li>当<code>page</code>的大小超出容量时, 使用<code>lru-k</code>进行替换</li></ol><h1 id="2-可扩展哈希"><a href="#2-可扩展哈希" class="headerlink" title="2 可扩展哈希"></a>2 可扩展哈希</h1><h2 id="2-1-整体介绍"><a href="#2-1-整体介绍" class="headerlink" title="2.1 整体介绍"></a>2.1 整体介绍</h2><p>可扩展哈希（Extendible Hashing）是一种动态哈希技术，适用于数据库和文件系统中的索引结构，特别是在处理大量增减变化的数据集时。可扩展哈希表的主要特点是能根据数据量的变化动态地调整其大小，这样可以维持较均匀的访问性能，无论数据量的多少。</p><h2 id="2-2-工作原理"><a href="#2-2-工作原理" class="headerlink" title="2.2 工作原理"></a>2.2 工作原理</h2><ol><li><p><strong>哈希函数</strong>：<br>可扩展哈希表使用哈希函数对键值进行哈希，生成固定长度的位模式。通常，这个哈希函数产生的位数要比实际使用的位数多，以便表可以在未来扩展。</p></li><li><p><strong>目录结构</strong>：<br>该算法使用一个称为“目录”(<code>directory</code>)的结构，它包含指向数据桶（<code>buckets</code>）的指针。目录的大小取决于当前使用的哈希键的位数，初始时通常很小。</p></li><li><p><strong>桶</strong>：<br> 存储实际数据项（例如键值对）的基本单元。每个桶可以存储一个或多个数据项，其容量通常是预先定义的。</p></li><li><p><strong>桶分裂</strong>：<br>当一个桶满时（即达到预设的装载因子），系统会进行桶分裂（<code>bucket splitting</code>）。分裂时，桶中的数据会根据新的哈希键位重新分配到两个新桶中。</p></li><li><p><strong>目录扩展</strong>：<br>如果所有数据项都使用了当前哈希键的全部位数，且某个桶满了需要分裂，则目录也需要扩展。目录扩展是通过增加哈希键的位数并复制当前目录项来实现的。</p></li><li><p><strong>局部性原理</strong>：<br>可扩展哈希表的一个关键特性是局部性原理，即桶分裂只影响某个特定桶中的记录，而不会影响到整个哈希表。</p></li></ol><h2 id="2-3-插入流程"><a href="#2-3-插入流程" class="headerlink" title="2.3 插入流程"></a>2.3 插入流程</h2><h3 id="2-3-1-流程概述"><a href="#2-3-1-流程概述" class="headerlink" title="2.3.1 流程概述"></a>2.3.1 流程概述</h3><p>整体流程如下:<br>可扩展哈希的插入流程涉及将新的数据项（键值对）添加到哈希表中。以下是插入过程的步骤：</p><ol><li><p><strong>哈希函数计算</strong>：<br>对插入项的键使用哈希函数，得到一个哈希值。这个哈希值包含足够多的位，以支持未来的目录扩展。</p></li><li><p><strong>确定目标桶</strong>：<br>使用哈希值的前几位（称为“全局深度”）来确定目标桶。全局深度是指目录中用于索引的位数。如果哈希表的目录大小是 $2^d$，那么全局深度就是 <code>d</code>。</p></li><li><p><strong>将数据插入桶</strong>：</p><ol><li>如果目标桶没有满，即其包含的数据项少于桶的最大容量，则直接将数据项插入到该桶中。</li><li><strong>处理桶溢出</strong>：<br>如果目标桶已经满了，需要进行桶分裂。桶分裂的基本流程如下：<ol><li><strong>分裂桶</strong>：<br>创建一个新的空桶。将原来的桶中的所有数据项和新插入的数据项根据哈希值的下一位重新分配到这两个桶中。这通常意味着原桶和新桶会根据哈希值的那一位（原本相同的位）分别收集0和1的记录。</li><li><strong>更新目录</strong>：<br>更新目录以反映新的桶分配。这可能需要增加目录的“全局深度”（即索引的位数）。如果分裂的桶的“局部深度”（该桶对应的哈希值的位数）已经等于全局深度，那么在分裂之前，目录需要加倍，即复制一遍，以增加一个位的索引深度。</li><li><strong>重新指向桶指针</strong>：<br>将目录中与原桶相关的指针（那些仅在分裂位上有差异的指针）更新，使一部分指向原桶，另一部分指向新桶。</li><li><strong>重复分裂（如有必要）</strong>：<br>如果在分裂后新插入的项还是无法被放入桶中（因为原桶中其他项与它有相同的新哈希值），则需要重复分裂过程。</li><li><strong>完成插入</strong>：<br>当桶分裂和目录更新完成后，确保所有的数据项都被正确地放入桶中，包括新插入的数据项。</li></ol></li></ol></li></ol><p>这个过程确保了可扩展哈希表可以根据数据量的变化动态调整，同时保持常数时间的平均插入性能。由于目录的深度和桶指针的更新是有限的，所以插入过程通常很高效。</p><h3 id="2-3-2-图解插入"><a href="#2-3-2-图解插入" class="headerlink" title="2.3.2 图解插入"></a>2.3.2 图解插入</h3><p>接下来结合插入的图例解释其工作原理:</p><p><img src="/../../images/CMU15445/Extendible-Hash-Table.png"></p><p>通过上图我们可以明显看到可扩展哈希的下面几个特点:</p><ol><li>不同目录项可以指向相同的<code>bucket</code></li><li>每次超出<code>bucket</code>容量时, 只有超出<code>bucket</code>容量的那一个<code>bucket</code>需要<code>rehash</code>, 其余<code>bucket</code>保持不变</li><li>每一个<code>bucket</code>有自己的深度, 全局的深度等于所有<code>bucket</code>的深度的最大值</li><li><code>global_depth &lt;&lt; 1== len(directory)</code></li></ol><p><strong>此处详细说明图中<code>IndexOf</code>的含义:</strong><br><code>IndexOf</code>就是寻找<code>bucket</code>的序号, 将<code>key</code>进行<code>hash</code>后取<code>某几个低位</code>得到<code>bucket</code>的序号, <code>某几个低位</code>正是通过全局的<code>global_depth</code>确定的, <code>global_depth</code>就是指定了低位的数量, 以最后一次插入的<code>(5, &quot;e&quot;)</code>为例:</p><ol><li><code>hash(5) = 5</code>;</li><li>5的二进制表示是<code>0b101</code>, 此时的<code>global_depth</code>为2, 所以取低2为<code>0b01</code>, 目标<code>bucket</code>的序号为1</li><li>向1号<code>bucket</code>插入<code>(5, &quot;e&quot;)</code>, 容量足够, 插入成功</li></ol><h2 id="2-4-删除流程"><a href="#2-4-删除流程" class="headerlink" title="2.4 删除流程"></a>2.4 删除流程</h2><p>由于本项目不需要实现哈希的收缩, 因此删除流程只需要将指定<code>bucket</code>中的元素删除即可</p><h1 id="3-LRU-K替换策略"><a href="#3-LRU-K替换策略" class="headerlink" title="3 LRU-K替换策略"></a>3 <code>LRU-K</code>替换策略</h1><h2 id="3-1-LRU-K工作原理"><a href="#3-1-LRU-K工作原理" class="headerlink" title="3.1 LRU-K工作原理"></a>3.1 <code>LRU-K</code>工作原理</h2><p><code>LRU-K</code> 是传统的最近最少使用（<code>LRU</code>）算法的扩展。在 <code>LRU</code> 算法中，当需要替换一个页面时，选择最长时间未被访问的页面进行替换。而 <code>LRU-K</code> 算法则进一步利用了页面的访问历史信息，不仅考虑最后一次访问时间，还考虑到最后 <code>K</code> 次的访问时间。</p><p><code>LRU-K</code> 跟踪并记录每个页面最后 K 次被访问的时间。它使用这些历史访问数据来预测每个页面未来被访问的可能性。</p><p>具体而言, <code>LRU-K</code>按照下面的规则来移除元素:</p><ol><li><p><strong>寻找访问次数低于 K 次的页面</strong>：首先检查是否有页面的访问次数低于 <code>K</code> 次。如果有，这些页面是候选被替换的对象，因为它们相对来说是最不常用的。在这些页面中，选取最新访问时间戳最旧的页面进行替换。</p></li><li><p><strong>寻找访问次数达到 K 次的页面</strong>：如果所有的页面访问次数都达到了 <code>K</code> 次，则从这些页面中选择最新的第 <code>K</code> 次访问时间戳最旧的页面进行替换。这表示即使页面被频繁访问，但如果它的“第 <code>K</code> 次”访问已经很久远了，那么它可能在未来一段时间内不会再次被访问，因此成为了替换的目标。</p></li></ol><h2 id="3-2-实现思路"><a href="#3-2-实现思路" class="headerlink" title="3.2 实现思路"></a>3.2 实现思路</h2><h3 id="3-2-1-数据结构"><a href="#3-2-1-数据结构" class="headerlink" title="3.2.1 数据结构"></a>3.2.1 数据结构</h3><p>可以看到, 传统的<code>LRU</code>直接移除时间戳最久的一个元素, 但<code>LRU-K</code>需要分为<code>访问次数低于 K 次</code>和<code>访问次数达到 K 次</code>2中情况, 在这2种情况下, 其移除的思路和传统的<code>LRU</code>是一样的。</p><p>由于我们的<code>LRU-K</code>是作为缓存池的一部分使用的，其更新、删除、读取都有时间复杂度的要求，查询最容易想到哈希表， 而插入和删除最容易想到的是链表， 因此可以结合这2个数据结构实现，由于2个情况都可以看做是传统<code>LRU</code>的实现, 因此可以用如下的数据结构实现:</p><ol><li>低于 <code>K</code> 次的页面记录数据结构<ol><li>双向链表: <code>list_less_k</code>: 按照最新访问顺序记录页面<code>id</code></li><li>哈希表: <code>map_less_k</code>: 记录页面在<code>list_less_k</code>中的位置(也就是迭代器), 以便快速删除</li></ol></li><li>达到 <code>K</code> 次的页面记录数据结构<ol><li>双向链表: <code>list_reach_k</code>: 按照最新访问顺序记录页面<code>id</code></li><li>哈希表: <code>map_reach_k</code>: 记录页面在<code>list_reach_k</code>中的位置(也就是迭代器), 以便快速删除</li></ol></li><li>全局计数器<code>map_count</code>: 记录每个页面<code>id</code>的访问次数, 控制页面从<code>list_less_k</code>&#x2F;<code>map_less_k</code>转移到<code>list_reach_k</code>&#x2F;<code>map_reach_k</code></li></ol><h3 id="3-2-2-记录和删除"><a href="#3-2-2-记录和删除" class="headerlink" title="3.2.2 记录和删除"></a>3.2.2 记录和删除</h3><h4 id="3-2-2-1-新增访问记录"><a href="#3-2-2-1-新增访问记录" class="headerlink" title="3.2.2.1 新增访问记录"></a>3.2.2.1 新增访问记录</h4><p>记访问记录的页面为<code>id</code></p><ol><li>从<code>map_count</code>中查看<code>id</code>的访问次数</li><li>如果访问次数达到了<code>k</code>次<ol><li>将<code>id</code>的记录从<code>list_reach_k</code>和<code>map_reach_k</code>中删除</li><li>将<code>id</code>重新插入<code>list_reach_k</code>, 并更新这个新的头部或者尾部位置(取决于链表的排序是从新到旧还是从旧到新)的迭代器到<code>map_reach_k</code></li><li>更新<code>map_count</code>计数</li></ol></li><li>如果访问次数不到<code>k</code>次<ol><li>如果访问次数是<code>k-1</code>次<ol><li>由于这次更新后就达到了<code>k</code>次, 需要将<code>id</code>从<code>list_less_k</code>和<code>map_less_k</code>中删除</li><li>将<code>id</code>插入<code>list_reach_k</code>, 并更新这个新的头部或者尾部位置(取决于链表的排序是从新到旧还是从旧到新)的迭代器到<code>map_reach_k</code></li><li>更新<code>map_count</code>计数</li></ol></li><li>如果访问次数小于<code>k-1</code>次<ol><li>将<code>id</code>从<code>list_less_k</code>和<code>map_less_k</code>中删除</li><li>将<code>id</code>重新插入<code>list_less_k</code>, 并更新这个新的头部或者尾部位置(取决于链表的排序是从新到旧还是从旧到新)的迭代器到<code>map_less_k</code></li><li>更新<code>map_count</code>计数</li></ol></li></ol></li></ol><h4 id="3-2-2-2-替换策略"><a href="#3-2-2-2-替换策略" class="headerlink" title="3.2.2.2 替换策略"></a>3.2.2.2 替换策略</h4><ol><li>如果<code>list_less_k</code>不为空<ol><li>移除<code>list_less_k</code>头部或尾部的最旧页面号, 同时移除对应的<code>map_less_k</code></li><li>更新对应<code>map_count</code>计数为0, 表示没有在缓存池中</li></ol></li><li>如果<code>list_less_k</code>为空<ol><li>移除<code>list_reach_k</code>头部或尾部的最旧页面号, 同时移除对应的<code>map_reach_k</code></li><li>更新对应<code>map_count</code>计数为0, 表示没有在缓存池中</li></ol></li></ol><blockquote><blockquote><p>以上的新增和替换思路没有考虑到页面在逻辑上是否可以移除, 因为一个页面尽管长时间没有被访问, 但其数据和加载到内存时发生了变化, 还没有刷入磁盘, 因此不能被移除。在项目代码中， 还需要增加相应的判断，不过这个判断很简单，就没有写到上面的流程里了</p></blockquote></blockquote><h1 id="4-Buffer-Pool"><a href="#4-Buffer-Pool" class="headerlink" title="4 Buffer Pool"></a>4 Buffer Pool</h1><p>之前我们只是一股脑地实现了可扩展哈希和<code>LRU-K</code>, 但实际上却不知道或者不完全知道这些东西和最后实现的缓存池有什么联系, 做完这一小节后这一切都有了答案</p><h2 id="4-1-Buffer-Pool-数据结构"><a href="#4-1-Buffer-Pool-数据结构" class="headerlink" title="4.1 Buffer Pool 数据结构"></a>4.1 Buffer Pool 数据结构</h2><p>首先需要说明<code>Buffer Pool</code>的数据结构:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Number of pages in the buffer pool. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> pool_size_;</span><br><span class="line"><span class="comment">/** The next page id to be allocated  */</span></span><br><span class="line">std::atomic&lt;<span class="type">page_id_t</span>&gt; next_page_id_ = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** Bucket size for the extendible hash table */</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> bucket_size_ = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Array of buffer pool pages. */</span></span><br><span class="line">Page *pages_;</span><br><span class="line"><span class="comment">/** Pointer to the disk manager. */</span></span><br><span class="line">DiskManager *disk_manager_ __attribute__((__unused__));</span><br><span class="line"><span class="comment">/** Pointer to the log manager. Please ignore this for P1. */</span></span><br><span class="line">LogManager *log_manager_ __attribute__((__unused__));</span><br><span class="line"><span class="comment">/** Page table for keeping track of buffer pool pages. */</span></span><br><span class="line">ExtendibleHashTable&lt;<span class="type">page_id_t</span>, <span class="type">frame_id_t</span>&gt; *page_table_;</span><br><span class="line"><span class="comment">/** Replacer to find unpinned pages for replacement. */</span></span><br><span class="line">LRUKReplacer *replacer_;</span><br><span class="line"><span class="comment">/** List of free frames that don&#x27;t have any pages on them. */</span></span><br><span class="line">std::list&lt;<span class="type">frame_id_t</span>&gt; free_list_;</span><br><span class="line"><span class="comment">/** This latch protects shared data structures. We recommend updating this comment to describe what it protects. */</span></span><br><span class="line">std::mutex latch_;</span><br></pre></td></tr></table></figure><p>上面这些都是<code>src/include/buffer/buffer_pool_manager_instance.h</code>中定义的类成员变量, 对其中主要的成员变量说明如下:</p><ol><li><code>pool_size_</code>: 缓存池的容量, 也是之前的<code>LRU-K</code>中的<code>num_frames</code></li><li><code>bucket_size_</code>: 之前的可扩展哈希的桶的容量</li><li><code>pages_</code>: 实际缓存池的页的内容, 是一个数组</li><li><code>disk_manager_</code>: 官方已经实现的从硬盘加载页面的类的实例, 相关函数的作用可以去看头文件</li><li><code>page_table_</code>: 之前实现的可扩展哈希表, 用于快速查找指定的<code>page_id_t</code>在<code>pages_</code>数组中的位置</li><li><code>replacer_</code>: 之前实现的替换类, 用于记录读写记录并在缓存池满时进行替换</li><li><code>free_list_</code>: 空闲链表, 记录的是空闲的页的索引, 也就是在 <code>pages_</code>数组中的下标</li></ol><p>通过上面的分析, 我们对之前实现的可扩展哈希表和<code>LRU-K</code>的作用就已经很明白了, 而且在实现了可扩展哈希表和<code>LRU-K</code>后, 最后这一部分的任务已经很简单了, 简单阅读一下<code>proj</code>文档, 应该就能试着写出来了</p><h2 id="4-2-实现思路"><a href="#4-2-实现思路" class="headerlink" title="4.2 实现思路"></a>4.2 实现思路</h2><h3 id="4-2-1-NewPgImp"><a href="#4-2-1-NewPgImp" class="headerlink" title="4.2.1 NewPgImp"></a>4.2.1 <code>NewPgImp</code></h3><p>要求在缓存池中创建一个新页, 逻辑如下:</p><ol><li>如果<code>pages_</code>中的所有页都不能被替换(<code>GetPinCount() &gt; 0</code>), 返回空指针</li><li>此时创建新页, 如下获取一个新页<ol><li>如果空闲列表<code>free_list_</code>不为空, 从中取一个页</li><li>否则用替换类<code>replacer_</code>驱逐一个页<ol><li>如果驱逐页是脏页, 还需要用<code>disk_manager_</code>写回磁盘</li><li>缓存池哈希表<code>page_table_</code>移除驱逐页</li></ol></li></ol></li><li>在缓存池哈希表<code>page_table_</code>记录新页位置</li><li>更新页的<code>pin_count_</code>和页号</li><li>用替换类<code>replacer_</code>更新新页的访问记录, 并设置其不可驱逐(马上要被使用)</li></ol><h3 id="4-2-2-FetchPgImp"><a href="#4-2-2-FetchPgImp" class="headerlink" title="4.2.2 FetchPgImp"></a>4.2.2 <code>FetchPgImp</code></h3><p>要求从缓存池取出指定页号的页面, 如果页面不存在于缓存池但缓存池没有可以驱逐的页面, 返回空指针, 逻辑如下:</p><ol><li>如果哈希表中存在映射, 说明页存在:<ol><li>自增其<code>pin_count_</code></li><li>用替换类<code>replacer_</code>更新页的访问记录, 并设置其不可驱逐(马上要被使用)</li><li>返回</li></ol></li><li>不存在映射, 需要驱逐<ol><li>如果<code>pages_</code>中的所有页都不能被替换(<code>GetPinCount() &gt; 0</code>), 返回空指针</li><li>分配新页<ol><li>如果空闲列表<code>free_list_</code>不为空, 从中取一个页</li><li>否则用替换类<code>replacer_</code>驱逐一个页<ol><li>如果驱逐页是脏页, 还需要用<code>disk_manager_</code>写回磁盘</li><li>缓存池哈希表<code>page_table_</code>移除驱逐页</li></ol></li></ol></li></ol></li><li>更新新页的<code>pin_count_</code>和页号</li><li>用替换类<code>replacer_</code>更新新页的访问记录, 并设置其不可驱逐(马上要被使用)</li><li>调用<code>disk_manager_</code>的相关方法从硬盘上读取指定页的内容到这个新页</li></ol><h3 id="4-2-3-DeletePgImp"><a href="#4-2-3-DeletePgImp" class="headerlink" title="4.2.3 DeletePgImp"></a>4.2.3 <code>DeletePgImp</code></h3><p>要求在缓存池删除指定页号的页, 逻辑如下:</p><ol><li>如果该页不存在于缓存池, 返回<code>true</code>表示删除成功</li><li>如果该页被占用(<code>GetPinCount() &gt; 0</code>), 返回<code>false</code>表示删除失败</li><li>删除该页<ol><li>从哈希表从移除</li><li>从替换类<code>replacer_</code>中移除</li><li>更新删除页的页号为<code>INVALID_PAGE_ID</code>, 更新<code>pin_count_ = 0</code>, 标记<code>is_dirty_ = false</code></li><li>将该页的索引号放回空闲列表</li><li>返回<code>true</code>表示删除成功</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将介绍第一个&lt;code&gt;project: buffer poll&lt;/code&gt;的实现思路&lt;br&gt;由于课程老师不允许放出自己的代码实现, 因此我只会涉及大概的实现思路, 而不涉及代码细节&lt;/p&gt;
&lt;p&gt;官方&lt;code&gt;project&lt;/code&gt;文档: &lt;a href=&quot;</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CMU15445" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/CMU15445/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="lru-k" scheme="http://example.com/tags/lru-k/"/>
    
    <category term="可扩展哈希" scheme="http://example.com/tags/%E5%8F%AF%E6%89%A9%E5%B1%95%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>Postgresql学习笔记0: 源码安装、gdb调试与VSCode智能提示设置</title>
    <link href="http://example.com/2024/02/12/%E6%95%B0%E6%8D%AE%E5%BA%93/postgres%E5%AD%A6%E4%B9%A0/0-%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/"/>
    <id>http://example.com/2024/02/12/%E6%95%B0%E6%8D%AE%E5%BA%93/postgres%E5%AD%A6%E4%B9%A0/0-%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/</id>
    <published>2024-02-12T01:55:30.000Z</published>
    <updated>2024-02-21T16:16:04.675Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容包括:</p><ol><li>如何从源码安装<code>postgresql-14</code>, 更多信息请参考官方文档: <a href="https://www.postgresql.org/docs/current/">https://www.postgresql.org/docs/current/</a></li><li>如何使用<code>gdb</code>调试<code>postgresql</code></li><li>如何在<code>VSCode</code>中开启<code>postgresql</code>代码的智能提示</li></ol><h1 id="1-编译源码"><a href="#1-编译源码" class="headerlink" title="1 编译源码"></a>1 编译源码</h1><h2 id="1-1-安装依赖"><a href="#1-1-安装依赖" class="headerlink" title="1.1 安装依赖"></a>1.1 安装依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libreadline-dev</span><br></pre></td></tr></table></figure><h2 id="1-2-克隆仓库并编译"><a href="#1-2-克隆仓库并编译" class="headerlink" title="1.2 克隆仓库并编译"></a>1.2 克隆仓库并编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://git.postgresql.org/git/postgresql.git <span class="comment"># 克隆完整仓库</span></span><br><span class="line">git checkout REL_14_STABLE <span class="comment"># 切换到14分支</span></span><br></pre></td></tr></table></figure><p>由于我们源码安装的目的是为了查看源码调试, 所以我们不需要安装到默认的<code>/usr/local/</code>路径, 需要在<code>configure</code>中指定编译安装目录, 同时需要开启一些额外的选项允许后续的<code>gdb</code>调试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /home/toni/pgBuild</span><br><span class="line">./configure --prefix=/home/toni/pgBuild/ --enable-debug --enable-depend --enable-cassert CFLAGS=-O0</span><br></pre></td></tr></table></figure><ol><li><code>--enable-debug</code>: 编译程序时包含额外的调试信息</li><li><code>--enable-depend</code>: 用于生成依赖关系。它使得编译过程中会自动生成 <code>.depend</code> 文件，这些文件包含了源文件之间的依赖信息。这对于开发者在修改代码后只重新编译改变了的部分非常有用。</li><li><code>--enable-cassert</code>: 用于开启断言（assertions）。通常用于开发和调试。它会编译进一些额外的检查，这些检查在标准运行中通常是关闭的，因为它们可能会降低性能。但是在开发过程中，这些检查可以帮助捕捉到代码中的错误。</li><li><code>CFLAGS=-O0</code>: 环境变量设置，用于控制 C 编译器的优化级别。<code>-O0</code> 表示不进行优化，确保了编译器不会改变代码结构，从而使得调试时的代码行为更接近源码。</li></ol><p>然后正常编译即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="1-3-额外编译选项"><a href="#1-3-额外编译选项" class="headerlink" title="1.3 额外编译选项"></a>1.3 额外编译选项</h2><ol><li>编译后测试<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make check</span><br></pre></td></tr></table></figure></li><li>安装额外模块<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make world</span><br></pre></td></tr></table></figure></li></ol><h1 id="2-基本配置"><a href="#2-基本配置" class="headerlink" title="2 基本配置"></a>2 基本配置</h1><h2 id="2-1-配置环境变量"><a href="#2-1-配置环境变量" class="headerlink" title="2.1 配置环境变量"></a>2.1 配置环境变量</h2><p>将安装目录的四个文件夹添加到环境变量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.bashrc</span></span><br><span class="line">PATH=<span class="variable">$PATH</span>:/home/toni/pgBuild/bin</span><br><span class="line">PATH=<span class="variable">$PATH</span>:/home/toni/pgBuild/include</span><br><span class="line">PATH=<span class="variable">$PATH</span>:/home/toni/pgBuild/lib</span><br><span class="line">PATH=<span class="variable">$PATH</span>:/home/toni/pgBuild/share</span><br></pre></td></tr></table></figure><h2 id="2-2-初始化数据库"><a href="#2-2-初始化数据库" class="headerlink" title="2.2 初始化数据库"></a>2.2 初始化数据库</h2><p>新建一个数据库目录并初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p pgData</span><br><span class="line">initdb -D pgData</span><br></pre></td></tr></table></figure><h2 id="2-3-启动数据库并登录"><a href="#2-3-启动数据库并登录" class="headerlink" title="2.3 启动数据库并登录"></a>2.3 启动数据库并登录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pg_ctl -D pgData/ start</span><br></pre></td></tr></table></figure><p>从<code>psql</code>连接数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql postgres</span><br></pre></td></tr></table></figure><p>查看当前登录信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres<span class="operator">=</span># \c</span><br><span class="line">You <span class="keyword">are</span> now connected <span class="keyword">to</span> database &quot;postgres&quot; <span class="keyword">as</span> <span class="keyword">user</span> &quot;toni&quot;.</span><br></pre></td></tr></table></figure><p>可以看到, 初始化数据库目录后, 自动创建了名为<code>postgres</code>的数据库和安装时的用户<code>toni</code></p><h1 id="3-启用gdb调试"><a href="#3-启用gdb调试" class="headerlink" title="3 启用gdb调试"></a>3 启用gdb调试</h1><h2 id="3-1-调试pg-ctl"><a href="#3-1-调试pg-ctl" class="headerlink" title="3.1 调试pg_ctl"></a>3.1 调试<code>pg_ctl</code></h2><p>进入<code>pg_ctl</code>所在的目录, 执行如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb pg_ctl</span><br><span class="line">(gdb) layout src</span><br><span class="line">(gdb) set args -D /home/toni/pgData/ start</span><br><span class="line">(gdb) b main</span><br><span class="line">(gdb) run</span><br></pre></td></tr></table></figure><p>如果成功, 则会看到下图的内容:</p><p><img src="/../../../images/DB/postgresql/gdb-postgres.png" alt="gdb-postgres"></p><h2 id="3-2-postgres主程序的启动"><a href="#3-2-postgres主程序的启动" class="headerlink" title="3.2 postgres主程序的启动"></a>3.2 postgres主程序的启动</h2><p>我们单步调试<code>pg_ctl</code>, 终于发现了程序在这个位置启动主程序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">void</span>) <span class="built_in">execl</span>(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmd, (<span class="type">char</span> *) <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>但是返现其是由<code>exec</code>执行<code>sh</code>后再启动的, 这就不方便我们进行调试了, 不过我们可以通过获取<code>pid</code>后<code>attach</code>的方式进行调试</p><h2 id="3-3-postgresql的进程"><a href="#3-3-postgresql的进程" class="headerlink" title="3.3 postgresql的进程"></a>3.3 <code>postgresql</code>的进程</h2><p>使用<code>pg_ctl</code>启动后, 我们发现<code>potgresql</code>有如下几个进程:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep postgres</span><br><span class="line">toni       38492     355  0 11:18 ?        00:00:00 /home/toni/pgBuild/bin/postgres -D ../pgData</span><br><span class="line">toni       38494   38492  0 11:18 ?        00:00:00 postgres: checkpointer</span><br><span class="line">toni       38495   38492  0 11:18 ?        00:00:00 postgres: background writer</span><br><span class="line">toni       38496   38492  0 11:18 ?        00:00:00 postgres: walwriter</span><br><span class="line">toni       38497   38492  0 11:18 ?        00:00:00 postgres: autovacuum launcher</span><br><span class="line">toni       38498   38492  0 11:18 ?        00:00:00 postgres: stats collector</span><br><span class="line">toni       38499   38492  0 11:18 ?        00:00:00 postgres: logical replication launcher</span><br></pre></td></tr></table></figure><ol><li><p><code>/home/toni/pgBuild/bin/postgres -D ../pgData</code> (<code>PID 38492</code>):<br>这是 PostgreSQL 的主进程（称为 <code>postmaster</code>）。它负责管理数据库系统的整体运行，包括处理客户端连接请求、启动新的子进程来处理这些连接，以及监控所有的子进程。参数 <code>-D ../pgData</code> 指定了数据库的数据目录。</p></li><li><p><code>postgres: checkpointer</code> (<code>PID 38494</code>):<br>检查点进程（checkpointer）负责创建检查点，这是数据库的一个稳定状态，用于数据恢复。检查点包括将缓冲区中的所有脏页（已修改但尚未写入磁盘的数据页）刷新到磁盘中。检查点有助于减少崩溃恢复的时间。</p></li><li><p><code>postgres: background writer</code> (<code>PID 38495</code>):<br>后台写入程序（background writer）进程负责将脏页从缓冲区定期写入磁盘。它可以减轻前端数据库进程的 <code>I/O </code>负载，并且可以平滑 <code>I/O</code> 峰值。</p></li><li><p><code>postgres: walwriter</code> (<code>PID 38496</code>):<br>写前日志（<code>Write-Ahead Logging, WAL</code>）写入器进程负责将 <code>WAL</code> 缓冲区中的记录刷新到磁盘上的 <code>WAL</code> 文件中。<code>WAL</code> 是 <code>PostgreSQL</code> 实现事务持久性和崩溃恢复的关键组成部分。</p></li><li><p><code>postgres: autovacuum launcher</code> (<code>PID 38497</code>):<br>自动清理启动器（autovacuum launcher）进程负责启动自动清理工作进程，这些工作进程负责清理数据库中的“死”元组（即不再可达的数据），并且帮助回收空间、更新统计信息以及防止事务 ID 耗尽。</p></li><li><p><code>postgres: stats collector</code> (<code>PID 38498</code>):<br>统计信息收集器（stats collector）进程负责收集数据库活动的统计信息，比如对于每个表和索引的访问频率等。这些信息对于查询优化器的决策非常重要。</p></li><li><p><code>postgres: logical replication launcher</code> (<code>PID 38499</code>):<br>逻辑复制启动器（logical replication launcher）进程负责管理逻辑复制和订阅功能。它监控逻辑复制工作进程，并在需要时启动新的工作进程以处理逻辑复制任务。</p></li></ol><h2 id="3-4-psql后调试后端进程"><a href="#3-4-psql后调试后端进程" class="headerlink" title="3.4 psql后调试后端进程"></a>3.4 <code>psql</code>后调试后端进程</h2><ol><li><p><strong>获取后端进程<code>pid</code></strong><br>要使用 <code>gdb</code> 调试已经连接到 <code>postmaster</code> 的 <code>psql</code> 会话，需要找到该 <code>psql</code> 会话对应的后端进程 ID, 这可以通过<code>sql</code>语句实现:</p><p> <img src="/../../../images/DB/postgresql/psql-pg_backend_pid.png" alt="pg_backend_pid"></p><p>我得到的进程<code>pid</code>是<code>44765</code>, 此时在另一个终端再次运行<code>ps -ef | grep postgres</code>, 发现多了一个<code>44765</code>的进程, 这个后端进程是响应客户端请求的进程，每个客户端连接都会有一个对应的后端进程。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">toni       38492     355  0 11:18 ?        00:00:00 /home/toni/pgBuild/bin/postgres -D ../pgData</span><br><span class="line">toni       38494   38492  0 11:18 ?        00:00:00 postgres: checkpointer</span><br><span class="line">toni       38495   38492  0 11:18 ?        00:00:00 postgres: background writer</span><br><span class="line">toni       38496   38492  0 11:18 ?        00:00:00 postgres: walwriter</span><br><span class="line">toni       38497   38492  0 11:18 ?        00:00:00 postgres: autovacuum launcher</span><br><span class="line">toni       38498   38492  0 11:18 ?        00:00:00 postgres: stats collector</span><br><span class="line">toni       38499   38492  0 11:18 ?        00:00:00 postgres: logical replication launcher</span><br><span class="line">toni       44765   38492  0 11:42 ?        00:00:00 postgres: toni toni [<span class="built_in">local</span>] idle</span><br></pre></td></tr></table></figure></li><li><p><strong>附加 <code>gdb</code> 到进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gdb -p 44765</span><br></pre></td></tr></table></figure><p>结果如下:<br><img src="/../../../images/DB/postgresql/attach-44765.png" alt="attach-44765"></p><p>这将启动 <code>gdb</code> 并附加到具有指定进程 ID 的进程。</p><p>此时进程在系统调用<code>epoll_wait</code>中, 因此没有源码调试文件</p></li><li><p><code>backtrace</code>追踪调用栈信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(gdb) backtrace</span><br><span class="line"> <span class="comment">#0  0x00007fe42671ffda in epoll_wait (epfd=4, events=0x5615a6ee7c48,</span></span><br><span class="line">     maxevents=1, <span class="built_in">timeout</span>=-1) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30</span><br><span class="line"> <span class="comment">#1  0x00005615a6904d70 in WaitEventSetWaitBlock (set=0x5615a6ee7bd0,</span></span><br><span class="line">     cur_timeout=-1, occurred_events=0x7fffacc2e940, nevents=1) at latch.c:1471</span><br><span class="line"> <span class="comment">#2  0x00005615a6904bd7 in WaitEventSetWait (set=0x5615a6ee7bd0, timeout=-1,</span></span><br><span class="line">     occurred_events=0x7fffacc2e940, nevents=1, wait_event_info=100663296)</span><br><span class="line">     at latch.c:1417</span><br><span class="line"> <span class="comment">#3  0x00005615a673fde1 in secure_read (port=0x5615a6f0e3f0,</span></span><br><span class="line">     ptr=0x5615a6e5b260 &lt;PqRecvBuffer&gt;, len=8192) at be-secure.c:186</span><br><span class="line"> <span class="comment">#4  0x00005615a674b86c in pq_recvbuf () at pqcomm.c:959</span></span><br><span class="line"> <span class="comment">#5  0x00005615a674b951 in pq_getbyte () at pqcomm.c:1005</span></span><br><span class="line"> <span class="comment">#6  0x00005615a693cfd2 in SocketBackend (inBuf=0x7fffacc2eaa0) at postgres.c:352</span></span><br><span class="line"> <span class="comment">#7  0x00005615a693d24f in ReadCommand (inBuf=0x7fffacc2eaa0) at postgres.c:475</span></span><br><span class="line"> <span class="comment">#8  0x00005615a6942bd4 in PostgresMain (argc=1, argv=0x7fffacc2ebd0,</span></span><br><span class="line">     dbname=0x5615a6f18758 <span class="string">&quot;toni&quot;</span>, username=0x5615a6f18738 <span class="string">&quot;toni&quot;</span>)</span><br><span class="line">     at postgres.c:4445</span><br><span class="line"> <span class="comment">#9  0x00005615a6865e1e in BackendRun (port=0x5615a6f0e3f0) at postmaster.c:4540</span></span><br><span class="line"> <span class="comment">#10 0x00005615a6865679 in BackendStartup (port=0x5615a6f0e3f0)</span></span><br><span class="line">     at postmaster.c:4262</span><br><span class="line"> <span class="comment">#11 0x00005615a6861402 in ServerLoop () at postmaster.c:1748</span></span><br><span class="line"> <span class="comment">#12 0x00005615a6860b5f in PostmasterMain (argc=3, argv=0x5615a6ee5d20)</span></span><br><span class="line">     at postmaster.c:1420</span><br><span class="line"> <span class="comment">#13 0x00005615a674f089 in main (argc=3, argv=0x5615a6ee5d20) at main.c:209</span></span><br></pre></td></tr></table></figure><ul><li><p><code>#0</code> - 这是当前停止点，即 <code>epoll_wait</code> 系统调用。这个函数是 <code>Linux</code> 内核提供的，用于等待多个文件描述符上的事件。这里的参数表示正在等待文件描述符 <code>4</code> 上的事件，最多等待 <code>1</code> 个事件，且超时时间设置为 <code>-1</code>，表示无限等待直到有事件发生。</p></li><li><p><code>#1</code> - <code>WaitEventSetWaitBlock</code> 函数是 <code>PostgreSQL</code> 内部的函数。它是封装 <code>epoll_wait</code> 的部分，用于等待一组事件中的任何一个发生。</p></li><li><p><code>#2</code> - <code>WaitEventSetWait</code> 函数是 <code>PostgreSQL</code> 的另一个内部函数，它负责等待事件集合中指定的事件。</p></li><li><p><code>#3</code> - <code>secure_read</code> 函数尝试从安全连接中读取数据。</p></li><li><p><code>#4</code> - <code>pq_recvbuf</code> 函数是 <code>PostgreSQL</code> 的内部通信函数，从客户端接收数据缓冲区。</p></li><li><p><code>#5</code> - <code>pq_getbyte</code> 函数是用于从 <code>PostgreSQL</code> 后端接收单个字节的函数。</p></li><li><p><code>#6</code> - <code>SocketBackend</code> 函数处理 <code>PostgreSQL</code> 后端进程中的套接字通信。</p></li><li><p><code>#7</code> - <code>ReadCommand</code> 函数读取从客户端发来的命令。</p></li><li><p><code>#8</code> - <code>PostgresMain</code> 是 <code>PostgreSQL</code> 后端主函数，处理每个数据库会话的生命周期。</p></li><li><p><code>#9</code> - <code>BackendRun</code> 是在 <code>PostgreSQL</code> 后端进程启动后执行的函数。</p></li><li><p><code>#10</code> - <code>BackendStartup</code> 函数负责在系统启动后初始化后端进程。</p></li><li><p><code>#11</code> - <code>ServerLoop</code> 函数是 <code>PostgreSQL</code> 主进程的主循环，负责接受新的连接并启动新的后端进程。</p></li><li><p><code>#12</code> - <code>PostmasterMain</code> 是 <code>PostgreSQL</code> 的主守护进程主函数，管理数据库服务器的整体运行。</p></li><li><p><code>#13</code> - <code>main</code> 是 <code>PostgreSQL</code> 的入口点。</p></li></ul><p>从 <code>backtrace</code> 可以看出，<code>PostgreSQL</code> 后端进程正在等待来自客户端的新的网络活动。这是数据库服务器正常运行时的典型状态。</p></li><li><p>调试<code>SocketBackend</code><br><code>SocketBackend</code>接受客户端链接,因此可以在次数打断点, 先使用<code>ctrl c</code>暂停进程, 然后:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b SocketBackend</span><br><span class="line">c</span><br></pre></td></tr></table></figure><p>此时在<code>psql</code>连接客户端一侧, 使用<code>\l</code>命令使后端进行继续执行, 结果如下:<br><img src="/../../../images/DB/postgresql/gdb-SocketBackend.png" alt="gdb-SocketBackend"></p><p> 此时我们就已经正常进入了<code>postgresql</code>的业务代码, 并附带了源码调试信息, 大功告成</p></li></ol><h1 id="4-VSCode智能提示设置"><a href="#4-VSCode智能提示设置" class="headerlink" title="4 VSCode智能提示设置"></a>4 VSCode智能提示设置</h1><p>当我们完成上述操作后发现，如果我们在<code>VSCode</code>中直接打开项目文件夹, 是没有代码只能提示和补全的, 经过查阅得知, 智能跳转通常需要一个编译数据库（<code>compile_commands.json</code>）。这个文件包含了编译器在编译项目时使用的命令，它允许代码分析工具理解代码是如何被编译的，从而提供准确的智能感知。</p><p><code>compile_commands.json</code>可以如下得到:</p><h2 id="4-1-安装bear"><a href="#4-1-安装bear" class="headerlink" title="4.1 安装bear"></a>4.1 安装<code>bear</code></h2><p><code>bear</code> 用于在运行构建过程的同时拦截编译命令，生成 <code>compile_commands.json</code> 文件，这个文件可以被很多编辑器和工具用来提供代码索引和自动完成等功能。</p><p>我使用<code>Ubuntu</code>的<code>apt</code>安装<code>bear</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install bear</span><br></pre></td></tr></table></figure><h2 id="4-2-bear拦截编译命令"><a href="#4-2-bear拦截编译命令" class="headerlink" title="4.2 bear拦截编译命令"></a>4.2 <code>bear</code>拦截编译命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">bear -- make</span><br></pre></td></tr></table></figure><p>在这个命令中，<code>--</code> 表示后面的参数都将传递给实际的构建系统（在这个例子中是 <code>make</code>），而不是被 <code>bear</code> 解析。这样，<code>bear</code> 就会监听 <code>make</code> 命令的执行，捕获它的编译命令，并生成 <code>compile_commands.json</code> 文件。</p><p>需要注意的是, 首先要<code>make clean</code>清理之前的编译结果, 否则如果<code>make</code>什么也没做, 那么<code>bear</code>就什么也没拦截到, 构建的<code>compile_commands.json</code> 文件就是空的。</p><h2 id="4-3-VSCode设置compile-commands-json"><a href="#4-3-VSCode设置compile-commands-json" class="headerlink" title="4.3 VSCode设置compile_commands.json"></a>4.3 VSCode设置<code>compile_commands.json</code></h2><ol><li><code>VSCode</code>安装<code>clangd</code>插件</li><li>添加<code>compile_commands.json</code><br>在工作区的 <code>.vscode</code> 文件夹中创建或编辑 <code>settings.json</code> 文件，并添加以下内容：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;C_Cpp.default.compileCommands&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/compile_commands.json&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p>之后重启<code>VSCode</code>, 发现C文件已经有了智能提示和跳转了</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.postgresql.org/docs/">https://www.postgresql.org/docs/</a><br><a href="https://www.zhihu.com/column/c_1624079542120914944">https://www.zhihu.com/column/c_1624079542120914944</a><br><a href="https://blog.csdn.net/weixin_43997331/article/details/120662533">https://blog.csdn.net/weixin_43997331/article/details/120662533</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文内容包括:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何从源码安装&lt;code&gt;postgresql-14&lt;/code&gt;, 更多信息请参考官方文档: &lt;a href=&quot;https://www.postgresql.org/docs/current/&quot;&gt;https://www.postg</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Postgresql学习" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Postgresql%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Postgresql" scheme="http://example.com/tags/Postgresql/"/>
    
  </entry>
  
  <entry>
    <title>Google Test 简单使用</title>
    <link href="http://example.com/2024/02/10/C++/GoogleTest%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2024/02/10/C++/GoogleTest%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2024-02-10T02:38:15.000Z</published>
    <updated>2024-02-27T06:02:43.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Google-Test简介"><a href="#1-Google-Test简介" class="headerlink" title="1 Google Test简介"></a>1 Google Test简介</h1><p><code>Google Test</code>（<code>gtest</code>）是一个由<code>Google</code>提供的<code>C++</code>测试框架, 提供了丰富的断言类型和辅助函数，使得编写C++测试用例变得简单而又直观。<code>Google Test</code>旨在与<code>CMake</code>和其他构建系统无缝集成，而且与各种平台和测试工具兼容。下面是一些<code>Google Test</code>的核心特性：</p><h1 id="2-Google-Test基础语法"><a href="#2-Google-Test基础语法" class="headerlink" title="2 Google Test基础语法"></a>2 Google Test基础语法</h1><h2 id="2-1-断言"><a href="#2-1-断言" class="headerlink" title="2.1 断言"></a>2.1 断言</h2><p><code>Google Test</code>提供了一系列的断言宏来检查条件是否满足。如果断言失败，测试用例被认为失败。断言分为两大类：<code>ASSERT_*</code> 和 <code>EXPECT_*</code>。</p><ul><li><code>ASSERT_*</code> 版本在断言失败时会产生一个致命错误，并终止当前函数的执行。包括<code>ASSERT_TRUE</code>,<code>ASSERT_FALSE</code>, <code>ASSERT_EQ</code>等</li><li><code>EXPECT_*</code> 版本在断言失败时会产生一个非致命错误，当前函数会继续执行，这允许测试多个条件。包括<code>EXPECT_TRUE</code>,<code>EXPECT_FALSE</code>, <code>EXPECT_EQ</code>等</li></ul><h2 id="2-2-测试用例和测试套件"><a href="#2-2-测试用例和测试套件" class="headerlink" title="2.2 测试用例和测试套件"></a>2.2 测试用例和测试套件</h2><h3 id="2-2-1-测试用例"><a href="#2-2-1-测试用例" class="headerlink" title="2.2.1 测试用例"></a>2.2.1 测试用例</h3><p><strong>测试用例（Test Case）</strong>：是指一组相关测试的集合。在<code>Google Test</code>中，使用 <code>TEST()</code> 宏来定义一个不需要额外的设置或清理过程的简单测试用例。使用 <code>TEST</code> 时，只需提供测试案例名称和测试名称，然后编写测试代码块。案例如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(RbTreeTest, InsertTEST) &#123;</span><br><span class="line">  <span class="comment">// 测试代码在这里</span></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 一个示例断言</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>TEST</code>宏后的2个参数唯一标记了一个测试用例, 第一个参数可以重复, 但2个参数不能同时重复。<br>使用 <code>TEST</code>，每个测试是独立的，测试之间不共享任何状态。这个宏适合于无状态的测试，或者不需要为多个测试维护一个共同的环境时。</p><h3 id="2-2-2-测试套件"><a href="#2-2-2-测试套件" class="headerlink" title="2.2.2 测试套件"></a>2.2.2 测试套件</h3><p><strong>测试套件（Test Suite）</strong>：在更早的<code>Google Test</code>版本中，测试套件是指具有相同前缀的一组测试用例的集合。在新版本中，使用 <code>TEST_F()</code> 宏来定义测试套件，并且需要定义一个测试固件（<code>Fixture</code>）类。</p><p><code>TEST_F</code> 宏在有一个测试固件时使用，测试固件是一种用来重用相同的设置和清理代码为多个测试服务的方法。测试固件通过一个从 <code>::testing::Test</code> 派生的类来定义。然后，可以重写 <code>SetUp</code> 和 <code>TearDown</code> 方法来初始化和清理测试环境。</p><p>下面是一个使用 <code>TEST_F</code> 的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义测试固件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTestFixture</span> : <span class="keyword">public</span> ::testing::Test &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetUp</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置测试环境的代码</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">TearDown</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清理测试环境的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 TEST_F 编写使用测试固件的测试</span></span><br><span class="line"><span class="built_in">TEST_F</span>(MyTestFixture, 测试名称) &#123;</span><br><span class="line">  <span class="comment">// 可以使用设置好的环境的测试代码</span></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 一个示例断言</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>TEST_F</code>，同一个固件内的每个测试按照它们定义的顺序运行，但<code>Google Test</code>确保每个测试是隔离的；也就是说，在每个测试之前，环境都会重置为通过 <code>SetUp</code> 建立的初始状态。这样，一个测试所做的改变不会影响到另一个测试。</p><h1 id="3-案例-CMake下使用gtest"><a href="#3-案例-CMake下使用gtest" class="headerlink" title="3 案例: CMake下使用gtest"></a>3 案例: <code>CMake</code>下使用<code>gtest</code></h1><p>这个案例中, 我用自己之前学习过程中用<code>C++</code>手写常见数据结构的项目来介绍<code>CMake</code>中<code>gtest</code>的使用, 仓库在: <a href="https://github.com/ToniXWD/cppDataStructure">https://github.com/ToniXWD/cppDataStructure</a></p><h2 id="3-1-简单测试用例"><a href="#3-1-简单测试用例" class="headerlink" title="3.1 简单测试用例"></a>3.1 简单测试用例</h2><h3 id="3-1-1-官方指导的CMake编写"><a href="#3-1-1-官方指导的CMake编写" class="headerlink" title="3.1.1 官方指导的CMake编写"></a>3.1.1 官方指导的<code>CMake</code>编写</h3><p>在<code>CMake</code>中使用<code>gtest</code>不需要自行下载源码, 只需在<code>CMakeLists.txt</code>中如下编写:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.14</span>)</span><br><span class="line"><span class="keyword">project</span>(my_project)</span><br><span class="line"></span><br><span class="line"><span class="comment"># GoogleTest requires at least C++14</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(</span><br><span class="line">  googletest</span><br><span class="line">  URL https://github.com/google/googletest/archive/<span class="number">03597</span>a01ee50ed33e9dfd640b249b4be3799d395.zip</span><br><span class="line">)</span><br><span class="line"><span class="comment"># For Windows: Prevent overriding the parent project&#x27;s compiler/linker settings</span></span><br><span class="line"><span class="keyword">set</span>(gtest_force_shared_crt <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line">FetchContent_MakeAvailable(googletest)</span><br></pre></td></tr></table></figure><p>然后就可以如下编写一个单元测试:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./tests/rbTree_test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/rbTree.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Demonstrate some basic assertions.</span></span><br><span class="line"><span class="built_in">TEST</span>(RbTreeTest, InsertTEST) &#123;</span><br><span class="line">  <span class="comment">// 创建 RedBlackTree 对象</span></span><br><span class="line">  RedBlackTree&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(mySet.<span class="built_in">empty</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入元素</span></span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">42</span>);</span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">21</span>);</span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">63</span>);</span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">36</span>);</span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">92</span>);</span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">75</span>);</span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">87</span>);</span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">58</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(mySet.<span class="built_in">len</span>() == mySet.<span class="built_in">getSizeByTranverse</span>());</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(mySet.<span class="built_in">isBlackLenLegal</span>());</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(mySet.<span class="built_in">isNoDoubleRed</span>());</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(mySet.<span class="built_in">len</span>(), <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">  mySet.<span class="built_in">insert</span>(<span class="number">58</span>);</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(mySet.<span class="built_in">len</span>() == mySet.<span class="built_in">getSizeByTranverse</span>());</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(mySet.<span class="built_in">isBlackLenLegal</span>());</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(mySet.<span class="built_in">isNoDoubleRed</span>());</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(mySet.<span class="built_in">len</span>(), <span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line">...<span class="comment">//省略更多的测例</span></span><br></pre></td></tr></table></figure><p>编写完测试的<code>cpp</code>文件后, 还需要在<code>CMake</code>中进行下面的设置:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># rbTree_test</span></span><br><span class="line"><span class="keyword">add_executable</span>(</span><br><span class="line">  rbTree_test</span><br><span class="line">  tests/rbTree_test.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">  rbTree_test</span><br><span class="line">  GTest::gtest_main</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(GoogleTest)</span><br><span class="line">gtest_discover_tests(rbTree_test)</span><br></pre></td></tr></table></figure><p>这段<code>CMake</code>是为了设置并运行名为<code>rbTree_test</code>的测试用例:</p><ol><li><p><code>enable_testing()</code>用于启用当前目录和以下目录中的测试功能, 使用这个命令后就可以用<code>make test</code>来运行测试。</p></li><li><p><code>add_executable(rbTree_test tests/rbTree_test.cpp)</code><br>编译测试文件为可执行文件, 没啥好说的</p></li><li><p><code>target_link_libraries(rbTree_test GTest::gtest_main)</code><br>将测试可执行文件链接到<code>gtest</code>的<code>gtest_main</code>库</p></li><li><p><code>gtest_discover_tests(rbTree_test)</code><br> 告诉<code>CMake</code>去自动发现在<code>rbTree_test</code>可执行文件中定义的所有测试用例，并创建<code>CTest</code>测试案</p></li></ol><p>然后再命令行中执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> build/</span><br><span class="line">$ <span class="built_in">cd</span> build/ &amp;&amp; cmake ..</span><br><span class="line">$ make</span><br><span class="line">$ make <span class="built_in">test</span></span><br><span class="line">Running tests...</span><br><span class="line">Test project /home/xwd/cppDataStructure/build</span><br><span class="line">    Start 1: DequeTest.Basic1</span><br><span class="line">1/9 Test <span class="comment">#1: DequeTest.Basic1 ..................................   Passed    0.00 sec</span></span><br><span class="line">    Start 2: ListTest.Basic1</span><br><span class="line">2/9 Test <span class="comment">#2: ListTest.Basic1 ...................................   Passed    0.00 sec</span></span><br><span class="line">    Start 3: RbTreeTest.InsertTEST</span><br><span class="line">3/9 Test <span class="comment">#3: RbTreeTest.InsertTEST .............................   Passed    0.00 sec</span></span><br><span class="line">    Start 4: RbTreeTest.RemoveTest1</span><br><span class="line">4/9 Test <span class="comment">#4: RbTreeTest.RemoveTest1 ............................   Passed    0.00 sec</span></span><br><span class="line">    Start 5: RbTreeTest.RemoveTest2</span><br><span class="line">5/9 Test <span class="comment">#5: RbTreeTest.RemoveTest2 ............................   Passed    0.00 sec</span></span><br><span class="line">    Start 6: RbTreeTest.RemoveRoot</span><br><span class="line">6/9 Test <span class="comment">#6: RbTreeTest.RemoveRoot .............................   Passed    0.00 sec</span></span><br><span class="line">    Start 7: RbTreeTest.DoubleBlackTest</span><br><span class="line">7/9 Test <span class="comment">#7: RbTreeTest.DoubleBlackTest ........................   Passed    0.00 sec</span></span><br><span class="line">    Start 8: RbTreeTest.RemoveWithSiblingHasTwoBlackChildren</span><br><span class="line">8/9 Test <span class="comment">#8: RbTreeTest.RemoveWithSiblingHasTwoBlackChildren ...   Passed    0.00 sec</span></span><br><span class="line">    Start 9: RbTreeTest.RandomOperation</span><br><span class="line">9/9 Test <span class="comment">#9: RbTreeTest.RandomOperation ........................   Passed    0.01 sec</span></span><br><span class="line"></span><br><span class="line">100% tests passed, 0 tests failed out of 9</span><br><span class="line"></span><br><span class="line">Total Test time (real) =   0.03 sec</span><br></pre></td></tr></table></figure><h3 id="3-1-2-自动通过CMake注册单元测试"><a href="#3-1-2-自动通过CMake注册单元测试" class="headerlink" title="3.1.2 自动通过CMake注册单元测试"></a>3.1.2 自动通过<code>CMake</code>注册单元测试</h3><p>之前的内容可以看出, 每个单元测试都要单独地在<code>CMakeLists.txt</code>中指定链接库等, 很繁琐, 实际上我们可以借助<code>CMake</code>的语法自动注册单元测试:<br>首先假设所有的单元测试都在<code>test</code>文件夹下, 且形如<code>*_test.cpp</code>, 因此可以在<code>test</code>文件夹下编写<code>CMake</code>模块:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(</span><br><span class="line">  googletest</span><br><span class="line">  URL https://github.com/google/googletest/archive/<span class="number">03597</span>a01ee50ed33e9dfd640b249b4be3799d395.zip</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># For Windows: Prevent overriding the parent project&#x27;s compiler/linker settings</span></span><br><span class="line"><span class="keyword">set</span>(gtest_force_shared_crt <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line">FetchContent_MakeAvailable(googletest)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(GoogleTest)</span><br><span class="line"></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE TEST_CPPS <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/tests/*test.cpp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (test_source <span class="variable">$&#123;TEST_CPPS&#125;</span>)</span><br><span class="line">    <span class="comment"># Create a human readable name.</span></span><br><span class="line">    <span class="keyword">get_filename_component</span>(test_filename <span class="variable">$&#123;test_source&#125;</span> NAME)</span><br><span class="line">    <span class="keyword">string</span>(REPLACE <span class="string">&quot;.cpp&quot;</span> <span class="string">&quot;&quot;</span> mySTL_test_name <span class="variable">$&#123;test_filename&#125;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add the test target separately and as part of &quot;make check-tests&quot;.</span></span><br><span class="line">    <span class="keyword">add_executable</span>(<span class="variable">$&#123;mySTL_test_name&#125;</span>  <span class="variable">$&#123;test_source&#125;</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;mySTL_test_name&#125;</span> GTest::gtest_main)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gtest_discover_tests(<span class="variable">$&#123;mySTL_test_name&#125;</span></span><br><span class="line">            EXTRA_ARGS</span><br><span class="line">            --gtest_color=auto</span><br><span class="line">            --gtest_output=xml:<span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="keyword">test</span>/<span class="variable">$&#123;mySTL_test_name&#125;</span>.xml</span><br><span class="line">            --gtest_catch_exceptions=<span class="number">0</span></span><br><span class="line">            DISCOVERY_TIMEOUT <span class="number">120</span></span><br><span class="line">            PROPERTIES</span><br><span class="line">            TIMEOUT <span class="number">120</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set test target properties and dependencies.</span></span><br><span class="line">    <span class="keyword">set_target_properties</span>(<span class="variable">$&#123;mySTL_test_name&#125;</span></span><br><span class="line">            PROPERTIES</span><br><span class="line">            RUNTIME_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/test&quot;</span></span><br><span class="line">            <span class="keyword">COMMAND</span> <span class="variable">$&#123;mySTL_test_name&#125;</span></span><br><span class="line">            )</span><br><span class="line"><span class="keyword">endforeach</span> ()</span><br></pre></td></tr></table></figure><p>在线获取<code>gtest</code>的部分和之前一样, 这里介绍其是如何自动发现单元测试文件的:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB_RECURSE TEST_CPPS <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/tests/*test.cpp&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>file(GLOB_RECURSE ...)</code>用于递归地搜索所有匹配的文件，并将它们的列表存储在变量<code>TEST_CPPS</code>中。在这种情况下，它搜索项目源目录下<code>tests</code>文件夹中所有以<code>test.cpp</code>结尾的文件。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (test_source <span class="variable">$&#123;TEST_CPPS&#125;</span>)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endforeach</span> ()</span><br></pre></td></tr></table></figure><p>这个循环遍历所有找到的测试文件。对于每个文件，它执行以下操作：</p><ul><li>获取文件名，去除<code>.cpp</code>后缀，创建一个易读的测试名称（<code>mySTL_test_name</code>）。</li><li>使用<code>add_executable</code>为每个测试文件创建一个可执行文件。</li><li>使用<code>target_link_libraries</code>将Google Test主库链接到每个测试可执行文件。</li><li>调用<code>gtest_discover_tests</code>来发现和注册测试，设置额外的参数和属性，包括输出格式（XML），是否捕获异常，测试发现超时和测试超时。</li><li>设置每个测试目标的属性，确保测试的可执行文件被放置在预期的目录，并指定运行测试的命令。</li></ul><p>然后只需要在根路径下的<code>CMakeLists</code>中包含这个模块即可:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(tests)</span><br></pre></td></tr></table></figure><p>之后自己新建的单元测试就可以被自动发现了</p><h2 id="3-2-测试套件"><a href="#3-2-测试套件" class="headerlink" title="3.2 测试套件"></a>3.2 测试套件</h2><p>如果有这样一种情况, 多个测试用例中, 代码初始化部分逻辑是相同的, 可以将其设置为测试套件, 下面是一个测试堆(<code>Heap</code>)数据结构的单元测试:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/heap.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义测试固件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InitHeap</span> : <span class="keyword">public</span> ::testing::Test &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Heap&lt;<span class="type">int</span>&gt; minHeap;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetUp</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置测试环境的代码</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">TearDown</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清理测试环境的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test case for inserting elements into the heap</span></span><br><span class="line"><span class="built_in">TEST_F</span>(InitHeap, InsertAndSize) &#123;</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(minHeap.<span class="built_in">size</span>(), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test case for removing the root element</span></span><br><span class="line"><span class="built_in">TEST_F</span>(InitHeap, RemoveRoot) &#123;</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(minHeap.<span class="built_in">removeRoot</span>(), <span class="number">2</span>); <span class="comment">// Assuming a min heap</span></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(minHeap.<span class="built_in">size</span>(), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test case to check heap property is maintained after insertions</span></span><br><span class="line"><span class="built_in">TEST_F</span>(InitHeap, HeapPropertyAfterInsertion) &#123;</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">  minHeap.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(minHeap.<span class="built_in">removeRoot</span>(), <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(minHeap.<span class="built_in">removeRoot</span>(), <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(minHeap.<span class="built_in">removeRoot</span>(), <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(minHeap.<span class="built_in">removeRoot</span>(), <span class="number">5</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(minHeap.<span class="built_in">removeRoot</span>(), <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test case for handling removal from an empty heap</span></span><br><span class="line"><span class="built_in">TEST_F</span>(InitHeap, RemoveFromEmptyHeap) &#123;</span><br><span class="line">  <span class="built_in">EXPECT_THROW</span>(minHeap.<span class="built_in">removeRoot</span>(), std::out_of_range);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test case for dynamic resizing of the heap</span></span><br><span class="line"><span class="built_in">TEST_F</span>(InitHeap, ResizeHeap) &#123;</span><br><span class="line">  <span class="type">size_t</span> initialCapacity = <span class="number">32</span>; <span class="comment">// Assuming initial capacity is 32</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; initialCapacity + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    minHeap.<span class="built_in">insert</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">EXPECT_GT</span>(minHeap.<span class="built_in">size</span>(), initialCapacity);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(initialCapacity); ++i) &#123;</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(minHeap.<span class="built_in">removeRoot</span>(), i); <span class="comment">// Assuming a min heap</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test case for max heap property</span></span><br><span class="line"><span class="built_in">TEST</span>(HeapTest, MaxHeapProperty) &#123;</span><br><span class="line">  Heap&lt;<span class="type">int</span>, std::greater&lt;<span class="type">int</span>&gt;&gt; maxHeap;</span><br><span class="line">  maxHeap.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">  maxHeap.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">  maxHeap.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line">  maxHeap.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">  maxHeap.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">  maxHeap.<span class="built_in">insert</span>(<span class="number">26</span>);</span><br><span class="line">  maxHeap.<span class="built_in">insert</span>(<span class="number">-5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(maxHeap.<span class="built_in">removeRoot</span>(), <span class="number">26</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(maxHeap.<span class="built_in">removeRoot</span>(), <span class="number">8</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(maxHeap.<span class="built_in">removeRoot</span>(), <span class="number">5</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(maxHeap.<span class="built_in">removeRoot</span>(), <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(maxHeap.<span class="built_in">removeRoot</span>(), <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(maxHeap.<span class="built_in">removeRoot</span>(), <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(maxHeap.<span class="built_in">removeRoot</span>(), <span class="number">-5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了最后一个测试用例外, 每个测试都是初始化一个泛型为<code>int</code>的小根堆, 因此可以定义一个继承自<code>testing::Test</code>的类<code>InitHeap</code>, 并添加一个成员变量<code>minHeap</code>, 此后在使用<code>TEST_F</code>宏的测试案中将第一个参数设置为<code>InitHeap</code>, 然后就可以不用初始化小根堆了。如果有别的需求， 还可以重写<code>TearDown</code>和<code>SetUp</code>成员方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Google-Test简介&quot;&gt;&lt;a href=&quot;#1-Google-Test简介&quot; class=&quot;headerlink&quot; title=&quot;1 Google Test简介&quot;&gt;&lt;/a&gt;1 Google Test简介&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Google Test&lt;</summary>
      
    
    
    
    <category term="C++随笔" scheme="http://example.com/categories/C-%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="单元测试" scheme="http://example.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    <category term="gtest" scheme="http://example.com/tags/gtest/"/>
    
  </entry>
  
  <entry>
    <title>CMU15445 2022 project0: C++ Primer: 字典树</title>
    <link href="http://example.com/2024/02/06/CMU15445/proj0/"/>
    <id>http://example.com/2024/02/06/CMU15445/proj0/</id>
    <published>2024-02-06T09:37:18.000Z</published>
    <updated>2024-02-21T16:16:04.636Z</updated>
    
    <content type="html"><![CDATA[<p>这是对个人在2022年秋的<code>CMU15445</code>的<code>project</code>总结, 算是补档, 所有很多代码也忘了, 这里也就值只介绍其中的思路, 不涉及具体代码细节, 不过<code>CMU15445</code>的老师<code>Andy</code>本来也禁止个人公开代码实现的。</p><p>本次实验是实现一个字典树<code>Trie</code>, 但难度主要不在这个数据结构, 更多是通过这个项目熟悉<code>C++</code>常见的新特性。</p><p><code>官方project指导书</code>: <a href="https://15445.courses.cs.cmu.edu/fall2022/project0/">https://15445.courses.cs.cmu.edu/fall2022/project0/</a></p><h1 id="1-Trie数据结构介绍"><a href="#1-Trie数据结构介绍" class="headerlink" title="1 Trie数据结构介绍"></a>1 <code>Trie</code>数据结构介绍</h1><p>下面是摘自官方文档的数据结构示意图:</p><p><img src="/../../images/CMU15445/trie.png" alt="trie"></p><p>在上面的图中可以看到, 字典树每个节点实际上存储的就是字符串的一个字符, 这个树结构从根路径到叶子结点路径上的字符一起组成了字符串, 如<code>hello</code>, <code>have</code>, <code>hat</code></p><p>另一方面, 还可以在特定的节点存储<code>value</code>形成<code>KV</code>存储的数据结构, 下面是摘自官方文档的数据结构示意图:</p><blockquote><p>另外, 如果不存在某个字符是所有字符串的祖先(第一个字符), 就设一个空的<code>root</code>节点替代</p></blockquote><p><img src="/../../images/CMU15445/trie-kv.png" alt="trie-k"></p><p>这个数据结构存储了<code>(&quot;ab&quot;, 1)</code> 和 <code>(&quot;ac&quot;, &quot;val&quot;)</code>2个数据结构</p><p>可以看出, 这种数据结构的核心思想就是: <strong>将公共的前缀压缩在树的公共祖先路径上</strong>, 路径形成<code>key</code>, 再在节点上存储<code>value</code></p><h1 id="2-代码实现思路"><a href="#2-代码实现思路" class="headerlink" title="2 代码实现思路"></a>2 代码实现思路</h1><h2 id="2-1-数据结构解析"><a href="#2-1-数据结构解析" class="headerlink" title="2.1 数据结构解析"></a>2.1 数据结构解析</h2><p>给出的代码框架中, <code>TrieNode</code>就对应不包含值的节点, <code>TrieNodeWithValue</code>就是包含了值的节点, 二者是继承关系, 而<code>TrieNode</code>使用<code>unordered_map</code>存储指向每个节点的<code>unique_ptr</code></p><h2 id="2-3-Insert函数实现思路"><a href="#2-3-Insert函数实现思路" class="headerlink" title="2.3 Insert函数实现思路"></a>2.3 <code>Insert</code>函数实现思路</h2><p><code>Insert</code> 函数是一个模板函数，用于插入键值对。它接受一个字符串 <code>key</code> 作为要插入的键，以及一个 <code>value</code> 作为与键关联的值。流程如下：</p><ol><li><p>检查键 (<code>key</code>) 是否为空。如果为空，直接返回 <code>false</code></p></li><li><p>使用迭代器<code>c</code> 循环遍历 <code>key</code> 中的每个字符，直至迭代器 <code>c</code> 到达 <code>key</code> 的末尾。</p></li><li><p>在循环中，<code>cur</code> 存储当前迭代器 <code>c</code> 的值，并立即将 <code>c</code> 增加。如果 <code>c</code> 到达 <code>key</code> 的末尾，则跳出循环。</p></li><li><p>检查前一个子节点 <code>pre_child</code> 是否有当前字符 <code>*cur</code> 对应的子节点。</p><ol><li>如果没有，使用 <code>InsertChildNode</code> 创建一个新的 <code>TrieNode</code> 子节点，并更新 <code>pre_child</code> 指向新节点。</li><li>如果 <code>pre_child</code> 已经有当前字符 <code>*cur</code> 对应的子节点，那么就获取这个子节点，并更新 <code>pre_child</code> 指向它。</li></ol></li><li><p>循环结束后，<code>c</code> 递减，指向 <code>key</code> 的最后一个字符。</p></li><li><p>尝试获取最后一个字符对应的子节点 <code>end_node</code>。</p><ol><li>如果 <code>end_node</code> 已经存在并且是一个结束节点（即已经存储了一个值），则释放写锁并返回 <code>false</code>，表示键已存在。</li><li>如果 <code>end_node</code> 存在但不是结束节点，创建一个带有值 <code>value</code> 的新 <code>TrieNodeWithValue</code> 节点，并使用 <code>std::move</code> 把 <code>end_node</code> 的数据移动到新节点。然后用 <code>reset</code> 方法替换 <code>end_node</code> 中的指针。</li><li>如果 <code>end_node</code> 不存在，使用 <code>InsertChildNode</code> 在 <code>pre_child</code> 下插入一个新的 <code>TrieNode</code>，然后创建一个新的 <code>TrieNodeWithValue</code> 实例，将 <code>pre_child</code> 的数据移动到新节点，并设置值 <code>value</code>。</li></ol></li><li><p>最后，函数释放写锁，并返回 <code>true</code>，表示键值对已成功插入字典树。</p></li></ol><p>上面的代码其实说的太详细了, <code>Tie</code>的插入其实也很简单, 之所以说这么复杂, 主要是要提到使用的<code>C++11\14\17</code>的新特性</p><h2 id="2-2-Remove函数实现思路"><a href="#2-2-Remove函数实现思路" class="headerlink" title="2.2 Remove函数实现思路"></a>2.2 <code>Remove</code>函数实现思路</h2><ol><li><p>检查键是否为空：<br>如果提供的键 <code>key</code> 为空字符串，函数返回 <code>false</code>，因为无法从Trie中移除一个不存在的键。</p></li><li><p>使用栈跟踪路径：<br>  代码初始化了一个栈 <code>s</code> 来存储遍历过程中的路径。栈中的元素是一个包含字符和指向<code>TrieNode</code>指针的<code>pair</code>。</p></li><li><p>遍历键中的每个字符：</p><ol><li>使用一个迭代器 <code>c</code> 遍历键 <code>key</code> 的每个字符。</li><li>检查是否存在当前字符对应的子节点。如果存在：<ol><li>将当前字符和指向父节点的指针存入栈中。</li><li>更新 <code>pre_child</code> 指向当前字符的子节点。</li></ol></li><li>如果不存在当前字符对应的子节点，说明键不在Trie中，返回 <code>false</code>。</li></ol></li><li><p>检查并移除没有子节点的节点：</p><ol><li>从栈中弹出元素，这样就可以从键的末尾向根节点遍历。</li><li>对于每一个弹出的元素，检查当前节点（通过 <code>(*node)-&gt;GetChildNode(key)</code> 获取）是否存在子节点。</li><li>如果当前节点没有子节点，使用 <code>(*node)-&gt;RemoveChildNode(key)</code> 方法移除它。</li><li>如果当前节点有子节点，说明该节点是其他键的前缀，或者其子节点中有其他键的后续部分，因此不能移除该节点。</li></ol></li><li><p>返回成功：<br>  如果整个键已经被遍历，并且相关节点已被移除，函数返回 <code>true</code> 表示键已成功从Trie中移除。</p></li></ol><p>在这个过程中，推荐使用后进先出（LIFO）的栈结构来保存遍历过程中的路径。这是因为在移除过程中，可能需要从叶子节点回溯到根节点，去除沿途的任何不再有用的节点。这种回溯机制确保只有当<strong>一个节点不再表示任何其他键时，它才会被移除</strong>。如果在回溯过程中<strong>遇到一个有子节点的节点，这意味着该节点仍然是其他键的一部分</strong>，因此该节点和它的祖先节点都不应该被移除。</p><p>这个代码实际写起来应该很简单, 本项目的目的也就是对C++17进行练手而已</p><h1 id="3-补充知识-用到的C-新特性"><a href="#3-补充知识-用到的C-新特性" class="headerlink" title="3 补充知识: 用到的C++新特性"></a>3 补充知识: 用到的C++新特性</h1><h2 id="3-1-右值"><a href="#3-1-右值" class="headerlink" title="3.1 右值"></a>3.1 右值</h2><h3 id="3-1-1-右值的定义"><a href="#3-1-1-右值的定义" class="headerlink" title="3.1.1 右值的定义"></a>3.1.1 右值的定义</h3><p>在C++中，右值（rvalue）是指一个临时的、非持久的对象，它通常出现在赋值表达式的右侧。右值表示对象的值，而不是对象的身份（位置），这意味着它们不具有可识别的内存地址。</p><p>C++中的值可以分为两大类：左值（lvalue）和右值（rvalue）。左值是指那些具有持久状态的对象，这些对象通常可以<strong>通过它们的地址来标识</strong>。它们可以出现在赋值表达式的左侧。例如，一个变量或者一个数组的元素都是左值。</p><p>而右值分为两类：</p><ol><li><p>纯右值：表示表达式完全不对应任何对象存储位置。例如，数字字面量（如<code>42</code>）、算术表达式的结果（如<code>3+4</code>）、返回非引用类型的函数调用等。</p></li><li><p>将亡值：C++11中引入的概念，是一种特殊的右值，它对应于即将被销毁、或者可以“移动”的对象。这类右值允许将资源（比如动态分配的内存）从一个对象转移到另一个对象，这样可以提升效率，避免不必要的复制。例如，使用<code>std::move</code>函数可以将一个左值转换为将亡值。</p></li></ol><p>右值的一个关键特性是它们可以被移动而非复制，这是C++11中引入的右值引用（<code>&amp;&amp;</code>）的主要用途。右值引用允许开发者重用即将销毁的对象的资源，例如在移动构造函数（<code>T(T&amp;&amp;)</code>）和移动赋值操作符（<code>T&amp; operator=(T&amp;&amp;)</code>）中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">42</span>; <span class="comment">// 42是一个纯右值</span></span><br><span class="line"><span class="type">int</span> b = a;  <span class="comment">// a是一个左值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp;&amp; rvalue_ref = a * <span class="number">2</span>; <span class="comment">// a * 2是一个纯右值，rvalue_ref是对它的右值引用</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; moved_ref = std::<span class="built_in">move</span>(b); <span class="comment">// 使用std::move将b转换为一个将亡值，moved_ref是对它的右值引用</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>42</code>是一个纯右值，<code>a * 2</code>是一个临时结果，也是一个纯右值，而<code>std::move(b)</code>将<code>b</code>转换为一个将亡值，这允许将<code>b</code>的资源移动到另一个对象中。</p><h3 id="3-1-2-赋值后的右值"><a href="#3-1-2-赋值后的右值" class="headerlink" title="3.1.2 赋值后的右值"></a>3.1.2 赋值后的右值</h3><p>这里有个非常容易误解的地方, 涉及到C++中的一个微妙之处。当创建一个右值引用，比如 <code>int&amp;&amp; rvalue_ref</code>，并将一个右值表达式 <code>a * 2</code> 绑定到它上面时，<code>rvalue_ref</code> 本身成为一个具名的引用，它的身份可以被识别，因此在某种意义上它表现得像一个左值。</p><p>然而，<code>rvalue_ref</code> 仍然保持着与它所绑定的右值的联系，这意味着可以使用它来“移动”所绑定的临时对象的资源，正如右值引用的初衷那样。C++标准规定，即使是具名的右值引用，也应该被视为一个右值，以允许移动语义和其他对右值的操作。</p><p>在函数重载解析中，<code>rvalue_ref</code> 会被当作一个右值来处理。举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// 针对左值的重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// 针对右值的重载</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; rvalue_ref = a * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">foo</span>(rvalue_ref); <span class="comment">// 这里会调用 foo(int&amp;&amp; x)</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，即使 <code>rvalue_ref</code> 是一个具名的变量，<code>foo(rvalue_ref)</code> 依然会调用接受右值引用的重载版本 <code>foo(int&amp;&amp; x)</code>，因为 <code>rvalue_ref</code> 在表达式中被视为右值。</p><p>然而，如果尝试对 <code>rvalue_ref</code> 取地址或者再次对其赋值，它就会表现得像一个左值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = &amp;rvalue_ref; <span class="comment">// 现在取得了它的地址，它表现得像一个左值</span></span><br><span class="line"></span><br><span class="line">rvalue_ref = <span class="number">100</span>; <span class="comment">// 可以对它赋值，它表现得像一个左值</span></span><br></pre></td></tr></table></figure><p>在这些情况下，<code>rvalue_ref</code> 的行为与左值没有区别，因为它是一个具名的对象，可以对它进行操作，例如取地址和赋值，这是标准左值操作。</p><p>下面的陈述不一定复合编译器的事实, 但阐述了右值的思想: <strong>右值引用的出现可以延长一个右值的生命周期，并提供了对这个右值的直接访问。</strong>:<br>比较<code>int&amp;&amp; rvalue_ref = a * 2;</code>和<code>int&amp; rvalue_ref = a * 2;</code>这2句代码的执行, </p><ul><li><code>int rvalue_ref = a * 2;</code>的执行</li></ul><ol><li><code>a * 2</code>这个临时的右值存放在栈上</li><li><code>rvalue_ref</code>是个左值,  <code>a * 2</code>会被复制到<code>rvalue_ref</code>的地址中</li><li><code>rvalue_ref</code>的地址被释放</li></ol><ul><li><code>int&amp;&amp; rvalue_ref = a * 2;</code>的执行</li></ul><ol><li><code>a * 2</code>这个临时的右值存放在栈上</li><li><code>rvalue_ref</code>是个右值引用, 其内存地址直接和存放<code>a * 2</code>这个临时的右值的地址相同</li><li>由于原来临时右值将要被继续使用, 所以不需要释放</li></ol><h2 id="3-1-3-右值的使用——完美转发"><a href="#3-1-3-右值的使用——完美转发" class="headerlink" title="3.1.3 右值的使用——完美转发"></a>3.1.3 右值的使用——完美转发</h2><p>完美转发（<code>Perfect forwarding</code>）是C++11引入的一个概念，简单说就是: <strong>允许函数模板将其接收到的参数以原始的值类别（即保持其是左值还是右值的特性）转发到另一个函数</strong>。其目的也是减少复制的数量。</p><p>完美转发的关键在于<code>std::forward</code>函数模板和右值引用的结合使用。右值引用独自并不能实现完美转发，因为当一个右值引用被传递时，它变成了一个左值。为了解决这个问题，<code>std::forward</code>用于保持参数的原始值类别。</p><p>以下是使用右值引用和<code>std::forward</code>实现完美转发的一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// For std::forward</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forwarder</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span>&amp;&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只有当n是一个右值时，这里的代码才会被执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    forwarder(g, <span class="number">42</span>); <span class="comment">// 42是一个右值，forwarder能够完美转发它到g</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>forwarder</code>是一个函数模板，它接受任意类型的函数<code>f</code>和参数<code>args</code>。它用<code>std::forward</code>来转发参数<code>args</code>到函数<code>f</code>，同时保持每个参数的左值或右值属性。</p><p><code>std::forward</code>的作用是这样的：</p><ul><li>当参数是一个左值时，<code>std::forward</code>将其转换为左值引用类型。</li><li>当参数是一个右值时，<code>std::forward</code>将其转换为右值引用类型，允许移动语义的发生。</li></ul><h2 id="3-2-智能指针"><a href="#3-2-智能指针" class="headerlink" title="3.2 智能指针"></a>3.2 智能指针</h2><p>所有的智能指针都是自动回收资源, 这一点是最重要的。</p><h2 id="3-2-1-unique-ptr"><a href="#3-2-1-unique-ptr" class="headerlink" title="3.2.1 unique_ptr"></a>3.2.1 <code>unique_ptr</code></h2><p>在任何给定时间，只有一个 <code>unique_ptr</code> 实例可以指向一个特定的对象。这个特性使得 <code>unique_ptr</code> 成为管理动态分配内存的理想选择，因为它可以确保对象被正确删除，并且防止了资源泄露。</p><p><code>unique_ptr</code> 是一个模板类，提供了一系列用于管理动态分配的资源的接口函数。以下是一些常用的接口函数及其用法：</p><ol><li><strong>初始化</strong></li></ol><ul><li><p><strong>构造函数</strong>：可以用来创建 <code>unique_ptr</code>，有多种构造方式，包括默认构造、从原始指针构造等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr1; <span class="comment">// 默认构造，初始化为空</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">5</span>))</span></span>; <span class="comment">// 从原始指针构造</span></span><br></pre></td></tr></table></figure></li><li><p><strong>移动构造函数</strong>：允许从另一个 <code>unique_ptr</code> 转移所有权。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr3</span><span class="params">(std::move(ptr2))</span></span>; <span class="comment">// ptr2 为空，ptr3 拥有原始资源</span></span><br></pre></td></tr></table></figure></li><li><p><strong>make_unique</strong>：C++14 引入了 <code>std::make_unique</code> 函数模板，用于在堆上创建一个对象，并返回这个对象的 <code>unique_ptr</code>。这是创建 <code>unique_ptr</code> 的推荐方式，因为它可以防止原始指针的泄露，并且可以提供异常安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr7 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">30</span>); <span class="comment">// 使用 make_unique 创建</span></span><br></pre></td></tr></table></figure></li><li><p><strong>构造函数 with deleter</strong>：创建一个带有自定义删除器的 <code>unique_ptr</code>。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> deleter = [](<span class="type">int</span>* ptr)&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Custom deleter is called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>, <span class="title">decltype</span><span class="params">(deleter)</span>&gt; <span class="title">ptr6</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>, deleter)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><p><strong>赋值</strong></p><ul><li><strong>移动赋值操作符</strong>：允许转移所有权。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr4 = std::<span class="built_in">move</span>(ptr3); <span class="comment">// ptr3 为空，ptr4 拥有原始资源</span></span><br></pre></td></tr></table></figure></li><li><p><strong>资源管理</strong></p><ul><li><strong>reset</strong>：替换管理的对象，或设置为空。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr4.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>)); <span class="comment">// ptr4 现在拥有一个新的 int 对象</span></span><br><span class="line">ptr4.<span class="built_in">reset</span>(); <span class="comment">// 自动删除管理的对象，并将 ptr4 设置为空</span></span><br></pre></td></tr></table></figure><ul><li><strong>release</strong>：释放对对象的所有权，并返回原始指针，之后 <code>unique_ptr</code> 将为空。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* rawPtr = ptr4.<span class="built_in">release</span>(); <span class="comment">// 现在 rawPtr 是裸指针，需要手动管理</span></span><br></pre></td></tr></table></figure><ul><li><strong>swap</strong>：交换两个 <code>unique_ptr</code> 的管理的对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr5</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">20</span>))</span></span>;</span><br><span class="line">ptr4.<span class="built_in">swap</span>(ptr5); <span class="comment">// 现在 ptr4 管理一个 int(20)，ptr5 为空</span></span><br></pre></td></tr></table></figure></li><li><p><strong>裸指针获取</strong></p><ul><li><strong>get</strong>：返回管理的对象的裸指针。</li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* rawPtr = ptr5.<span class="built_in">get</span>(); <span class="comment">// 不释放所有权，仅返回指针</span></span><br></pre></td></tr></table></figure><ul><li>**<code>operator*</code> 和 <code>operator-&gt;</code>**：提供对管理对象的访问。</li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = *ptr5; <span class="comment">// 访问 int 值</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="3-2-2-shared-ptr"><a href="#3-2-2-shared-ptr" class="headerlink" title="3.2.2 shared_ptr"></a>3.2.2 <code>shared_ptr</code></h2><p>与 <code>unique_ptr</code> 不同，多个 <code>shared_ptr</code> 实例可以共享同一个对象，引用计数会跟踪有多少个 <code>shared_ptr</code> 拥有同一个资源，当最后一个 <code>shared_ptr</code> 被销毁时，资源会被自动释放。</p><ol><li><strong>构造函数</strong></li></ol><ul><li><p><strong>默认构造函数</strong>：构造一个空的 <code>shared_ptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr;</span><br></pre></td></tr></table></figure></li><li><p><strong>从原始指针构造</strong>：创建一个 <code>shared_ptr</code> 管理一个新的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>拷贝构造函数</strong>：构造一个新的 <code>shared_ptr</code>，它与另一个 <code>shared_ptr</code> 共享对象，并增加引用计数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>移动构造函数</strong>：从另一个 <code>shared_ptr</code> 移动构造，转移所有权并将原 <code>shared_ptr</code> 设置为空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr3</span><span class="params">(std::move(ptr2))</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>构造函数 with deleter</strong>：创建一个带有自定义删除器的 <code>shared_ptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> deleter = [](<span class="type">int</span>* p)&#123; <span class="keyword">delete</span> p; &#125;;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr6</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>, deleter)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>make_shared</strong>：C++11 引入了 <code>std::make_shared</code> 函数模板，用于在堆上创建一个对象，并返回这个对象的 <code>shared_ptr</code>。这是创建 <code>shared_ptr</code> 的推荐方式，因为它通常更高效，并可以减少内存分配次数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr7 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">30</span>);</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>赋值运算符</strong></li></ol><ul><li><p><strong>拷贝赋值运算符</strong>：允许将一个 <code>shared_ptr</code> 的所有权赋值给另一个 <code>shared_ptr</code>，原 <code>shared_ptr</code> 的引用计数减一，新 <code>shared_ptr</code> 的引用计数加一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr4;</span><br><span class="line">ptr4 = ptr;</span><br></pre></td></tr></table></figure></li><li><p><strong>移动赋值运算符</strong>：将一个 <code>shared_ptr</code> 的所有权移动给另一个 <code>shared_ptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr5;</span><br><span class="line">ptr5 = std::<span class="built_in">move</span>(ptr4);</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>资源管理</strong></li></ol><ul><li><p><strong>reset</strong>：更换 <code>shared_ptr</code> 所管理的对象，或者放弃对当前对象的所有权。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>)); <span class="comment">// ptr 现在指向新的 int 对象</span></span><br><span class="line">ptr.<span class="built_in">reset</span>(); <span class="comment">// 放弃所有权，如果 ptr 是最后一个引用，将释放对象</span></span><br></pre></td></tr></table></figure></li><li><p><strong>use_count</strong>：返回当前共享同一个对象的 <code>shared_ptr</code> 数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> count = ptr.<span class="built_in">use_count</span>(); <span class="comment">// 获取引用计数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>unique</strong>：检查 <code>shared_ptr</code> 是否是管理对象的唯一拥有者。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isUnique = ptr.<span class="built_in">unique</span>(); <span class="comment">// 如果引用计数为1，则返回 true</span></span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><strong>裸指针获取</strong></li></ol><ul><li><p><strong>get</strong>：返回管理的对象的原始指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* rawPtr = ptr.<span class="built_in">get</span>(); <span class="comment">// 获取裸指针</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>operator*</code> 和 <code>operator-&gt;</code>**：提供对管理对象的访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = *ptr; <span class="comment">// 解引用</span></span><br><span class="line"><span class="type">int</span> value = ptr-&gt;<span class="built_in">someMethod</span>(); <span class="comment">// 访问对象成员</span></span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li><strong>检查</strong></li></ol><ul><li><p><strong>operator bool</strong>：检查 <code>shared_ptr</code> 是否拥有一个对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr is not empty.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-3-weak-ptr"><a href="#3-2-3-weak-ptr" class="headerlink" title="3.2.3 weak_ptr"></a>3.2.3 <code>weak_ptr</code></h2><p><code>weak_ptr</code> 用来解决智能指针间的循环引用问题。<code>weak_ptr</code> 持有对 <code>shared_ptr</code> 管理对象的非拥有（弱）引用，即它不会增加对象的引用计数。这意味着 <code>weak_ptr</code> 的存在不会阻止其所指向的对象被销毁。</p><p><code>weak_ptr</code> 主要用于监视 <code>shared_ptr</code>，而不是拥有资源。它通常用于缓存、观察者模式、和防止 <code>shared_ptr</code> 之间的循环引用导致的内存泄漏。</p><p><strong>一个循环引用的例子</strong><br>如果有两个类 <code>A</code> 和 <code>B</code>，它们互相持有对方的 <code>shared_ptr</code>，那么它们将永远不会被释放，因为它们的引用计数永远不会降到零。使用 <code>weak_ptr</code> 可以打破这种循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; b_ptr;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;A&gt; a_ptr; <span class="comment">// 使用 weak_ptr 而不是 shared_ptr</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，即使 <code>A</code> 和 <code>B</code> 相互引用，一旦外部对 <code>A</code> 和 <code>B</code> 的 <code>shared_ptr</code> 被销毁，它们最终也能被正确清理。</p><ol><li><strong>构造函数</strong></li></ol><ul><li><p><strong>默认构造函数</strong>：创建一个不指向任何对象的 <code>weak_ptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; wp;</span><br></pre></td></tr></table></figure></li><li><p><strong>从 shared_ptr 构造</strong>：创建一个 <code>weak_ptr</code> 实例，它指向由 <code>shared_ptr</code> 管理的对象，但不增加引用计数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>资源管理</strong></li></ol><ul><li><p><strong>reset</strong>：重置 <code>weak_ptr</code> 实例，放弃对对象的引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wp.<span class="built_in">reset</span>();</span><br></pre></td></tr></table></figure></li><li><p><strong>use_count</strong>：返回与此 <code>weak_ptr</code> 共享对象的 <code>shared_ptr</code> 实例的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> count = wp.<span class="built_in">use_count</span>(); <span class="comment">// 如果对象已经被删除，则返回 0</span></span><br></pre></td></tr></table></figure></li><li><p><strong>expired</strong>：检查所管理的对象是否已经被删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isExpired = wp.<span class="built_in">expired</span>(); <span class="comment">// 如果对象已经被删除，则返回 true</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>获得 <code>shared_ptr</code></strong></li></ol><ul><li><strong>lock</strong>：尝试从 <code>weak_ptr</code> 创建一个 <code>shared_ptr</code> 实例。如果对象还存在，这将返回一个有效的 <code>shared_ptr</code>，否则返回一个空的 <code>shared_ptr</code>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp = wp.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (sp) &#123;</span><br><span class="line">    <span class="comment">// 对象仍然存在，可以安全使用 sp</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 对象已被删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-3-类型转换"><a href="#3-3-类型转换" class="headerlink" title="3.3 类型转换"></a>3.3 类型转换</h2><p>C++ 提供了四种类型转换运算符来覆盖不同的类型转换场景：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code> 和 <code>reinterpret_cast</code>。</p><h3 id="3-3-1-static-cast"><a href="#3-3-1-static-cast" class="headerlink" title="3.3.1 static_cast"></a>3.3.1 <code>static_cast</code></h3><p><code>static_cast</code> 在编译时执行类型转换，不进行运行时类型检查。<code>static_cast</code> 可以用于各种明确的类型转换，包括基本数据类型之间的转换、指向基类和派生类之间的转换（只要没有虚继承），以及用户定义的类型转换（通过转换构造函数或转换运算符）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(i); <span class="comment">// 基础数据类型转换</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2-dynamic-cast"><a href="#3-3-2-dynamic-cast" class="headerlink" title="3.3.2 dynamic_cast"></a>3.3.2 <code>dynamic_cast</code></h3><p><code>dynamic_cast</code> 专门用于处理多态类型。它在运行时检查对象类型，确保转换的安全性。<code>dynamic_cast</code> 主要用于将基类指针或引用安全地转换为派生类指针或引用，它依赖于运行时类型信息（<code>RTTI</code>）。</p><p>如果转换失败，当转换的目标类型是指针时，<code>dynamic_cast</code> 返回 <code>nullptr</code>；当目标类型是引用时，则抛出一个 <code>std::bad_cast</code> 异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line">Base* base_ptr = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived* derived_ptr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base_ptr); <span class="comment">// 安全地转换为派生类指针</span></span><br></pre></td></tr></table></figure><h3 id="3-3-3-const-cast"><a href="#3-3-3-const-cast" class="headerlink" title="3.3.3 const_cast"></a>3.3.3 <code>const_cast</code></h3><p><code>const_cast</code> 用于改变对象的 <code>const</code> 或 <code>volatile</code> 属性。它是唯一能够去除对象的 <code>const</code> 属性的 C++ 类型转换运算符。但是，它不应该用来去除对象本身就是常量的 <code>const</code> 属性，那样会导致未定义行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* modifiable = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;i); <span class="comment">// 去除 const 属性</span></span><br></pre></td></tr></table></figure><h3 id="3-3-4-reinterpret-cast"><a href="#3-3-4-reinterpret-cast" class="headerlink" title="3.3.4 reinterpret_cast"></a>3.3.4 <code>reinterpret_cast</code></h3><p><code>reinterpret_cast</code> 提供了低级别的重新解释类型的能力，它可以将任何指针转换为任何其他类型的指针。也可以用于指针与足够大的整数类型之间的转换。<code>reinterpret_cast</code> 不检查语义安全性，其实也就类似C语言的强制转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> p = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="type">void</span>* vp = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(p); <span class="comment">// 将整数转换为 void 指针</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是对个人在2022年秋的&lt;code&gt;CMU15445&lt;/code&gt;的&lt;code&gt;project&lt;/code&gt;总结, 算是补档, 所有很多代码也忘了, 这里也就值只介绍其中的思路, 不涉及具体代码细节, 不过&lt;code&gt;CMU15445&lt;/code&gt;的老师&lt;code&gt;And</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CMU15445" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/CMU15445/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="Trie" scheme="http://example.com/tags/Trie/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>清华大学开源操作系统训练营: rCore chapter1笔记</title>
    <link href="http://example.com/2024/02/05/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch1%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/02/05/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch1%E7%AC%94%E8%AE%B0/</id>
    <published>2024-02-05T07:06:13.000Z</published>
    <updated>2024-02-21T16:16:04.677Z</updated>
    
    <content type="html"><![CDATA[<p>本文不会将原本<code>rCore文档</code>的内容重复太多, 主要是补充学习过程中遇到的知识点, 因此还需结合原文使用, 原文在后面的链接中</p><p>本章节的内容是介绍如何构建一个能在裸机上运行的<code>Rust</code>程序, 这一部分其实也是很多操作系统课程, 包括<code>MIT 6.S081</code>缺少的部分, 通过这一部分, 我们可以学习到操作系统和硬件之间是如何工作的, 还是挺重要的。</p><p>本文是只个人对官方文档第一章知识的梳理和补充，因此一些基础的知识概念并不会再设计， 这些细节请阅读：</p><p>完整版官方文档： <a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/1app-ee-platform.html">https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/1app-ee-platform.html</a></p><p>精简版文档： <a href="https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter1/index.html">https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter1/index.html</a></p><h1 id="1-理论知识梳理"><a href="#1-理论知识梳理" class="headerlink" title="1 理论知识梳理"></a>1 理论知识梳理</h1><h2 id="1-1-应用程序执行环境"><a href="#1-1-应用程序执行环境" class="headerlink" title="1.1 应用程序执行环境"></a>1.1 应用程序执行环境</h2><p><img src="/../../../images/LearningOS/ch1-env.png" alt="应用程序执行环境栈"></p><p>上图是从官方文档中摘取的，<code>操作系统</code>承接了<code>硬件平台</code>和各种编程语言标准库中的<code>系统调用</code>, 裸机程序就是没有操作系统的程序, 因此我们实现的程序需要绕过标准库直接和硬件打交道, 一句话就是, 不能调包了, 得手写</p><h2 id="1-2-平台与目标三元组"><a href="#1-2-平台与目标三元组" class="headerlink" title="1.2 平台与目标三元组"></a>1.2 平台与目标三元组</h2><p>目标三元组 (Target Triplet): CPU 指令集、操作系统类型和标准运行时库。</p><p><code>Rust</code>工具链中的<code>rustc</code>可以获取以上信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ rustc --version --verbose</span><br><span class="line">rustc 1.75.0-nightly (aa1a71e9e 2023-10-26)</span><br><span class="line">binary: rustc</span><br><span class="line">commit-hash: aa1a71e9e90f6eb3aed8cf79fc80bea304c17ecb</span><br><span class="line">commit-date: 2023-10-26</span><br><span class="line">host: x86_64-unknown-linux-gnu</span><br><span class="line">release: 1.75.0-nightly</span><br><span class="line">LLVM version: 17.0.3</span><br></pre></td></tr></table></figure><p><code>host</code>中展示了: 目标平台是<code> x86_64-unknown-linux-gnu</code>， CPU 架构是 <code>x86_64</code>，CPU 厂商是 <code>unknown</code>, 操作系统是 <code>linux</code>，运行时库是 <code>gnu</code></p><h2 id="1-3-从qemu看层级架构"><a href="#1-3-从qemu看层级架构" class="headerlink" title="1.3 从qemu看层级架构"></a>1.3 从qemu看层级架构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-riscv64 \</span><br><span class="line">    -machine virt \</span><br><span class="line">    -nographic \</span><br><span class="line">    -bios ../bootloader/rustsbi-qemu.bin \</span><br><span class="line">    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000</span><br></pre></td></tr></table></figure><p>下面是<code>qemu</code>的启动命令, 其中<code>os.bin</code>就是我们构建的裸机程序, 但为什么又存在一个<code>rustsbi-qemu.bin</code>呢?</p><p>这涉及到计算机的启动流程, 在<code>qemu</code>虚拟平台上, 第一阶段的启动是<code>qemu</code>自己提供的程序, 第二段启动是<code>bootloader</code>, <code>bootloader</code>进行硬件相关的初始化工作, 第三个阶段是加载操作系统镜像（就是这里的裸机程序）。每一阶段的程序都需要将下一阶段程序放在指定的位置并进行跳转。</p><p>也就是说，我们的裸机程序直接在<code>bootloader</code>启动后就运行了， 不需要操作系统</p><p>更详细的启动流程请见<a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/3first-instruction-in-kernel1.html#id5">官方文档说明</a></p><h2 id="1-4-裸机程序构建思路"><a href="#1-4-裸机程序构建思路" class="headerlink" title="1.4 裸机程序构建思路"></a>1.4 裸机程序构建思路</h2><p>第一章中, 裸机程序的构建实际上就是一步步<strong>剥离标准库</strong>并实现替代标准库中相应数据结构和函数的过程。因为<code>std</code>依赖于操作系统, 因此需要用不依赖与操作系统的<code>core</code>代替</p><p>裸机程序的代码其实不复杂, 只是涉及一些不常用的知识点, 包括内联汇编等, 这些在后面的补充知识会介绍到, 除此外, 原始文档给的代码很详细了, 因此这里就不进行代码分析了。</p><h2 id="1-5-链接脚本的作用"><a href="#1-5-链接脚本的作用" class="headerlink" title="1.5 链接脚本的作用"></a>1.5 链接脚本的作用</h2><p>由于上述的原因，<code>bootloader</code>启动后跳转的地址是固定的(<code>bootloader</code>已经提供了, 不需要自己实现), 所以程序需要将起始位置放置在这固定的内存位置(此时还没有页表, 是物理内存地址), 这就是链接脚本的作用</p><p>具体内存也参见<a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/3first-instruction-in-kernel1.html#id8">官方文档说明</a></p><h2 id="1-6-剥离elf"><a href="#1-6-剥离elf" class="headerlink" title="1.6 剥离elf"></a>1.6 剥离elf</h2><p>编译后的代码存在一些元数据段， 因此需要将其剥离才能将程序的第一条指令放在指定的位置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin</span><br></pre></td></tr></table></figure><p>具体的解析参考<a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/4first-instruction-in-kernel2.html#id5">源文档</a></p><h2 id="1-7-sbi的调用时机"><a href="#1-7-sbi的调用时机" class="headerlink" title="1.7 sbi的调用时机"></a>1.7 <code>sbi</code>的调用时机</h2><p>我第一次阅读官方文档后仍然有一个疑惑, 就是我们是如何调用<code>sbi</code>, 提供的服务的? </p><p>实际上还是使用<code>ecall</code>, 先贴出调用<code>sbi</code>的代码:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[inline(always)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sbi_call</span>(which: <span class="type">usize</span>, arg0: <span class="type">usize</span>, arg1: <span class="type">usize</span>, arg2: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(</span><br><span class="line">            <span class="string">&quot;li x16, 0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">inlateout</span>(<span class="string">&quot;x10&quot;</span>) arg0 =&gt; ret,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x11&quot;</span>) arg1,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x12&quot;</span>) arg2,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x17&quot;</span>) which,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里, 和U模式下的系统调用中<code>ecall</code>的使用类似, S模式下也是通过<code>ecall</code>来进入M模式, 从而使用<code>sbi</code>提供的服务。相关部分会在后续的系统调用章节进行更多的介绍， 此处只简单介绍：</p><ol><li>S 模式下的操作系统设置 <code>a0-a7 </code>和<code> t0</code> 寄存器，以指定所需的 SBI 调用和参数。</li><li>操作系统执行 <code>ecall</code> 指令，触发异常并切换到 M 模式。</li><li>M 模式下的 <code>SBI</code> 实现查看寄存器的值，确定请求的服务并执行它。</li><li><code>SBI</code> 实现将结果存入寄存器中。</li><li>控制权返回给 S 模式的操作系统，操作系统读取寄存器以获取服务结果。</li></ol><p>这种机制允许分离操作系统和机器模式执行环境，使得操作系统无须了解硬件的详细实现，也能够利用硬件提供的功能。</p><h1 id="2-补充知识"><a href="#2-补充知识" class="headerlink" title="2 补充知识"></a>2 补充知识</h1><h2 id="2-1-cargo配置"><a href="#2-1-cargo配置" class="headerlink" title="2.1 cargo配置"></a>2.1 <code>cargo</code>配置</h2><p><code>Rust</code> 项目中，<code>.cargo/config</code> 是一个配置文件，用于定义和调整 Cargo 的各种行为和设置。<code>Cargo</code> 是 <code>Rust</code> 的包管理器和构建工具，它处理依赖下载、编译过程及更多功能。<code>.cargo/config</code> 文件通常位于项目的根目录下的 <code>.cargo</code> 文件夹内，或者在用户的主目录下的 <code>.cargo</code> 文件夹内作为全局配置。</p><p>下面是 <code>.cargo/config</code> 文件中一些基本配置操作的概述：</p><ol><li><p>设置构建目标<br>可以指定默认的构建目标（target triple）：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[build]</span></span><br><span class="line"><span class="attr">target</span> = <span class="string">&quot;riscv64gc-unknown-none-elf&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>设置构建标志<br>可以添加自定义的构建标志，比如优化等级、链接参数等：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[build]</span></span><br><span class="line"><span class="attr">rustflags</span> = [<span class="string">&quot;-C&quot;</span>, <span class="string">&quot;opt-level=2&quot;</span>]</span><br></pre></td></tr></table></figure></li><li><p>设置环境变量<br>可以设置在构建脚本中使用的环境变量：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[build]</span></span><br><span class="line"><span class="attr">rustc-env</span> = [<span class="string">&quot;RUST_BACKTRACE=1&quot;</span>]</span><br></pre></td></tr></table></figure></li><li><p>定义自定义构建目标<br>如果有一个自定义的架构，可以指定链接器和其他构建参数：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[target.i686-unknown-linux-gnu]</span></span><br><span class="line"><span class="attr">linker</span> = <span class="string">&quot;gcc&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>重写依赖源<br>如果需要从不同的源或者私有源下载依赖项，可以重写它们：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[source.crates-io]</span></span><br><span class="line"><span class="attr">replace-with</span> = <span class="string">&#x27;tuna&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[source.tuna]</span></span><br><span class="line"><span class="attr">registry</span> = <span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>设置别名<br>可以为常用的命令设置别名，以便更快地调用：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[alias]</span></span><br><span class="line"><span class="attr">b</span> = <span class="string">&quot;build&quot;</span></span><br><span class="line"><span class="attr">r</span> = <span class="string">&quot;run&quot;</span></span><br><span class="line"><span class="attr">t</span> = <span class="string">&quot;test&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>配置货物配置文件<br>可以为不同的构建配置（例如 debug 或 release）指定不同的设置：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure></li></ol><p>在实际使用中，应该根据项目的具体需要来调整这些设置。此外，<code>.cargo/config</code> 文件支持层级结构，可以在多个目录级别定义配置文件，Cargo 会合并这些配置，其中更具体（更深层目录）的配置会覆盖更通用（更高层目录）的配置。</p><p>下面是本项目的<code>cargo</code>配置文件:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[build]</span></span><br><span class="line"><span class="section">[build]</span></span><br><span class="line"><span class="attr">target</span> = <span class="string">&quot;riscv64gc-unknown-none-elf&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[target.riscv64gc-unknown-none-elf]</span></span><br><span class="line"><span class="attr">rustflags</span> = [</span><br><span class="line">    <span class="string">&quot;-Clink-arg=-Tsrc/linker.ld&quot;</span>, <span class="string">&quot;-Cforce-frame-pointers=yes&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其中 两个 Rust 编译器标志（<code>rustflags</code>）解释如下：</p><ol><li><p><code>-Clink-arg=-Tsrc/linker.ld</code>: 这告诉 Rust 编译器传递 <code>linker.ld</code> 链接器脚本文件的路径给链接器。链接器脚本文件通常用于指导链接器如何生成最终的可执行文件，包括内存布局等。这里 <code>linker.ld</code> 文件位于项目的 <code>src</code> 目录下。</p></li><li><p><code>-Cforce-frame-pointers=yes</code>: 这指示 Rust 编译器在生成可执行文件时，即使在优化模式下也保留帧指针。帧指针通常用于帮助调试和获取函数调用栈信息，但有时在优化时会被省略以提高性能。</p></li></ol><h2 id="2-2-链接脚本的语法"><a href="#2-2-链接脚本的语法" class="headerlink" title="2.2 链接脚本的语法"></a>2.2 链接脚本的语法</h2><p>下面是<code>ch1</code>中使用的链接脚本:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_ARCH(riscv) </span><br><span class="line">/*设置了目标平台为 riscv */</span><br><span class="line">ENTRY(_start)</span><br><span class="line">/* 设置了整个程序的入口点为之前定义的全局符号 _start */</span><br><span class="line">BASE_ADDRESS = 0x80200000;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = BASE_ADDRESS;</span><br><span class="line">    skernel = .;</span><br><span class="line"></span><br><span class="line">    stext = .;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    etext = .;</span><br><span class="line">    srodata = .;</span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata .rodata.*)</span><br><span class="line">        *(.srodata .srodata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    erodata = .;</span><br><span class="line">    sdata = .;</span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data .data.*)</span><br><span class="line">        *(.sdata .sdata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    edata = .;</span><br><span class="line">    .bss : &#123;</span><br><span class="line">        *(.bss.stack)</span><br><span class="line">        sbss = .;</span><br><span class="line">        *(.bss .bss.*)</span><br><span class="line">        *(.sbss .sbss.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    ebss = .;</span><br><span class="line">    ekernel = .;</span><br><span class="line"></span><br><span class="line">    /DISCARD/ : &#123;</span><br><span class="line">        *(.eh_frame)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链接脚本 (<code>Linker Script</code>) 是由 <code>GNU</code> 链接器 (<code>ld</code>) 使用的脚本语言，用于控制程序的链接过程。链接脚本的语法允许用户定义输出文件的内存布局，指定各个段的位置、大小和属性。</p><ol><li><p>输出架构 (<code>OUTPUT_ARCH</code>)<br><code>OUTPUT_ARCH(architecture)</code><br>  指定目标架构，告诉链接器生成针对特定架构的代码。</p></li><li><p>入口点 (<code>ENTRY</code>)<br><code>ENTRY(symbol)</code><br>  指定程序的入口点，即程序开始执行的地方。</p></li><li><p>符号赋值<br><code>symbol = expression;</code><br>  定义符号，并将其设置为特定的值或地址。</p></li><li><p>段定义 (<code>SECTIONS</code>)<br><code>SECTIONS &#123;...&#125;</code><br>  段定义块开始和结束的标志，里面包含了对输出段的具体指令。</p></li><li><p>地址计数器<br><code>.</code> (点) 表示当前地址计数器，可以设置为特定值或者用于符号赋值。<br><strong>进行字段包含后, 其会自动地增长</strong></p></li><li><p>段地址和属性<br><code>segment : &#123; subsections &#125;</code><br>  定义一个段（如 <code>.text</code>, <code>.data</code>），并指定包含在该段的子段内容。</p></li><li><p>子段<br><code>*(.subsection)</code><br>  将特定的子段包含进父段中，如将 <code>.text</code> 子段包含进 <code>.text</code> 段中。</p></li><li><p>对齐指令 (ALIGN)<br><code>ALIGN(expression)</code><br>  对当前地址计数器进行对齐，确保地址是特定值的倍数，常用于页对齐或数据结构对齐。</p></li><li><p>输出段属性</p></li></ol><ul><li><code>&gt;region</code><br>指定输出段应该放置在哪个内存区域。</li><li><code>AT(address)</code><br>指定输出段的加载地址，与放置地址可能不同。</li><li><code>:alignment</code><br>指定段对齐。</li></ul><ol start="10"><li>内存布局 (<code>MEMORY</code>)</li></ol><ul><li><code>MEMORY &#123; ... &#125;</code><br>定义内存布局和属性，用于告诉链接器如何使用不同的内存区域。</li></ul><ol start="11"><li><code>/DISCARD/</code></li></ol><ul><li><code>/DISCARD/ : &#123; ... &#125;</code><br>用于丢弃不需要的段，例如调试信息或未使用的段。</li></ul><p>现在再来看本章的链接脚本:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_ARCH(riscv) </span><br><span class="line">/*设置了目标平台为 riscv */</span><br><span class="line">ENTRY(_start)</span><br><span class="line">/* 设置了整个程序的入口点为之前定义的全局符号 _start */</span><br><span class="line">BASE_ADDRESS = 0x80200000;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = BASE_ADDRESS;</span><br><span class="line">    skernel = .;</span><br><span class="line"></span><br><span class="line">    stext = .;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    etext = .;</span><br><span class="line">    srodata = .;</span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata .rodata.*)</span><br><span class="line">        *(.srodata .srodata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    erodata = .;</span><br><span class="line">    sdata = .;</span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data .data.*)</span><br><span class="line">        *(.sdata .sdata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    edata = .;</span><br><span class="line">    .bss : &#123;</span><br><span class="line">        *(.bss.stack)</span><br><span class="line">        sbss = .;</span><br><span class="line">        *(.bss .bss.*)</span><br><span class="line">        *(.sbss .sbss.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    ebss = .;</span><br><span class="line">    ekernel = .;</span><br><span class="line"></span><br><span class="line">    /DISCARD/ : &#123;</span><br><span class="line">        *(.eh_frame)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就很好理解了, 其分别将指的目标文件中各个段的内容整合在一起, 并且为每个段的开始地址声明了变量: <code>stext</code>, <code>etext</code>, <code>erodata</code>, <code>edata</code>, <code>ebss</code> </p><h2 id="2-3-Rust宏语法"><a href="#2-3-Rust宏语法" class="headerlink" title="2.3 Rust宏语法"></a>2.3 <code>Rust</code>宏语法</h2><p>本项目执行实现了<code>println!</code>宏, 在我之前学<code>Rust</code>时, 主要是使用已定义的宏, 自己实现宏的部分仅仅是略过, 因此这里特别来复习下宏的定义, 项目中定义了下面的宏:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> print &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        $crate::console::<span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>($fmt $(, $($arg)+)?))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释如下:</p><ol><li><p><code>#[macro_export]</code><br>表示这个宏是要被导出的，使得当这个宏所在的<code>crate</code>被其他<code>crate</code>引用时，这个宏也可以被使用。</p></li><li><p><code>macro_rules!</code><br>这是宏的声明开始，<code>macro_rules!</code>是Rust中定义宏的关键字，后面跟着的<code>println</code>是宏的名字。</p></li><li><p>宏的匹配部分</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">($fmt: literal $(, $($arg: tt)+)?)</span><br></pre></td></tr></table></figure><p> 这行定义了宏的模式匹配部分。它匹配一个字面量<code>$fmt</code>作为第一个参数，后面可以跟一个逗号和任意数量的额外参数<code>$arg</code>。参数使用Rust宏的”token tree” (<code>tt</code>)设计，它可以匹配几乎任何Rust语法。</p></li></ol><ul><li><code>$fmt: literal</code>表示第一个参数必须是一个字面量（通常是一个字符串字面量）。</li><li><code>literal</code>: 一个特定的关键字, 用来指定宏参数应该是一个字面量</li><li><code>$(, $($arg: tt)+)?</code>是一个可选的模式，它使用了Rust宏的重复模式：</li><li><code>$($arg: tt)+</code>表示可以有一个或多个额外的参数，每个参数都是一个<code>token tree</code>。</li></ul><blockquote><p>补充宏知识<br>在Rust的宏定义中，<code>$</code>和<code>?</code>符号都用于模式匹配，但它们在宏规则中扮演着不同的角色。</p><ul><li><code>$</code> 符号: <ul><li>用法1: 指示一个变量的开始，可以捕获宏输入中的相应部分。在宏规则中，<code>$</code>后面通常跟着一个标识符和一个冒号，再跟着一个设计符(<code>designator</code>)，用来指定变量的类型。例如，<code>$var:ident</code>表示匹配一个标识符并将其绑定到变量<code>$var</code>中。</li><li>用法2: 标识重复的开始，例如<code>$($arg:tt),*</code>表示重复匹配<code>$arg</code>零次或多次，每次匹配由逗号分隔。</li></ul></li><li><code>?</code> 符号: 它用于表示前面的模式是可选的。在宏规则中，将<code>?</code>放在模式的外部，表示这个模式可以出现零次或一次。这类似于正则表达式中的<code>?</code>运算符。例如，在<code>$($arg:tt)?</code>中，<code>?</code>表明<code>$arg</code>是可选的，可以有或没有。</li><li><code>+</code> 符号: 它用于表示前面的模式出现一次多次。在宏规则中，将<code>+</code>放在模式的外部，表示这个模式可以出现一次或多次。这类似于正则表达式中的<code>+</code>运算符。例如，在<code>$($arg:tt)+</code>中，<code>?</code>表明<code>$arg</code>以出现一次或多次</li></ul><p>结合上面的符号使用时，<code>$</code>捕获宏参数，而<code>?</code>或<code>+</code>指定这些参数的重复模式。所以<code>$(, $($arg: tt)+)?</code>这部分的意思是：</p><ul><li><code>$( ... )?</code> 表示整个模式是可选的，即可以有也可以没有。</li><li><code>,</code> 表示模式的开始，一个逗号，用来分隔参数。</li><li><code>$($arg: tt)+</code> 表示匹配一个或多个<code>$arg</code>，每个<code>$arg</code>是一个token tree。</li></ul></blockquote><ol start="4"><li>匹配后的动作<br>根据前面的分析, 这个模式可以匹配零个或多个以逗号分隔的<code>token trees</code>，如果匹配到，则将这些<code>token trees</code>作为参数传递给<code>format_args!</code>宏。 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$crate::console::<span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>(<span class="built_in">concat!</span>($fmt, <span class="string">&quot;\n&quot;</span>) $(, $($arg)+)?))</span><br></pre></td></tr></table></figure></li></ol><p>这是宏展开的部分。</p><ul><li><code>$crate</code>是一个特殊的变量，它在宏内部用于引用当前<code>crate</code>的根路径，这样即使宏被移动到其他crate中，它也能正确地引用到原来的<code>crate</code>中定义的项。</li><li><code>format_args!</code>是Rust的一个内置宏，用于处理格式化参数。它接受一个格式化字符串和对应的参数，并返回一个可以延迟计算的格式化参数结构体，这通常用于避免字符串的分配和复制。</li><li><code>concat!($fmt, &quot;\n&quot;)</code>将传入的格式化字符串和一个换行符连在一起，确保输出后会自动换行。</li><li><code>$(, $($arg)+)?</code>是对传入参数的引用，如果有参数的话，它们会被插入到格式化参数结构体中。</li></ul><h2 id="2-4-Rust内联汇编"><a href="#2-4-Rust内联汇编" class="headerlink" title="2.4 Rust内联汇编"></a>2.4 Rust内联汇编</h2><p>使用的<code>RustSbi</code>中存在如下的<code>Rust</code>内联汇编的用法:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[inline(always)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sbi_call</span>(which: <span class="type">usize</span>, arg0: <span class="type">usize</span>, arg1: <span class="type">usize</span>, arg2: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(</span><br><span class="line">            <span class="string">&quot;li x16, 0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">inlateout</span>(<span class="string">&quot;x10&quot;</span>) arg0 =&gt; ret,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x11&quot;</span>) arg1,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x12&quot;</span>) arg2,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x17&quot;</span>) which,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释如下:</p><ol><li><p><code>#[inline(always)]</code><br><code>Rust</code>的属性<code>#[inline(always)]</code>告诉编译器这个函数应该总是被内联，也就是说，在每个调用点替换为函数体的代码，而不是实际进行函数调用。</p></li><li><p><code>asm!</code><br><code>asm!</code>宏是用来编写内联汇编代码的，这段代码直接使用了RISC-V的汇编语法：</p><ul><li><p><code>&quot;li x16, 0&quot;</code>：这条指令将立即数0加载到寄存器<code>x16</code>中。<code>li</code>代表”load immediate”。</p></li><li><p><code>&quot;ecall&quot;</code>：陷入更低级的模式</p></li><li><p><code>inlateout(&quot;x10&quot;) arg0 =&gt; ret</code><br>  在<code>ecall</code>执行后，返回值通常存放在<code>x10</code>寄存器中。Rust内联汇编通过<code>inlateout(&quot;x10&quot;) arg0 =&gt; ret</code>这个约束来传递这个信息，即<code>arg0</code>的值在<code>ecall</code>执行前被放入<code>x10</code>寄存器中，并且<code>ecall</code>执行后，<code>x10</code>寄存器中的值会存放到变量<code>ret</code>中。</p></li><li><p><code>in(&quot;x11&quot;) arg1</code> &amp;&amp; <code>in(&quot;x12&quot;) arg2</code> &amp;&amp; <code>in(&quot;x17&quot;) which</code><br>  在执行汇编代码前将值加载到指定的寄存器中。在这种情况下，<code>arg1</code>被加载到<code>x11</code>寄存器，<code>arg2</code>被加载到<code>x12</code>寄存器，<code>which</code>被加载到<code>x17</code>寄存器。</p></li></ul></li></ol><p>这里容易产生一个误区, 就是, 存放输入寄存器的操作位于<code>ecall</code>出现之后, 实际上所有的输入操作数都是在执行任何汇编指令之前就被放入相应寄存器中的。</p><h2 id="2-5-直接嵌入汇编代码"><a href="#2-5-直接嵌入汇编代码" class="headerlink" title="2.5 直接嵌入汇编代码"></a>2.5 直接嵌入汇编代码</h2><p>可以使用 <code>global_asm!</code> 宏包含全局汇编代码。这个宏允许在 <code>Rust</code> 代码中直接嵌入汇编代码片段，并且这些代码会在全局范围内被汇编器处理。</p><p>以下项目代码中的 <code>global_asm!</code> 的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(global_asm)]</span></span><br><span class="line"></span><br><span class="line">global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;entry.asm&quot;</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文不会将原本&lt;code&gt;rCore文档&lt;/code&gt;的内容重复太多, 主要是补充学习过程中遇到的知识点, 因此还需结合原文使用, 原文在后面的链接中&lt;/p&gt;
&lt;p&gt;本章节的内容是介绍如何构建一个能在裸机上运行的&lt;code&gt;Rust&lt;/code&gt;程序, 这一部分其实也是很多</summary>
      
    
    
    
    <category term="训练营笔记" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
    
    <category term="清华大学开源操作系统训练营2023" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A52023/"/>
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="riscv" scheme="http://example.com/tags/riscv/"/>
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.5840(6.824) Lab3: 分布式KV数据库 3B</title>
    <link href="http://example.com/2024/02/03/MIT6.5840/Lab3B/"/>
    <id>http://example.com/2024/02/03/MIT6.5840/Lab3B/</id>
    <published>2024-02-03T10:19:25.000Z</published>
    <updated>2024-02-27T06:02:43.812Z</updated>
    
    <content type="html"><![CDATA[<p><em>最新的更新在博客 <a href="https://tonixwd.github.io/">ToniBlog</a></em></p><p>本文将介绍<code>lab3B</code>部分的实现, <code>lab3B</code>要求基于在<code>lab3A</code>的基础上实现快照, 仅从<code>lab</code>本省来讲其实很简单, 可以说是目前我做的所有<code>lab</code>里面难度最小的一个模块了, 但实际上遇到了很多困难, 调试的时间比<code>lab3A</code>还久, 核心原因就是自己的<code>lab2</code>实现的<code>raft</code>底层有一些问题(真真真真太折磨了, 即时过了所有单元测试, 还是时不时地在后续的<code>lab</code>暴露出问题来, 并且这些问题还挺难定位, 得仔细分析海量的<code>log</code>输出才可以)</p><p><code>Lab</code>文档见: <a href="http://nil.csail.mit.edu/6.5840/2023/labs/lab-kvraft.html">http://nil.csail.mit.edu/6.5840/2023/labs/lab-kvraft.html</a></p><p>我的代码: <a href="https://github.com/ToniXWD/MIT6.5840/tree/lab3B">https://github.com/ToniXWD/MIT6.5840/tree/lab3B</a></p><h1 id="1-快照的生成和传递逻辑"><a href="#1-快照的生成和传递逻辑" class="headerlink" title="1 快照的生成和传递逻辑"></a>1 快照的生成和传递逻辑</h1><p>简单说, <code>lab3B</code>就是要在底层<code>raft</code>的<code>log</code>过大时生成快照并截断日志, 从而节省内存空间, 并且快照会持久化存储到本地。因此， 原来的代码结构只需要在以下几个方面做出调整：</p><ol><li>需要再某个地方定期地判断底层<code>raft</code>的日志大小, 决定是否要生成快照, 生成快照直接调用我们在<code>lab2</code>中实现的接口<code>Snapshot</code>即可</li><li>由于<code>follower</code>的底层<code>raft</code>会出现无法从<code>Leader</code>获取<code>log</code>的情况, 这时<code>Leader</code>会发送给<code>follower</code>的<code>raft</code>层一个快照, <code>raft</code>层会将其上交给<code>server</code>, <code>server</code>通过快照改变自己的状态机</li><li><code>server</code>启动时需要判断是否有持久化的快照需要加载, 如果有就加载</li></ol><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a>2 代码实现</h1><h2 id="2-1-快照应该包含什么"><a href="#2-1-快照应该包含什么" class="headerlink" title="2.1 快照应该包含什么?"></a>2.1 快照应该包含什么?</h2><p>快照首先应该包含的肯定是内存中的<code>KV</code>数据库, 也就是自己维护的<code>map</code>, 但是还应该包含对每个<code>clerk</code>序列号的记录信息, 因为从快照恢复后的<code>server</code>应该具备判断重复的客户端请求的能力, 同时也应该记录最近一次应用到状态机的日志索引, 凡是低于这个索引的日志都是包含在快照中</p><p>因此, <code>server</code>结构体需要添加如下成员:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KVServer <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">persister    *raft.Persister</span><br><span class="line">lastApplied  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-加载和生成快照"><a href="#2-2-加载和生成快照" class="headerlink" title="2.2 加载和生成快照"></a>2.2 加载和生成快照</h2><p>通过上述分析, 快照的加载和生成就很简单了,代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> GenSnapShot() []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="comment">// 调用时必须持有锁mu</span></span><br><span class="line">w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">e := labgob.NewEncoder(w)</span><br><span class="line"></span><br><span class="line">e.Encode(kv.db)</span><br><span class="line">e.Encode(kv.historyMap)</span><br><span class="line"></span><br><span class="line">serverState := w.Bytes()</span><br><span class="line"><span class="keyword">return</span> serverState</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> LoadSnapShot(snapShot []<span class="type">byte</span>) &#123;</span><br><span class="line"><span class="comment">// 调用时必须持有锁mu</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(snapShot) == <span class="number">0</span> || snapShot == <span class="literal">nil</span> &#123;</span><br><span class="line">ServerLog(<span class="string">&quot;server %v LoadSnapShot: 快照为空&quot;</span>, kv.me)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r := bytes.NewBuffer(snapShot)</span><br><span class="line">d := labgob.NewDecoder(r)</span><br><span class="line"></span><br><span class="line">tmpDB := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">tmpHistoryMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]*Result)</span><br><span class="line"><span class="keyword">if</span> d.Decode(&amp;tmpDB) != <span class="literal">nil</span> ||</span><br><span class="line">d.Decode(&amp;tmpHistoryMap) != <span class="literal">nil</span> &#123;</span><br><span class="line">ServerLog(<span class="string">&quot;server %v LoadSnapShot 加载快照失败\n&quot;</span>, kv.me)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">kv.db = tmpDB</span><br><span class="line">kv.historyMap = tmpHistoryMap</span><br><span class="line">ServerLog(<span class="string">&quot;server %v LoadSnapShot 加载快照成功\n&quot;</span>, kv.me)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GenSnapShot</code>和<code>LoadSnapShot</code>分别生成和加载快照, 唯一需要注意的就是这两个函数应当在持有锁时才能调用</p><h2 id="2-3-生成快照的时机判断"><a href="#2-3-生成快照的时机判断" class="headerlink" title="2.3 生成快照的时机判断"></a>2.3 生成快照的时机判断</h2><p>由于<code>ApplyHandler</code>协程会不断地读取<code>raft commit</code>的通道, 所以每收到一个<code>log</code>后进行判断即可:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> ApplyHandler() &#123;</span><br><span class="line"><span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">log := &lt;-kv.applyCh</span><br><span class="line"><span class="keyword">if</span> log.CommandValid &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 如果在follower一侧, 可能这个log包含在快照中, 直接跳过</span></span><br><span class="line"><span class="keyword">if</span> log.CommandIndex &lt;= kv.lastApplied &#123;</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 每收到一个log就检测是否需要生成快照</span></span><br><span class="line"><span class="keyword">if</span> kv.maxraftstate != <span class="number">-1</span> &amp;&amp; kv.persister.RaftStateSize() &gt;= kv.maxraftstate/<span class="number">100</span>*<span class="number">95</span> &#123;</span><br><span class="line"><span class="comment">// 当达到95%容量时需要生成快照</span></span><br><span class="line">snapShot := kv.GenSnapShot()</span><br><span class="line">kv.rf.Snapshot(log.CommandIndex, snapShot)</span><br><span class="line">&#125;</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还需要进行之前提到的判断: 低于<code>lastApplied</code>索引的日志都是包含在快照中, 在尽显<code>lab3A</code>的操作之后, 再判断是否需要生成快照, 在我的实现中, 如果仅仅比较<code>maxraftstate</code>和<code>persister.RaftStateSize()</code>相等才生成快照的话, 无法通过测例, 因为可能快照<code>RPC</code>存在一定延时, 所以我采用的手段是只要达到阈值的95%, 就生成快照</p><h2 id="2-4-加载快照的时机判断"><a href="#2-4-加载快照的时机判断" class="headerlink" title="2.4 加载快照的时机判断"></a>2.4 加载快照的时机判断</h2><p>首先启动时需要判断是否需要加载快照, 然后就是<code>ApplyHandler</code>从通道收到快照时需要判断加载, 都很简单:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartKVServer</span><span class="params">(servers []*labrpc.ClientEnd, me <span class="type">int</span>, persister *raft.Persister, maxraftstate <span class="type">int</span>)</span></span> *KVServer &#123;</span><br><span class="line">...</span><br><span class="line">kv.persister = persister</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先在启动时检查是否有快照</span></span><br><span class="line">kv.mu.Lock()</span><br><span class="line">kv.LoadSnapShot(persister.ReadSnapshot())</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> kv.ApplyHandler()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> ApplyHandler() &#123;</span><br><span class="line"><span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">log := &lt;-kv.applyCh</span><br><span class="line"><span class="keyword">if</span> log.CommandValid &#123;</span><br><span class="line">            ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> log.SnapshotValid &#123;</span><br><span class="line"><span class="comment">// 日志项是一个快照</span></span><br><span class="line">kv.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> log.SnapshotIndex &gt;= kv.lastApplied &#123;</span><br><span class="line">kv.LoadSnapShot(log.Snapshot)</span><br><span class="line">kv.lastApplied = log.SnapshotIndex</span><br><span class="line">&#125;</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-调试Bug和修复"><a href="#3-调试Bug和修复" class="headerlink" title="3 调试Bug和修复"></a>3 调试Bug和修复</h1><p>这里才是这个<code>lab</code>的重头戏, 我在完成上述所有修改后, 会在<code>TestSnapshotUnreliable3B</code>这个单元测试中大概率卡死, 一直会卡到<code>go</code>默认的十分钟单元测试时间截止后才报错退出, 在反复检查了<strong>死锁</strong>和<strong>持锁接发通道消息</strong>等常见问题并确认无误后, 我再次观察超时报错的堆栈信息和日志输出, 得到结论就是:<br><strong><code>raft</code>层因为无法承受测试的高并发程度而导致大量的<code>RPC</code>请求失败, 从而导致<code>clerk</code>无限重复发送请求<code>RPC</code>(我的实现是<code>RPC</code>请求失败)就重试</strong></p><p>……陷入了沉思, 自己还是菜啊, 但代码还得慢慢修, 总不能把<code>raft</code>推倒重来吧……</p><p>我最后分别从<code>raft</code>层和<code>server</code>层进行了优化</p><h2 id="3-1-raft层优化"><a href="#3-1-raft层优化" class="headerlink" title="3.1 raft层优化"></a>3.1 <code>raft</code>层优化</h2><h3 id="3-1-1-修复过多的AppendEntries-RPC"><a href="#3-1-1-修复过多的AppendEntries-RPC" class="headerlink" title="3.1.1 修复过多的AppendEntries RPC"></a>3.1.1 修复过多的<code>AppendEntries RPC</code></h3><p>通过对日志的调试发现, <code>AppendEntries RPC</code>数量太多了, 这是因为我在<code>lab3A</code>中做了如下修改:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Start(command <span class="keyword">interface</span>&#123;&#125;) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.ResetHeartTimer(<span class="number">1</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rf.VirtualLogIdx(<span class="built_in">len</span>(rf.log) - <span class="number">1</span>), rf.currentTerm, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是在接受一个请求并追加一个<code>log</code>后立即发送<code>AppendEntries RPC</code>, 但是如果在高并发的场景下, 新的请求绵绵不断地到来, 每到达一个请求都发一个<code>RPC</code>, 并且每个<code>RPC</code>可能只包含了长度为1的日志切片, 这是不太合理的设计, 过多的<code>RPC</code>使得<code>raft</code>无法及时处理而出现<code>RPC</code>卡死的情况, 因此, 我手动修改了重置定时器的时间为<code>15ms</code>, 这个值比心跳间隔小很多, 但又不是很小, 足以在满足响应速度的前提下摊销多个命令, 使一次<code>AppendEntries RPC</code>包含多个新的日志项:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Start(command <span class="keyword">interface</span>&#123;&#125;) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.ResetHeartTimer(<span class="number">15</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rf.VirtualLogIdx(<span class="built_in">len</span>(rf.log) - <span class="number">1</span>), rf.currentTerm, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么是<code>15ms</code>…, 我自己也说不出理由, 随便设的, 比心跳小很多, 但又不太小就是了, <strong>本质目的就是积攒多个<code>AppendEntries RPC</code>后一次性发送, 避免<code>AppendEntries RPC</code>数量过大</strong></p><h3 id="3-1-2-修复过多的InstallSnapshot-RPC"><a href="#3-1-2-修复过多的InstallSnapshot-RPC" class="headerlink" title="3.1.2 修复过多的InstallSnapshot RPC"></a>3.1.2 修复过多的<code>InstallSnapshot RPC</code></h3><p>在我原来的设计中, <code>InstallSnapshot RPC</code>的发送有2中情形:</p><ol><li><code>handleAppendEntries</code>在处理<code>AppendEntries RPC</code>回复时发现<code>follower</code>需要的日志项背快照截断, 立即调用<code>go rf.handleInstallSnapshot(serverTo)</code>协程发送快照</li><li>心跳函数发送时发现<code>PrevLogIndex &lt; rf.lastIncludedIndex</code>, 则发送快照</li></ol><p>这和之前的情形类似, 在高并发的场景下，<code>follower</code>和<code>Leader</code>之间的日志复制也很频繁, 如果某一个日志触发了<code>InstallSnapshot RPC</code>的发送, 接下来连续很多个日志也会触发<code>InstallSnapshot RPC</code>的发送, 因为<code>InstallSnapshot RPC</code>的发送时间消耗更大, 这样以来, 又加大了<code>raft</code>的压力, 所以, 我对<code>InstallSnapshot RPC</code>的发送做出修改:</p><ol><li><code>handleAppendEntries</code>在处理<code>AppendEntries RPC</code>回复时发现<code>follower</code>需要的日志项背快照截断, 仅仅设置<code>rf.nextIndex[serverTo] = rf.lastIncludedIndex</code>, 这将导致下一次心跳时调用<code>go rf.handleInstallSnapshot(serverTo)</code>协程发送快照</li><li>心跳函数发送时发现<code>PrevLogIndex &lt; rf.lastIncludedIndex</code>, 则发送快照</li></ol><p>代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> handleAppendEntries(serverTo <span class="type">int</span>, args *AppendEntriesArgs) &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> reply.Term == rf.currentTerm &amp;&amp; rf.role == Leader &#123;</span><br><span class="line"><span class="comment">// term仍然相同, 且自己还是leader, 表名对应的follower在prevLogIndex位置没有与prevLogTerm匹配的项</span></span><br><span class="line"><span class="comment">// 快速回退的处理</span></span><br><span class="line"><span class="keyword">if</span> reply.XTerm == <span class="number">-1</span> &#123;</span><br><span class="line"><span class="comment">// PrevLogIndex这个位置在Follower中不存在</span></span><br><span class="line">DPrintf(<span class="string">&quot;leader %v 收到 server %v 的回退请求, 原因是log过短, 回退前的nextIndex[%v]=%v, 回退后的nextIndex[%v]=%v\n&quot;</span>, rf.me, serverTo, serverTo, rf.nextIndex[serverTo], serverTo, reply.XLen)</span><br><span class="line"><span class="keyword">if</span> rf.lastIncludedIndex &gt;= reply.XLen &#123;</span><br><span class="line"><span class="comment">// 由于snapshot被截断</span></span><br><span class="line"><span class="comment">// 下一次心跳添加InstallSnapshot的处理</span></span><br><span class="line">rf.nextIndex[serverTo] = rf.lastIncludedIndex</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rf.nextIndex[serverTo] = reply.XLen</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> i == rf.lastIncludedIndex &amp;&amp; rf.log[rf.RealLogIdx(i)].Term &gt; reply.XTerm &#123;</span><br><span class="line"><span class="comment">// 要找的位置已经由于snapshot被截断</span></span><br><span class="line"><span class="comment">// 下一次心跳添加InstallSnapshot的处理</span></span><br><span class="line">rf.nextIndex[serverTo] = rf.lastIncludedIndex</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> rf.log[rf.RealLogIdx(i)].Term == reply.XTerm &#123;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 之前PrevLogIndex发生冲突位置时, Follower的Term自己没有</span></span><br><span class="line"><span class="keyword">if</span> reply.XIndex &lt;= rf.lastIncludedIndex &#123;</span><br><span class="line"><span class="comment">// XIndex位置也被截断了</span></span><br><span class="line"><span class="comment">// 添加InstallSnapshot的处理</span></span><br><span class="line">rf.nextIndex[serverTo] = rf.lastIncludedIndex</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rf.nextIndex[serverTo] = reply.XIndex</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-server层优化"><a href="#3-2-server层优化" class="headerlink" title="3.2 server层优化"></a>3.2 <code>server</code>层优化</h2><p><code>server</code>层应该尽量减小对<code>raft</code>层的接口的调用, 因为大量的接口调用将获取<code>raft</code>层的一把大锁, 从而阻碍<code>RPC</code>的响应</p><h3 id="3-2-1-调用Start前过滤"><a href="#3-2-1-调用Start前过滤" class="headerlink" title="3.2.1 调用Start前过滤"></a>3.2.1 调用<code>Start</code>前过滤</h3><p>之前的实现中, 无论是<code>Put/Append</code>还是<code>Get</code>, 都是封装成<code>OP</code>结构体, 在<code>HandleOp</code>中一股脑调用<code>Start</code>扔给<code>raft</code>层处理, 然后在<code>ApplyHandler</code>处进行去重判断, 现在可以在调用<code>raft</code>层的<code>Start</code>之前就从<code>historyMap</code>中判断是否有历史记录可以直接返回:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> HandleOp(opArgs *Op) (res Result) &#123;</span><br><span class="line"><span class="comment">// 先判断是否有历史记录</span></span><br><span class="line">kv.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> hisMap, exist := kv.historyMap[opArgs.Identifier]; exist &amp;&amp; hisMap.LastSeq == opArgs.Seq &#123;</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line">ServerLog(<span class="string">&quot;leader %v HandleOp: identifier %v Seq %v 的请求: %s(%v, %v) 从历史记录返回\n&quot;</span>, kv.me, opArgs.Identifier, opArgs.OpType, opArgs.Key, opArgs.Val)</span><br><span class="line"><span class="keyword">return</span> *hisMap</span><br><span class="line">&#125;</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-减少GetState的调用"><a href="#3-2-2-减少GetState的调用" class="headerlink" title="3.2.2 减少GetState的调用"></a>3.2.2 减少<code>GetState</code>的调用</h3><p><code>ratf</code>的<code>GetState</code>也会获取锁, 从而阻碍<code>RPC</code>的响应速度, 我原来的实现中, <code>GetState</code>会在2个地方调用:</p><ol><li><code>Get</code>和<code>PutAppend</code>调用<code>GetState</code>判断是否是<code>leader</code>, 不是则返回错误</li><li><code>ApplyHandler</code>在通过通道唤醒<code>HandleOp</code>时, 需要判断当前节点是不是<code>leader</code>, 不是<code>leader</code>则不需要唤醒</li></ol><p>以上2不操作看似合理, 但实际上是冗余的:</p><ol><li>首先, <code>Get</code>和<code>PutAppend</code>在后续的<code>HandleOp</code>会调用<code>Start</code>, <code>Start</code>也会因为当前节点不是<code>leader</code>而返回, 所以<code>GetState</code>是冗余的, 反而阻碍<code>RPC</code>响应速度</li><li>其次, <code>ApplyHandler</code>在通过通道唤醒<code>HandleOp</code>时, 日志项本身有<code>term</code>的记录, <code>HandleOp</code>会调用<code>Start</code>时也会获取那时的<code>term</code>, <code>HandleOp</code>只需要在被唤醒后比较前后的<code>term</code>是否相同, 就可以判断出当前的节点是不是一个过时的<code>leader</code></li></ol><p>以上2处修改很简单, 由于是删代码而不是新增和修改, 就不贴代码了, 感兴趣可以看仓库</p><h3 id="3-2-3-clerk先sleep再重试"><a href="#3-2-3-clerk先sleep再重试" class="headerlink" title="3.2.3 clerk先sleep再重试"></a>3.2.3 <code>clerk</code>先<code>sleep</code>再重试</h3><p>这个修改也很简单, 如果<code>server</code>返回了需要重试类型的错误, <code>clerk</code>先<code>sleep</code>一会, 再重试, 代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Get(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">args := &amp;GetArgs&#123;Key: key, Seq: ck.GetSeq(), Identifier: ck.identifier&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">reply := &amp;GetReply&#123;&#125;</span><br><span class="line">ok := ck.servers[ck.leaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, args, reply)</span><br><span class="line"><span class="keyword">if</span> !ok || reply.Err == ErrNotLeader || reply.Err == ErrLeaderOutDated &#123;</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">reply.Err = ERRRPCFailed</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> reply.Err != ErrNotLeader &#123;</span><br><span class="line">DPrintf(<span class="string">&quot;clerk %v Seq %v 重试Get(%v), Err=%s&quot;</span>, args.Identifier, args.Key, args.Key, reply.Err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ck.leaderId += <span class="number">1</span></span><br><span class="line">ck.leaderId %= <span class="built_in">len</span>(ck.servers)</span><br><span class="line">time.Sleep(RpcRetryInterval)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> reply.Err &#123;</span><br><span class="line"><span class="keyword">case</span> ErrChanClose:</span><br><span class="line">DPrintf(<span class="string">&quot;clerk %v Seq %v 重试Get(%v), Err=%s&quot;</span>, args.Identifier, args.Key, args.Key, reply.Err)</span><br><span class="line">time.Sleep(time.Microsecond * <span class="number">5</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> ErrHandleOpTimeOut:</span><br><span class="line">DPrintf(<span class="string">&quot;clerk %v Seq %v 重试Get(%v), Err=%s&quot;</span>, args.Identifier, args.Key, args.Key, reply.Err)</span><br><span class="line">time.Sleep(RpcRetryInterval)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> ErrKeyNotExist:</span><br><span class="line">DPrintf(<span class="string">&quot;clerk %v Seq %v 成功: Get(%v)=%v, Err=%s&quot;</span>, args.Identifier, args.Key, args.Key, reply.Value, reply.Err)</span><br><span class="line"><span class="keyword">return</span> reply.Value</span><br><span class="line">&#125;</span><br><span class="line">DPrintf(<span class="string">&quot;clerk %v Seq %v 成功: Get(%v)=%v, Err=%s&quot;</span>, args.Identifier, args.Key, args.Key, reply.Value, reply.Err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> reply.Value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> PutAppend(key <span class="type">string</span>, value <span class="type">string</span>, op <span class="type">string</span>) &#123;</span><br><span class="line"><span class="comment">// You will have to modify this function.</span></span><br><span class="line">args := &amp;PutAppendArgs&#123;Key: key, Value: value, Op: op, Seq: ck.GetSeq(), Identifier: ck.identifier&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">reply := &amp;PutAppendReply&#123;&#125;</span><br><span class="line">ok := ck.servers[ck.leaderId].Call(<span class="string">&quot;KVServer.PutAppend&quot;</span>, args, reply)</span><br><span class="line"><span class="keyword">if</span> !ok || reply.Err == ErrNotLeader || reply.Err == ErrLeaderOutDated &#123;</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">reply.Err = ERRRPCFailed</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> reply.Err != ErrNotLeader &#123;</span><br><span class="line">DPrintf(<span class="string">&quot;clerk %v Seq %v 重试%s(%v, %v), Err=%s&quot;</span>, args.Identifier, args.Key, args.Op, args.Key, args.Value, reply.Err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ck.leaderId += <span class="number">1</span></span><br><span class="line">ck.leaderId %= <span class="built_in">len</span>(ck.servers)</span><br><span class="line">time.Sleep(RpcRetryInterval)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> reply.Err &#123;</span><br><span class="line"><span class="keyword">case</span> ErrChanClose:</span><br><span class="line">DPrintf(<span class="string">&quot;clerk %v Seq %v 重试%s(%v, %v), Err=%s&quot;</span>, args.Identifier, args.Key, args.Op, args.Key, args.Value, reply.Err)</span><br><span class="line">time.Sleep(RpcRetryInterval)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> ErrHandleOpTimeOut:</span><br><span class="line">DPrintf(<span class="string">&quot;clerk %v Seq %v 重试%s(%v, %v), Err=%s&quot;</span>, args.Identifier, args.Key, args.Op, args.Key, args.Value, reply.Err)</span><br><span class="line">time.Sleep(RpcRetryInterval)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">DPrintf(<span class="string">&quot;clerk %v Seq %v 成功: %s(%v, %v), Err=%s&quot;</span>, args.Identifier, args.Key, args.Op, args.Key, args.Value, reply.Err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h1><ol><li>执行测试命令测试<code>lab3B</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -run 3B</span><br></pre></td></tr></table></figure>结果如下:<br><img src="/../../images/MIT6.5840/lab3B/lab3-3B-test.png" alt="Alt text"><br>可以看出, 取消立即发送心跳广播导致前3个测例满了不少, 但也就凑活吧(<del>不想优化了, 麻木了</del>)</li></ol><p>该代码经过150次测试没有报错</p><ol><li><p>执行测试命令测试整个<code>lab3</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -run 3</span><br></pre></td></tr></table></figure><p>结果如下:<br><img src="/../../images/MIT6.5840/lab3B/lab3-3-test.png" alt="Alt text"><br>该代码经过150次测试没有报错</p></li><li><p>修改后再次测试<code>lab2</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../raft/</span><br><span class="line">go <span class="built_in">test</span> -run 2</span><br></pre></td></tr></table></figure><p>结果如下:<br><img src="/../../images/MIT6.5840/lab3B/lab3-2-test.png" alt="Alt text"></p></li></ol><p>该代码经过150次测试没有报错</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;最新的更新在博客 &lt;a href=&quot;https://tonixwd.github.io/&quot;&gt;ToniBlog&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;本文将介绍&lt;code&gt;lab3B&lt;/code&gt;部分的实现, &lt;code&gt;lab3B&lt;/code&gt;要求基于在&lt;code&gt;lab</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="Lab笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/Lab%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Go" scheme="http://example.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>红黑树1: 插入、删除原理详解与代码实现</title>
    <link href="http://example.com/2024/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://example.com/2024/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2024-02-02T02:01:07.000Z</published>
    <updated>2024-02-27T06:02:43.813Z</updated>
    
    <content type="html"><![CDATA[<p>本文将从原理介绍红黑树的实现思路，尽量做到图文并茂</p><p>具体的<code>cpp</code>代码实现在<a href="https://github.com/ToniXWD/cppDataStructure/blob/main/include/rbTree.hpp">这里</a>, 就不在文章里代码了, 自己写的实在太丑</p><h1 id="0-引入-为什么需要红黑树"><a href="#0-引入-为什么需要红黑树" class="headerlink" title="0 引入: 为什么需要红黑树?"></a>0 引入: 为什么需要红黑树?</h1><p>通常, 基本的数据结构课程和<code>Leetcode</code>中主要关注的是普通二叉树或者完全二叉树。我们知道其各自存在一些优缺点:</p><ul><li>普通二叉树<code>BST</code><ul><li>优点: 实现简单</li><li>缺点: 如果插入的节点恰好是有序的，那么<code>BST</code>将会退化成一个链表，导致搜索、插入和删除的操作的时间复杂度都下降到<code>O(n)</code></li></ul></li><li>均衡二叉树<code>AVL</code><ul><li>优点: 查询时时间复杂度一定是<code>O(log n)</code>, 不能存在退化成一个链表的情况</li><li>缺点: 维护均衡二叉树消耗很大</li></ul></li></ul><p>为了解决普通<code>BST</code>在最坏情况下性能下降的问题，需要一种能够保持树平衡的数据结构，红黑树就是这样一种结构。红黑树通过节点着色和在插入或删除后进行特定的旋转操作，来保证树基本平衡。这种自平衡机制保证了在最坏情况下，树的高度保持在<code>O(log n)</code>，使得搜索、插入和删除操作的时间复杂度也都是<code>O(log n)</code>。</p><p>红黑树的自平衡特性使得它在实现许多数据结构（如关联数组、映射和集合）时非常有用，这些数据结构在<code>STL</code>（标准模板库）中被广泛使用。它为那些需要高效搜索、插入和删除操作的场景提供了一种可靠的解决方案，无论数据是如何插入的。</p><h1 id="1-红黑树的性质"><a href="#1-红黑树的性质" class="headerlink" title="1 红黑树的性质"></a>1 红黑树的性质</h1><p>红黑树是一种自平衡的二叉搜索树，它保持树的平衡通过确保任何从根到叶子的最长路径不会超过最短路径的两倍。为了实现这一点，红黑树维护以下性质：</p><ol><li><p><strong>节点颜色</strong>：每个节点要么是红色，要么是黑色。</p></li><li><p><strong>根节点性质</strong>：根节点总是黑色。</p></li><li><p><strong>叶子节点性质</strong>：所有叶子节点（NIL节点，通常表示为哨兵节点）都是黑色。</p></li><li><p><strong>红色节点性质</strong>：如果一个节点是红色的，那么它的两个子节点都是黑色的（也就是说，红色节点不能有红色的父节点或子节点，即不会有两个连续的红色节点）。</p></li><li><p><strong>黑色高度性质</strong>：从任何给定节点到其任何叶子节点的路径中，经过的黑色节点的数量是相同的（这个数量称为该节点的黑色高度）。</p></li></ol><p>这些性质确保了红黑树的关键优势：在最坏的情况下，树的高度保持在<code>O(log N)</code>，其中N是树中节点的数量。这意味着查找、插入和删除操作都可以在对数时间内完成，保持了高效性。红黑树通过旋转和重新着色来维持这些性质。当执行插入和删除等修改操作时，通过一系列的树旋转和重新着色来修复可能被破坏的红黑树性质，从而保持树结构的平衡。</p><h1 id="2-红黑树的查找"><a href="#2-红黑树的查找" class="headerlink" title="2 红黑树的查找"></a>2 红黑树的查找</h1><p>红黑树的查找和<code>BST</code>没有区别, 直接略过吧…</p><h1 id="3-红黑树的插入"><a href="#3-红黑树的插入" class="headerlink" title="3 红黑树的插入"></a>3 红黑树的插入</h1><h2 id="3-1-插入原理"><a href="#3-1-插入原理" class="headerlink" title="3.1 插入原理"></a>3.1 插入原理</h2><blockquote><p>草图说明:</p><ol><li>圆圈表示节点, 矩形表示子树</li><li>黑色和红色代表红黑树的颜色, 蓝色表示颜色未知</li><li>阴影表示操作节点</li><li>子树的颜色表示了子树的根节点的颜色</li><li>删除的时候, 初始操作节点的颜色是不确定的</li></ol></blockquote><p>插入过程:</p><ol><li><p><strong>插入新节点</strong>：</p><ul><li>将新节点插入到红黑树中，就像在普通的二叉搜索树中那样。新节点的颜色初始化为<strong>红色</strong>。</li></ul></li><li><p><strong>检查红黑树性质</strong>：</p><ol><li>如果新插入的节点是根节点，仅将其颜色改为黑色即可满足所有性质。</li><li>如果新节点的父节点是黑色，不违反红黑树的性质，不需要做任何额外的操作。</li><li>如果新节点的父节点是红色，就需要进行一些调整来修复树的性质，因为这违反了性质: 红色节点的子节点必须是黑色。</li></ol></li><li><p><strong>调整红黑树</strong>：<br> 如果新节点的父节点是红色的，有以下几种情况需要处理：</p><ol><li><p>叔叔节点为红色</p><ol><li>更改叔叔节点和父节点为黑色</li><li>将爷爷节点设为红色</li><li>以爷爷节点为目标继续判断是否需要调整<br>上述操作可参考下图, 将叔叔和父亲设为黑色是避免连续的红色节点, 将爷爷节点设为红色目的是确保<strong>黑色高度</strong>不变, 因为爷爷的父亲可能还是红色, 所以需要继续判断:<br><img src="/../../images/data_structures/rbTree_insert_uncle_red.png" alt="rbTree_insert_uncle_red"></li></ol></li><li><p>叔叔节点为黑色或者不存在</p><ol><li>如果新节点相对父节点的方向和父节点相对爷爷节点的<strong>方向不一致</strong>, 将操作的目标节点变为其父亲, 并进行左旋或右旋, 使者三代节点<strong>方向一致</strong>,</li><li>将操作节点(可能因为上一步的左旋或右旋, 操作节点发生了变化)的父节点设为黑色, 爷爷节点设为红色</li><li>右旋或左旋爷爷节点(父节点是爷爷节点的右孩子就左旋, 反之右旋), 修复完成, 不需要进一步判断<br>上述操作可参考下图, 目的其实就是化3层为2层, 从而避免原来2-3层连续的红节点, 需要注意的是, 如果是第一次检查修复, 叔叔节点一定是不存在的, 叔叔节点存在且为黑色只会出现在<code>叔叔节点为红色</code>这个条件下的递归修复过程中<br><img src="/../../images/data_structures/rbTree_insert_uncle_black.png" alt="rbTree_insert_uncle_black"></li></ol></li></ol><p> 递归向上进行修复，直到根节点，或满足红黑树性质, 注意,<strong>最后需要将根节点重置为黑色, 因为之前的调整可能改变了根节点的颜色</strong></p></li></ol><p><strong>名词解释：</strong></p><ul><li><strong>左旋</strong>：将父节点的右孩子设为新的父节点, 原来的父节点变为新的父节点的左孩子</li><li><strong>右旋</strong>：与左旋相反，将父节点的左孩子设为新的父节点, 原来的父节点变为新的父节点的右孩子</li><li><strong>方向不一致</strong>: 新节点是父节点的右孩子而父节点是祖父节点的左孩子，或者新节点是父节点的左孩子而父节点是祖父节点的右孩子</li></ul><h2 id="3-2-插入案例"><a href="#3-2-插入案例" class="headerlink" title="3.2 插入案例"></a>3.2 插入案例</h2><p>上面的流程看起来很抽象, 因此我们结合实际的案例来说明, 我使用了<a href="../../images/data_structures/https://algo.hufeifei.cn/RedBlack.html">这个网站</a>演示红黑树插入的逻辑:<br><strong>1. 首先创建一个空的红黑树:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RedBlackTree&lt;<span class="type">int</span>&gt; tree; <span class="comment">// 伪代码</span></span><br></pre></td></tr></table></figure><p><strong>2. 再插入10</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree.<span class="built_in">insert</span>(<span class="number">10</span>); <span class="comment">// 伪代码</span></span><br></pre></td></tr></table></figure><p><img src="/../../images/data_structures/insert_10.png" alt="insert_10"><br>新的节点是根节点, 置为黑色</p><p><strong>3. 再插入5</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree.<span class="built_in">insert</span>(<span class="number">10</span>); <span class="comment">// 伪代码</span></span><br></pre></td></tr></table></figure><p><img src="/../../images/data_structures/insert_5.png" alt="insert_5"><br>插入后没有改变红黑树性质, 无需调整</p><p><strong>4. 再插入50</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree.<span class="built_in">insert</span>(<span class="number">50</span>); <span class="comment">// 伪代码</span></span><br></pre></td></tr></table></figure><p><img src="/../../images/data_structures/insert_50.png" alt="insert_50"><br>插入后没有改变红黑树性质, 无需调整</p><p><strong>5. 再插入30</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree.<span class="built_in">insert</span>(<span class="number">30</span>); <span class="comment">// 伪代码</span></span><br></pre></td></tr></table></figure><p><img src="/../../images/data_structures/insert_30_1.png" alt="insert_30_1"><br>插入后30的父节点50是连续的红节点, 需要调整</p><p><img src="/../../images/data_structures/insert_30_2.png" alt="insert_30_2"><br>叔叔节是红色, 将叔叔和父亲置为黑色, 爷爷节点设为红色</p><p><img src="/../../images/data_structures/insert_30_3.png" alt="insert_30_3"><br>从爷爷节点继续判断, 爷爷节点是根节点, 重新置为黑色</p><blockquote><p>小结: 为什么<code>父亲和叔叔节点都是红色</code>下的这种策略能有效地修复红黑树?<br>因为将父亲和叔叔变黑就已经修复了<strong>红色节点性质</strong>, 但增加了黑色节点高度怎么办呢? 再把爷爷节点变红就修复了<strong>黑色高度性质</strong>, 但需要从爷爷节点还是继续判断是否需要修复</p></blockquote><p><strong>6. 再插入36</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree.<span class="built_in">insert</span>(<span class="number">36</span>); <span class="comment">// 伪代码</span></span><br></pre></td></tr></table></figure><p><img src="/../../images/data_structures/insert_30_6.png" alt="insert_30_6"><br>插入后36的父节点30是连续的红节点, 需要调整</p><p><img src="/../../images/data_structures/insert_30_6_2.png" alt="insert_30_6_2"><br>50, 30和36方向不一致, 左旋父节点30使其方向和50与36的方向一致: 向左, 左旋后, 将30置为操作节点</p><p><img src="/../../images/data_structures/insert_30_6_3.png" alt="insert_30_6_3"><br>将操作节点30的父节点36设为黑色, 爷爷几点50设为红色, 右旋爷爷节点50</p><blockquote><p>小结: </p><ol><li>为什么<code>叔叔节点为黑色或者不存在</code>这个情况下旋转爷爷节点有效?<br>实际上就是将原来以爷爷节点为起点的3个分布在3层的节点压缩层了2层, 原来第二层和第三层连续的2个红色节点调整后就不连续了, 因为其中一个更大的一个节点变到了原来的爷爷节点的位置并变黑了, 原来的爷爷节点变成了儿子并且变成了红色, 所以满足了<strong>黑色高度性质</strong>的性质和<strong>红色节点性质</strong></li><li>为什么需要判断<strong>方向一致</strong>?<br>方便后续统一操作而已</li></ol></blockquote><p><strong>7. 再插入4</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree.<span class="built_in">insert</span>(<span class="number">4</span>); <span class="comment">// 伪代码</span></span><br></pre></td></tr></table></figure><p><img src="/../../images/data_structures/insert_4.png" alt="insert_4"><br>插入后4后不需要调整(主要是为了后续删除的演示)</p><h1 id="4-红黑树的删除"><a href="#4-红黑树的删除" class="headerlink" title="4 红黑树的删除"></a>4 红黑树的删除</h1><p>红黑树的删除比插入复杂很多, 整体分3步:</p><ol><li>找到删除节点</li><li>找到一个替换节点接替删除节点的位置</li><li>修复红黑树高度</li></ol><p>这里分删除和修复2部分说明</p><h2 id="4-1-修复前的替换"><a href="#4-1-修复前的替换" class="headerlink" title="4.1 修复前的替换"></a>4.1 修复前的替换</h2><p><strong>1. 查找要删除的节点</strong><br>就像在普通的二叉搜索树中那样, 查找要删除的节点。</p><p><strong>2. 替换节点</strong><br>红黑树需要用于一个节点来替换要删除的节点, 具体分情况如下:</p><ol><li><p><strong>删除节点有两个非空子节点</strong><br>   在这种情况下，通常会找到该节点的后继或前驱（中序遍历下的下一个节点或上一个节点），这将是该节点右子树中的最小值(或左子树的最大值)。然后，将后继或前驱的值复制到要删除的节点中，并删除后继或前驱节点。因为后继节点(或前驱节点)至多只有一个非空子节点，所以这步骤将问题简化为删除有一个或没有子节点的节点。<strong>本文采取使用前驱替代的策略</strong></p></li><li><p><strong>删除节点最多有一个非空子节点：</strong><br>   任意找到一个空子节点, 然后将另一个子节点(可能也是空的, 也可能是非空), 替代当前节点,</p></li></ol><p>删除红色节点不需要判断修复, 但删除黑色节点后, 需要从一个节点开始判断红黑树是否需要修复, 具体有以下情况:</p><ol><li><strong>删除节点有两个非空子节点</strong><br>由于前驱节点是实际被删除的黑色节点, 因此从它开始就违反了<strong>黑色高度性质</strong>, 具体分类如下:<ol><li>如果前驱节点有孩子, 孩子将替代前驱节点原来的位置, 这个位置就是修复判断的起始位置</li><li>如果前驱节点没有孩子, 那么也就是替代者是空指针, 虽然这个节点也是判断的其实位置, 但从这个节点开始不能进行修复判断, 因为空指针无法索引到它的父节点, 因此, 额外用一个<strong>哨兵节点Nil</strong>来代替这个空指针, 哨兵节点除了包含原来前驱的父节点指针外, 本身不算是红黑树的有效成员, 只是在删除修复时临时使用, <strong>哨兵节点Nil</strong>就是修复判断的起始位置</li></ol></li><li><strong>删除节点最多有一个非空子节点：</strong><br>任意找到一个空子节点, 然后将另一个子节点(可能也是空的, 也可能是非空), 替代当前节点, 当前节点被替代的位置就是判断的其实位置, 当然这个位置现在也可能是空的, 所以这种情况也需要使用<strong>哨兵节点Nil</strong>来处理</li></ol><p><strong>替换完成后, 还需要将替换的节点的颜色置为原来删除位置节点的颜色</strong></p><h2 id="4-2-修复红黑树"><a href="#4-2-修复红黑树" class="headerlink" title="4.2 修复红黑树"></a>4.2 修复红黑树</h2><p>删除节点后，可能会违反红黑树的性质。如果删除的是红色节点，通常不需要进一步的修复，因为红色节点的删除不会影响黑色节点的平衡。但如果删除的是黑色节点，就可能需要通过一系列复杂的树的旋转和重新着色来进行修复。</p><p>修复过程是从某个节点开始进行判断的, 这个判断的节点的含义是: 这个节点开始的子树的<strong>黑色高度</strong>比删除前减小了1</p><p>修复的目标是重新分配树中的黑色高度, 修复过程遵循以下原则：</p><ol><li><strong>兄弟节点是红色：</strong> <ol><li>兄弟节点是红色意味着父节点一定是黑色, 先交换父节点和兄弟节点的颜色。</li><li>将父节点进行旋转, 方向朝着修复判断的操作节点</li><li>旋转后操作节点的新兄弟节点就是黑色了, 可以继续下面的判断修复<br>这一过程可参考下图, 需要注意的是, 这个过程仅仅是将兄弟节点变黑, 并没有完成修复, 需要后续进一步操作<br><img src="/../../images/data_structures/rbTree_delete_change_sibling_to_black.png" alt="rbTree_delete_change_sibling_to_black"></li></ol></li><li><strong>兄弟节点是黑色，其子节点也都是黑色：</strong> <ol><li><p>将兄弟节点设为红色, 此时兄弟节点开始的子树和操作节点开始的子树的<strong>黑色高度</strong>已经一样了</p></li><li><p>由于上述原因, 可以将操作节点向上移动到父节点, 继续判断修复:</p><ol><li>如果父节点是红色, 将其置为黑色, 修复完成</li><li>否则, 从父节点开始继续判断</li></ol><p>这一过程可参考下图, 此时操作节点变成了原来的父节点, 继续判断:</p></li></ol><p><img src="/../../images/data_structures/rbTree_delete.set_sibling_red.png" alt="rbTree_delete.set_sibling_red"></p></li><li><strong>兄弟节点是黑色，且至少有一个红色子节点：</strong> <ol><li><p>无论兄弟节点的红色节点是哪一侧, 都可以通过旋转操作统一到某一侧一定有红色节点, 这里将红色节点位置统一为操作节点的相反侧(如果操作节点是左节点, 就把兄弟节点的红色节点放在右孩子), 如果需要调整兄弟节点的子节点的位置的话</p><ol><li>将兄弟节点和兄弟节点的红色孩子交换颜色</li><li>将兄弟节点向与操作节点向反的方向旋转<br>这一过程可参考下图<br><img src="/../../images/data_structures/./rbTree_delete_change_red.png" alt="delete_change_red"></li></ol></li><li><p>将兄弟节点(可能因旋转发生了变化)设置为操作节点的父节点的颜色，将操作节点的父节点设置为黑色，将兄弟节点的与操作节点相反方向的孩子(之前的操作确保其为红)设置为黑色<br>这一过程可参考下图<br><img src="/../../images/data_structures/rbTree_delete_exchange_parent_sibling_blacking_red_child_of_sibling.png" alt="rbTree_delete_exchange_parent_sibling_blacking_red_child_of_sibling"></p></li><li><p>将操作节点的父节点向操作节点方向旋转<br>这一过程可参考下图, 此时操作节点的路径上多了一个黑色节点, 其<strong>黑色高度</strong>被修复, 而操作节点的兄弟节点由于红色节点被置为黑色, 补充了被转移到原来操作节点一侧的黑节点, 因此高度也不变化, 此时, 完成了修复, 可以退出循环<br><img src="/../../images/data_structures/rbTree_delete_rotate_after_exchange_parent_sibling_blacking_red_child_of_sibling.png" alt="rbTree_delete_rotate_after_exchange_parent_sibling_blacking_red_child_of_sibling"></p></li></ol></li></ol><p>删除修复可能会在树上向上递归，直到到达根节点，或者遇到可以修复树平衡的情况。</p><p>同时, 修复完成后还需要重新将<strong>哨兵节点</strong>卸载掉</p><blockquote><p>有一个很重要的特性值得观察: 就是初始状态的修复判断的操作节点的颜色是未知的, 但通过以上的修复逻辑, 最终效果一定会将初始的操作节点安排一个黑色父节点从而避免连续的红色节点</p></blockquote><h2 id="4-3-删除案例"><a href="#4-3-删除案例" class="headerlink" title="4.3 删除案例"></a>4.3 删除案例</h2><p>使用我们之前插入案例最后状态的红黑树:<br><img src="/../../images/data_structures/insert_4.png" alt="insert_4"><br><strong>1. 删除36</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree.<span class="built_in">remove</span>(<span class="number">36</span>); <span class="comment">// 伪代码</span></span><br></pre></td></tr></table></figure><p><img src="/../../images/data_structures/remove_36.png" alt="remove_36"><br>删除的36左右孩子都不为空, 所以找到其前驱30, 用30替代36, 并且替代的节点需要设置成和原来位置节点相同的颜色</p><p>替换的30节点是红色, 无需修复 </p><p><strong>2. 删除30</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree.<span class="built_in">remove</span>(<span class="number">30</span>); <span class="comment">// 伪代码</span></span><br></pre></td></tr></table></figure><p><img src="/../../images/data_structures/remove_30_1.png" alt="remove_30_1"></p><p>删除的30节点用50节点来代替, 并将50节点设置为黑色<br>替换的50节点是红色, 不需要修复</p><p><strong>3. 删除10</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree.<span class="built_in">remove</span>(<span class="number">10</span>); <span class="comment">// 伪代码</span></span><br></pre></td></tr></table></figure><p><img src="/../../images/data_structures/remove_10_1.png" alt="remove_10_1"><br>删除的10的左右孩子不为空, 用前驱5替代10, 并将10节点设置为黑色<br>替换的5节点是黑色, 需要修复</p><p><img src="/../../images/data_structures/remove_10_2.png" alt="remove_10_2"><br>兄弟节点是黑色, 且孩子都是黑色(空节点也是黑色), 所以将兄弟节点染红, 操作节点置为其父节点</p><blockquote><p>在线可视化的网页是将其4染成黑色, 都可以, 我按照我总结的思路将50染红, 所以P了下图</p></blockquote><p>操作节点此时是根节点, 再次置为黑色, 结束修复</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将从原理介绍红黑树的实现思路，尽量做到图文并茂&lt;/p&gt;
&lt;p&gt;具体的&lt;code&gt;cpp&lt;/code&gt;代码实现在&lt;a href=&quot;https://github.com/ToniXWD/cppDataStructure/blob/main/include/rbTree.hp</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="红黑树" scheme="http://example.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.5840(6.824) Lab3: 分布式KV数据库 3A</title>
    <link href="http://example.com/2024/01/30/MIT6.5840/Lab3A/"/>
    <id>http://example.com/2024/01/30/MIT6.5840/Lab3A/</id>
    <published>2024-01-30T12:21:22.000Z</published>
    <updated>2024-02-27T06:02:43.811Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍<code>lab3A</code>部分的实现, <code>lab3A</code>要求基于<code>raft</code>实现一个容错的分布式<code>KV</code>数据库, 但不要求实现快照, 难度还是不小</p><p><code>Lab</code>文档见: <a href="http://nil.csail.mit.edu/6.5840/2023/labs/lab-kvraft.html">http://nil.csail.mit.edu/6.5840/2023/labs/lab-kvraft.html</a></p><p>我的代码: <a href="https://github.com/ToniXWD/MIT6.5840/tree/lab3A">https://github.com/ToniXWD/MIT6.5840/tree/lab3A</a></p><h1 id="1-lab2-Raft-bug-修复"><a href="#1-lab2-Raft-bug-修复" class="headerlink" title="1 lab2:Raft bug 修复"></a>1 <code>lab2:Raft bug </code>修复</h1><p>首先又是万恶的老旧代码<code>bug</code>修复</p><h2 id="1-1-心跳发送逻辑修复"><a href="#1-1-心跳发送逻辑修复" class="headerlink" title="1.1 心跳发送逻辑修复"></a>1.1 心跳发送逻辑修复</h2><h3 id="1-1-1-bug描述"><a href="#1-1-1-bug描述" class="headerlink" title="1.1.1 bug描述"></a>1.1.1 <code>bug</code>描述</h3><p>在<code>lab3A</code>中, <code>kv</code>数据库的命令要求命令能够尽快被<code>commit</code>, 且要求比一个心跳间隔更快, 但我在<code>lab2</code>的实现中, 无论是否调用了<code>Start</code>, 都不影响心跳的发送频率, 因此自然<code>commit</code>速度很慢, 过不了测试。因此需要修改<code>lab2</code>中<code>Start</code>, 使其立即唤醒一次心跳</p><h3 id="1-1-2-修改方案"><a href="#1-1-2-修改方案" class="headerlink" title="1.1.2 修改方案"></a>1.1.2 修改方案</h3><p>由于需要在发送心跳的携程函数<code>SendHeartBeats</code>外控制心跳发送, 因此可以简单地修改<code>SendHeartBeats</code>通过事件触发心跳发送, 而不是发送后简单地<code>Sleep</code>,</p><ol><li>首先设置一个心跳定时器<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    heartTimer *time.Timer</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>SendHeartBeats</code>通过事件触发心跳发送<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> SendHeartBeats() &#123;</span><br><span class="line"><span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">&lt;-rf.heartTimer.C</span><br><span class="line">...</span><br><span class="line">rf.ResetHeartTimer(HeartBeatTimeOut)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> ResetHeartTimer(timeStamp <span class="type">int</span>) &#123;</span><br><span class="line">rf.heartTimer.Reset(time.Duration(timeStamp) * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>Start</code>函数理解触发心跳<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Start(command <span class="keyword">interface</span>&#123;&#125;) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.ResetHeartTimer(<span class="number">1</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rf.VirtualLogIdx(<span class="built_in">len</span>(rf.log) - <span class="number">1</span>), rf.currentTerm, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>其余重设定时器的地方就不在赘述了</li></ol><h2 id="1-2-投票逻辑修复"><a href="#1-2-投票逻辑修复" class="headerlink" title="1.2 投票逻辑修复"></a>1.2 投票逻辑修复</h2><h3 id="1-2-1-bug描述"><a href="#1-2-1-bug描述" class="headerlink" title="1.2.1 bug描述"></a>1.2.1 <code>bug</code>描述</h3><p>简单说就是某节点2轮选举撞在了一起, 首先先回顾选举相关的结构体成员:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">muVote    sync.Mutex <span class="comment">// 保护投票数据</span></span><br><span class="line">voteCount <span class="type">int</span>        <span class="comment">// 票数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>bug</code>原来本来是没有的, 因为之前<code>Start</code>并不会立即发送心跳，所以不容易出现如<code>RPC</code>重复, <code>RPC</code>乱序等问题, 但修改了<code>Start</code>后, 并发场景更复杂, 因此出现了如下的场景:</p><ol><li>某一时刻<code>Follower 2</code>进行选举</li><li><code>Follower 2</code>选举还没结束时, 又收到了新的<code>Leader</code>的心跳, 证明选举结束了, 但由于选举的某个携程的<code>RPC</code>响应很慢, 其还没有进行选举是否结束(自身变为了<code>Follower</code>)的判断</li><li>选举超时又被触发, <code>Follower 2</code>进行新一轮选举, 由于票数是以结构体成员<code>voteCount</code>保存的, 因此<code>voteCount</code>可能与之前的选票发生冲突</li></ol><h3 id="1-2-2-修改方案"><a href="#1-2-2-修改方案" class="headerlink" title="1.2.2 修改方案"></a>1.2.2 修改方案</h3><p>既然结构体成员会发生冲突, 那不如为每轮选票临时创建一个成员和投票锁:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Elect() &#123;</span><br><span class="line"><span class="comment">// 特别注意, 要先对muVote加锁, 再对mu加锁, 这是为了统一获取锁的顺序以避免死锁</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">voteCount := <span class="number">1</span>      <span class="comment">// 自己有一票</span></span><br><span class="line"><span class="keyword">var</span> muVote sync.Mutex <span class="comment">// 临时的投票锁</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == rf.me &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> rf.collectVote(i, args, &amp;muVote, &amp;voteCount)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>collectVote</code>函数就不展示了, 将原来的结构体成员<code>muVote</code>和<code>voteCount</code>换为临时创建的变量即可</p><h1 id="2-KV数据库架构"><a href="#2-KV数据库架构" class="headerlink" title="2 KV数据库架构"></a>2 KV数据库架构</h1><p>首先先贴出官方提供的架构图:</p><p><img src="/../../images/raft_diagram.png" alt="raftkv-structure1"></p><p>简单说, 我们要建立的<code>KV</code>数据库是位于<code>raft</code>层之上的, 或者说我们的<code>KV</code>数据库使用了<code>raft</code>库。客户端（就是代码中的<code>clerk</code>）调用应用层(<code>server</code>)的<code>RPC</code>，应用层收到<code>RPC</code>之后，会调用<code>Start</code>函数，<code>Start</code>函数会立即返回，但是这时，应用层不会返回消息给客户端，因为它还没有执行客户端请求，它也不知道这个请求是否会被<code>Raft</code>层<code>commit</code>。只有在某一时刻，对应于这个客户端请求的消息在<code>applyCh channel</code>中出现, 应用层才会执行这个请求，并返回响应给客户端。</p><p>对于上述过程, 可参考我在课堂笔记中画的图:</p><p><img src="/../../images/Lec06-raft-kv.png" alt="raftkv-structure2"></p><h1 id="3-设计思路"><a href="#3-设计思路" class="headerlink" title="3 设计思路"></a>3 设计思路</h1><h2 id="3-1-为什么会线性不一致"><a href="#3-1-为什么会线性不一致" class="headerlink" title="3.1 为什么会线性不一致?"></a>3.1 为什么会线性不一致?</h2><p><code>clerk</code>和真正的客户端交互并管理<code>RPC</code>, 而<code>server</code>收到请求后需要将请求传递给<code>raft</code>层进行集群复制, 然后收到<code>raft</code>的<code>commit</code>, 在应用到状态机并返回给客户端。</p><p>但问题在于需要确保以上操作的线性一致性， 那什么时候会出现线形不一致的情况呢？就是重复的请求。因为网络问题，<code>clerk</code>可能认为之前的请求丢包了， 所以会再次发送请求。而<code>raft</code>层是无法判断这个请求是否重复的, 如果<code>server</code>层没有特殊处理, 有的请可能在客户端看来只执行了一次, 但在<code>server</code>执行了多次, 并且如果这是<code>Put</code>等改变状态机的请求, 执行了多次将导致逻辑错误。</p><h2 id="3-2-实现线性一致性的思路"><a href="#3-2-实现线性一致性的思路" class="headerlink" title="3.2 实现线性一致性的思路"></a>3.2 实现线性一致性的思路</h2><h3 id="3-2-1-如何判断重复请求？"><a href="#3-2-1-如何判断重复请求？" class="headerlink" title="3.2.1 如何判断重复请求？"></a>3.2.1 如何判断重复请求？</h3><p>首先，<code>server</code>需要判断某一个请求是否重复，最简单的方法就是让<code>clerk</code>携带一个全局递增的序列号，并且<code>server</code>需要在第一次将这个请求应用到状态机时记录这个序列号, 用以判断后续的请求是否重复。由于<code>clerk</code>不是并发的, 所以<code>server</code>只需要记录某个<code>clerk</code>序列号最高的一个请求即可, 序列号更低的请求不会出现, 只需要考虑请求重复的场景。</p><h3 id="3-2-2-如何处理重复请求？"><a href="#3-2-2-如何处理重复请求？" class="headerlink" title="3.2.2 如何处理重复请求？"></a>3.2.2 如何处理重复请求？</h3><p>除了记录某个<code>clerk</code>请求的序列号外， 还需要记录器执行结果，因为如果是一个重复的<code>Get</code>请求, 其返回的结果应该与其第一次发送请求时一致, 否则将导致线性不一致。如果是重复的<code>Put</code>等改变状态机的请求，就不应该被执行</p><p><strong>总结下来, 思路就是:</strong></p><ol><li>重复的<code>Put/Append</code>请求只在第一次出现时应用到状态机</li><li>记录每次应用到状态机的请求结果和序列号</li></ol><h1 id="4-具体实现"><a href="#4-具体实现" class="headerlink" title="4 具体实现"></a>4 具体实现</h1><h2 id="4-1-client实现"><a href="#4-1-client实现" class="headerlink" title="4.1 client实现"></a>4.1 <code>client</code>实现</h2><h3 id="4-1-1-结构体设计"><a href="#4-1-1-结构体设计" class="headerlink" title="4.1.1 结构体设计"></a>4.1.1 结构体设计</h3><p>先贴代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Clerk <span class="keyword">struct</span> &#123;</span><br><span class="line">servers    []*labrpc.ClientEnd</span><br><span class="line">seq        <span class="type">uint64</span></span><br><span class="line">identifier <span class="type">int64</span></span><br><span class="line">leaderId   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>identifier</code>用于标识<code>clerk</code>, <code>seq</code>是单调递增的序列号, 标记请求, <code>identifier</code>和<code>seq</code>一起标记了唯一的请求, <code>leaderId</code>记录领导者</p><h3 id="4-1-2-client-RPC设计"><a href="#4-1-2-client-RPC设计" class="headerlink" title="4.1.2 client RPC设计"></a>4.1.2 <code>client RPC</code>设计</h3><h4 id="4-1-2-1-RPC结构体设计"><a href="#4-1-2-1-RPC结构体设计" class="headerlink" title="4.1.2.1 RPC结构体设计"></a>4.1.2.1 <code>RPC</code>结构体设计</h4><p><code>RPC</code>请求只需要额外携带<code>identifier</code>和<code>seq</code>, <code>RPC</code>回复则需要携带结果和错误信息:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PutAppendArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Key        <span class="type">string</span></span><br><span class="line">Value      <span class="type">string</span></span><br><span class="line">Op         <span class="type">string</span> <span class="comment">// &quot;Put&quot; or &quot;Append&quot;</span></span><br><span class="line">Seq        <span class="type">uint64</span></span><br><span class="line">Identifier <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PutAppendReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Err Err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Key        <span class="type">string</span></span><br><span class="line">Seq        <span class="type">uint64</span></span><br><span class="line">Identifier <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Err   Err</span><br><span class="line">Value <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-2-Put-Append"><a href="#4-1-2-2-Put-Append" class="headerlink" title="4.1.2.2 Put/Append"></a>4.1.2.2 <code>Put/Append</code></h4><p>这2个函数很简单 ,不断轮询<code>server</code>即可, 但是需要注意, 如果对方返回了超时错误和通道关闭错误等意料之外的错误, 需要重试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Get(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">args := &amp;GetArgs&#123;Key: key, Seq: ck.GetSeq(), Identifier: ck.identifier&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">reply := &amp;GetReply&#123;&#125;</span><br><span class="line">ok := ck.servers[ck.leaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, args, reply)</span><br><span class="line"><span class="keyword">if</span> !ok || reply.Err == ErrNotLeader || reply.Err == ErrLeaderOutDated &#123;</span><br><span class="line">ck.leaderId += <span class="number">1</span></span><br><span class="line">ck.leaderId %= <span class="built_in">len</span>(ck.servers)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> reply.Err &#123;</span><br><span class="line"><span class="keyword">case</span> ErrChanClose:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> ErrHandleOpTimeOut:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> ErrKeyNotExist:</span><br><span class="line"><span class="keyword">return</span> reply.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> reply.Value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> PutAppend(key <span class="type">string</span>, value <span class="type">string</span>, op <span class="type">string</span>) &#123;</span><br><span class="line"><span class="comment">// You will have to modify this function.</span></span><br><span class="line">args := &amp;PutAppendArgs&#123;Key: key, Value: value, Op: op, Seq: ck.GetSeq(), Identifier: ck.identifier&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">reply := &amp;PutAppendReply&#123;&#125;</span><br><span class="line">ok := ck.servers[ck.leaderId].Call(<span class="string">&quot;KVServer.PutAppend&quot;</span>, args, reply)</span><br><span class="line"><span class="keyword">if</span> !ok || reply.Err == ErrNotLeader || reply.Err == ErrLeaderOutDated &#123;</span><br><span class="line">ck.leaderId += <span class="number">1</span></span><br><span class="line">ck.leaderId %= <span class="built_in">len</span>(ck.servers)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> reply.Err &#123;</span><br><span class="line"><span class="keyword">case</span> ErrChanClose:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> ErrHandleOpTimeOut:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Put(key <span class="type">string</span>, value <span class="type">string</span>) &#123;</span><br><span class="line">ck.PutAppend(key, value, <span class="string">&quot;Put&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Append(key <span class="type">string</span>, value <span class="type">string</span>) &#123;</span><br><span class="line">ck.PutAppend(key, value, <span class="string">&quot;Append&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重试<code>RPC</code>时, 需要新建<code>reply</code>结构体, 重复使用同一个结构体将导致<code>labgob</code>报错</p></blockquote><h2 id="4-2-Server实现"><a href="#4-2-Server实现" class="headerlink" title="4.2 Server实现"></a>4.2 <code>Server</code>实现</h2><h3 id="4-2-1-Server设计思路"><a href="#4-2-1-Server设计思路" class="headerlink" title="4.2.1 Server设计思路"></a>4.2.1 <code>Server</code>设计思路</h3><p>根据前文分析可知, <code>RPC handler</code>(就是<code>Get/Put handler</code>)只会在<code>raft</code>层的<code>commit</code>信息到达后才能回复, 因此其逻辑顺序就是</p><ol><li>将请求封装后通过接口<code>Start</code>交付给<code>raft</code>层<ol><li>如果<code>raft</code>层节点不是<code>Leader</code>, 返回相应错误</li><li>否则继续</li></ol></li><li>等待<code>commit</code>信息<ol><li>信息到达, 根据<code>commit</code>信息处理回复(具体是什么样的信息回复后面会说)</li><li>超时, 返回相应错误</li></ol></li></ol><p>分析到这里可知, 必然有一个协程在不断地接收<code>raft</code>层的<code>commit</code>日志(此后称为<code>ApplyHandler</code>协程), 那上述提到的重复<code>RPC</code>判别和处理是在<code>ApplyHandler</code>中进行, 还是在<code>RPC handler</code>中进行呢?</p><p>我的处理方式是在<code>ApplyHandler</code>中进行, 因为<code>ApplyHandler</code>是绝对串行的, 在其中处理这些日志是最安全的, 否则通过通道发送给<code>RPC handler</code>货条件变量唤醒<code>RPC handler</code>, 都存在一些并发同步的问题, 因此, <code>ApplyHandler</code>需要进行重复<code>RPC</code>判别和处理(可能需要存储), 并将这个请求(<code>commit log</code>就对应一个请求)的结果返回给<code>RPC handler</code></p><h3 id="4-2-2-结构体设计"><a href="#4-2-2-结构体设计" class="headerlink" title="4.2.2 结构体设计"></a>4.2.2 结构体设计</h3><p>因此, 通过上述分析, <code>server</code>结构体如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KVServer <span class="keyword">struct</span> &#123;</span><br><span class="line">mu         sync.Mutex</span><br><span class="line">me         <span class="type">int</span></span><br><span class="line">rf         *raft.Raft</span><br><span class="line">applyCh    <span class="keyword">chan</span> raft.ApplyMsg</span><br><span class="line">dead       <span class="type">int32</span>                <span class="comment">// set by Kill()</span></span><br><span class="line">waiCh      <span class="keyword">map</span>[<span class="type">int</span>]*<span class="keyword">chan</span> result <span class="comment">// 映射 startIndex-&gt;ch</span></span><br><span class="line">historyMap <span class="keyword">map</span>[<span class="type">int64</span>]*result    <span class="comment">// 映射 Identifier-&gt;*result</span></span><br><span class="line"></span><br><span class="line">maxraftstate <span class="type">int</span> <span class="comment">// snapshot if log grows this big</span></span><br><span class="line">maxMapLen    <span class="type">int</span></span><br><span class="line">db           <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">LastSeq <span class="type">uint64</span></span><br><span class="line">Err     Err</span><br><span class="line">Value   <span class="type">string</span></span><br><span class="line">ResTerm <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><code>historyMap</code>记录某<code>clerk</code>的最高序列号的请求的序列号和结果<code>result</code></li><li><code>result</code>结构体存储一个请求的序列号和结果, 以及<code>ResTerm</code>记录<code>commit</code>被<code>apply</code>时的<code>term</code>, 因为其可能与<code>Start</code>相比发生了变化, 需要将这一信息返回给客户端</li><li><code>waiCh</code>纪录等待<code>commit</code>信息的<code>RPC handler</code>的通道</li></ul><h3 id="4-2-3-RPC-handler设计"><a href="#4-2-3-RPC-handler设计" class="headerlink" title="4.2.3 RPC handler设计"></a>4.2.3 <code>RPC handler</code>设计</h3><p><code>RPC handler</code>设计较为简单,只需要调用<code>Start</code>, 等待<code>commit</code>信息即可, 不过还需要考虑超时的错误处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> Get(args *GetArgs, reply *GetReply) &#123;</span><br><span class="line"><span class="comment">// 先判断是不是leader</span></span><br><span class="line">_, isLeader := kv.rf.GetState()</span><br><span class="line"><span class="keyword">if</span> !isLeader &#123;</span><br><span class="line">reply.Err = ErrNotLeader</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">opArgs := &amp;Op&#123;OpType: OPGet, Seq: args.Seq, Key: args.Key, Identifier: args.Identifier&#125;</span><br><span class="line"></span><br><span class="line">res := kv.HandleOp(opArgs)</span><br><span class="line">reply.Err = res.Err</span><br><span class="line">reply.Value = res.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> PutAppend(args *PutAppendArgs, reply *PutAppendReply) &#123;</span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line"><span class="comment">// 先判断是不是leader</span></span><br><span class="line">_, isLeader := kv.rf.GetState()</span><br><span class="line"><span class="keyword">if</span> !isLeader &#123;</span><br><span class="line">reply.Err = ErrNotLeader</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">opArgs := &amp;Op&#123;Seq: args.Seq, Key: args.Key, Val: args.Value, Identifier: args.Identifier&#125;</span><br><span class="line"><span class="keyword">if</span> args.Op == <span class="string">&quot;Put&quot;</span> &#123;</span><br><span class="line">opArgs.OpType = OPPut</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">opArgs.OpType = OPAppend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res := kv.HandleOp(opArgs)</span><br><span class="line">reply.Err = res.Err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Get</code>和<code>PutAppend</code>都将请求封装成<code>Op</code>结构体, 统一给<code>HandleOp</code>处理, <code>HandleOp</code>处理<code>ApplyHandler</code>发过来的<code>commit</code>信息并生成回复, 这里我采用的通信方式是管道, 每一个请求会将自己创建的管道存储在<code>waiCh</code>中, 并在函数离开时清理管道和<code>waiCh</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> HandleOp(opArgs *Op) (res result) &#123;</span><br><span class="line">startIndex, startTerm, isLeader := kv.rf.Start(*opArgs)</span><br><span class="line"><span class="keyword">if</span> !isLeader &#123;</span><br><span class="line"><span class="keyword">return</span> result&#123;Err: ErrNotLeader, Value: <span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kv.mu.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接覆盖之前记录的chan</span></span><br><span class="line">newCh := <span class="built_in">make</span>(<span class="keyword">chan</span> result)</span><br><span class="line">kv.waiCh[startIndex] = &amp;newCh</span><br><span class="line">DPrintf(<span class="string">&quot;leader %v identifier %v Seq %v 的请求: 新建管道: %p\n&quot;</span>, kv.me, opArgs.Identifier, opArgs.Seq, &amp;newCh)</span><br><span class="line">kv.mu.Unlock() <span class="comment">// Start函数耗时较长, 先解锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">kv.mu.Lock()</span><br><span class="line"><span class="built_in">delete</span>(kv.waiCh, startIndex)</span><br><span class="line"><span class="built_in">close</span>(newCh)</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待消息到达或超时</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(HandleOpTimeOut):</span><br><span class="line">res.Err = ErrHandleOpTimeOut</span><br><span class="line">DPrintf(<span class="string">&quot;server %v identifier %v Seq %v: 超时&quot;</span>, kv.me, opArgs.Identifier, opArgs.Seq)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> msg, success := &lt;-newCh:</span><br><span class="line"><span class="keyword">if</span> success &amp;&amp; msg.ResTerm == startTerm &#123;</span><br><span class="line">res = msg</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !success &#123;</span><br><span class="line"><span class="comment">// 通道已经关闭, 有另一个协程收到了消息 或 通道被更新的RPC覆盖</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 是否需要判断消息到达时自己已经不是leader了?</span></span><br><span class="line">DPrintf(<span class="string">&quot;server %v identifier %v Seq %v: 通道已经关闭, 有另一个协程收到了消息 或 更新的RPC覆盖, args.OpType=%v, args.Key=%+v&quot;</span>, kv.me, opArgs.Identifier, opArgs.Seq, opArgs.OpType, opArgs.Key)</span><br><span class="line">res.Err = ErrChanClose</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// term与一开始不匹配, 说明这个Leader可能过期了</span></span><br><span class="line">DPrintf(<span class="string">&quot;server %v identifier %v Seq %v: term与一开始不匹配, 说明这个Leader可能过期了, res.ResTerm=%v, startTerm=%+v&quot;</span>, kv.me, opArgs.Identifier, opArgs.Seq, res.ResTerm, startTerm)</span><br><span class="line">res.Err = ErrLeaderOutDated</span><br><span class="line">res.Value = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要额外注意错误处理:</p><ol><li>超时错误</li><li>通道关闭错误</li><li><code>Leader</code>可能过期的错误(<code>term</code>不匹配)</li><li>不是<code>Leader</code>的错误</li></ol><p>同时这里还有一个难点, 就是如果出现了重复的<code>RPC</code>, 他们都在等待<code>commit</code>信息, 那么他们的管道存储在<code>waiCh</code>中的<code>key</code>是什么呢? 如果使用<code>Identifier</code>或<code>Seq</code>, 那么必然后来的<code>RPC</code>会覆盖之前的管道, 可能造成错误, 因为两个重复<code>RPC</code>的<code>Identifier</code>或<code>Seq</code>是一样的。 这里可以巧妙地利用<code>Start</code>函数的第一个返回值， 其代表如果<code>commit</code>成功, 其日志项的索引号, 由于<code>raft</code>层不区分重复<code>RPC</code>的<code>log</code>, 因此这个索引号肯定是不同的, 不会相互覆盖</p><h3 id="4-2-4-ApplyHandler设计"><a href="#4-2-4-ApplyHandler设计" class="headerlink" title="4.2.4 ApplyHandler设计"></a>4.2.4 <code>ApplyHandler</code>设计</h3><p><code>ApplyHandler</code>是<code>3A</code>的最核心的部分, 其思路是:</p><ol><li>先判断<code>log</code>请求的<code>Identifier</code>和<code>Seq</code>是否在历史记录<code>historyMap</code>中是否存在, 如果存在就直接返回历史记录</li><li>不存在就需要应用到状态机, 并更新历史记录<code>historyMap</code></li><li>如果<code>log</code>请求的<code>CommandIndex</code>对应的<code>key</code>在<code>waiCh</code>中存在, 表面当前节点可能是一个<code>Leader</code>, 需要将结果发送给<code>RPC handler</code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> ApplyHandler() &#123;</span><br><span class="line"><span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">log := &lt;-kv.applyCh</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> log.CommandValid &#123;</span><br><span class="line"></span><br><span class="line">op := log.Command.(Op)</span><br><span class="line">kv.mu.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要判断这个log是否需要被再次应用</span></span><br><span class="line"><span class="keyword">var</span> res result</span><br><span class="line"></span><br><span class="line">needApply := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> hisMap, exist := kv.historyMap[op.Identifier]; exist &#123;</span><br><span class="line"><span class="keyword">if</span> hisMap.LastSeq == op.Seq &#123;</span><br><span class="line"><span class="comment">// 历史记录存在且Seq相同, 直接套用历史记录</span></span><br><span class="line">res = *hisMap</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> hisMap.LastSeq &lt; op.Seq &#123;</span><br><span class="line"><span class="comment">// 否则新建</span></span><br><span class="line">needApply = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 历史记录不存在</span></span><br><span class="line">needApply = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, isLeader := kv.rf.GetState()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> needApply &#123;</span><br><span class="line"><span class="comment">// 执行log</span></span><br><span class="line">res = kv.DBExecute(&amp;op, isLeader)</span><br><span class="line">res.ResTerm = log.SnapshotTerm</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新历史记录</span></span><br><span class="line">kv.historyMap[op.Identifier] = &amp;res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !isLeader &#123;</span><br><span class="line"><span class="comment">// 不是leader则继续检查下一个log</span></span><br><span class="line">kv.mu.Unlock()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Leader还需要额外通知handler处理clerk回复</span></span><br><span class="line">ch, exist := kv.waiCh[log.CommandIndex]</span><br><span class="line"><span class="keyword">if</span> !exist &#123;</span><br><span class="line"><span class="comment">// 接收端的通道已经被删除了并且当前节点是 leader, 说明这是重复的请求, 但这种情况不应该出现, 所以panic</span></span><br><span class="line">DPrintf(<span class="string">&quot;leader %v ApplyHandler 发现 identifier %v Seq %v 的管道不存在, 应该是超时被关闭了&quot;</span>, kv.me, op.Identifier, op.Seq)</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 如果这里有 panic，是因为通道关闭</span></span><br><span class="line">DPrintf(<span class="string">&quot;leader %v ApplyHandler 发现 identifier %v Seq %v 的管道不存在, 应该是超时被关闭了&quot;</span>, kv.me, op.Identifier, op.Seq)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">res.ResTerm = log.SnapshotTerm</span><br><span class="line">*ch &lt;- res</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这里有几大易错点:</p><ol><li>需要额外传递<code>Term</code>以供<code>RPC handler</code>判断与调用<code>Start</code>时相比, <code>term</code>是否变化, 如果变化, 可能是<code>Leader</code>过期, 需要告知<code>clerk</code></li><li>发送消息到通道时, 需要解锁</li><li>因为发送消息到通道时解锁, 所以通道可能被关闭, 因此需要单独在一个函数中使用<code>recover</code>处理发送消息到不存在的通道时的错误</li><li>这个<code>ApplyHandler</code>是<code>leader</code>和<code>follower</code>都存在的协程, 只不过<code>follower</code>到应用到状态机和判重那里就结束了, <code>leader</code>多出来告知<code>RPC handler</code>结果的部分</li></ol><p><code>DBExecute</code>就是将日志项应用到状态机, 逻辑很简单:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> DBExecute(op *Op, isLeader <span class="type">bool</span>) (res result) &#123;</span><br><span class="line"><span class="comment">// 调用该函数需要持有锁</span></span><br><span class="line">res.LastSeq = op.Seq</span><br><span class="line"><span class="keyword">switch</span> op.OpType &#123;</span><br><span class="line"><span class="keyword">case</span> OPGet:</span><br><span class="line">val, exist := kv.db[op.Key]</span><br><span class="line"><span class="keyword">if</span> exist &#123;</span><br><span class="line">kv.LogInfoDBExecute(op, <span class="string">&quot;&quot;</span>, val, isLeader)</span><br><span class="line">res.Value = val</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res.Err = ErrKeyNotExist</span><br><span class="line">res.Value = <span class="string">&quot;&quot;</span></span><br><span class="line">kv.LogInfoDBExecute(op, <span class="string">&quot;&quot;</span>, ErrKeyNotExist, isLeader)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> OPPut:</span><br><span class="line">kv.db[op.Key] = op.Val</span><br><span class="line">kv.LogInfoDBExecute(op, <span class="string">&quot;&quot;</span>, kv.db[op.Key], isLeader)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> OPAppend:</span><br><span class="line">val, exist := kv.db[op.Key]</span><br><span class="line"><span class="keyword">if</span> exist &#123;</span><br><span class="line">kv.db[op.Key] = val + op.Val</span><br><span class="line">kv.LogInfoDBExecute(op, <span class="string">&quot;&quot;</span>, kv.db[op.Key], isLeader)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">kv.db[op.Key] = op.Val</span><br><span class="line">kv.LogInfoDBExecute(op, <span class="string">&quot;&quot;</span>, kv.db[op.Key], isLeader)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-测试"><a href="#5-测试" class="headerlink" title="5 测试"></a>5 测试</h1><p>执行测试命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -v -run 3A</span><br></pre></td></tr></table></figure><p>结果如下:<br><img src="/../../images/lab3-3A-test.png" alt="Alt text"></p><p>该代码经过150次测试没有报错</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将介绍&lt;code&gt;lab3A&lt;/code&gt;部分的实现, &lt;code&gt;lab3A&lt;/code&gt;要求基于&lt;code&gt;raft&lt;/code&gt;实现一个容错的分布式&lt;code&gt;KV&lt;/code&gt;数据库, 但不要求实现快照, 难度还是不小&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Lab&lt;/cod</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="Lab笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/Lab%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Go" scheme="http://example.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.5840(6.824) Lec10: ZooKeeper</title>
    <link href="http://example.com/2024/01/19/MIT6.5840/Lec10%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/01/19/MIT6.5840/Lec10%E7%AC%94%E8%AE%B0/</id>
    <published>2024-01-19T06:22:02.000Z</published>
    <updated>2024-01-22T00:22:47.152Z</updated>
    
    <content type="html"><![CDATA[<p>本次课程介绍了<code>ZooKeeper</code>, 并且我结合教授的课程和原论文总结了<code>ZooKeeper</code>的关键知识点形成了本文</p><p>课程主页: <a href="https://pdos.csail.mit.edu/6.824/schedule.html">https://pdos.csail.mit.edu/6.824/schedule.html</a></p><p>原论文地址: <a href="https://pdos.csail.mit.edu/6.824/papers/zookeeper.pdf">https://pdos.csail.mit.edu/6.824/papers/zookeeper.pdf</a></p><h1 id="0-引入-ZooKeeper是什么-和Raft区别是什么"><a href="#0-引入-ZooKeeper是什么-和Raft区别是什么" class="headerlink" title="0 引入: ZooKeeper是什么? 和Raft区别是什么?"></a>0 引入: ZooKeeper是什么? 和Raft区别是什么?</h1><ul><li><strong>更容易的交互</strong></li></ul><ol><li><code>Apache ZooKeeper</code> 是一个开源的分布式协调服务，它为分布式应用提供了一种可靠的同步服务。<code>ZooKeeper</code> 允许分布式进程通过一个共享的层次名称空间互相协调，这个名称空间类似于文件系统的目录树结构，但是它更专注于协调，而不是存储。ZooKeeper的设计目标是将分布式协调的复杂性封装起来，为开发人员提供一个简单一致的编程接口。也就是说, <code>ZooKeeper</code> 可以直接供应用程序进行交互, 应用程序不需要与<code>ZooKeeper</code>在底层上关联(例如加载二进制库文件)</li><li><code>Raft</code>不是一个可以直接交互的独立的服务， 而是以一个库的形式提供服务, 因此必须要设计自己的应用程序来与<code>Raft</code>库交互。<blockquote><p><code>Zookeeper</code>运行在<code>Zab</code>之上，<code>Zab</code>和之前的<code>Lab</code>实现的<code>Raft</code>属于同一层级, <code>Zab</code>在更低的层级也是维护一系列的<code>log</code>, 和<code>raft</code>类似</p></blockquote></li></ol><ul><li>提升读请求的性能</li></ul><ol><li><p><code>raft</code>的效率<br>由于我们目前已经实现了<code>raft</code>协议, 因此我们知道, 服务的性能并不随服务器数量的提升线性增长, 甚至会有性能下降, 因为<code>raft</code>需要将一个日志复制到过半的节点后才能标记为<code>commit</code>, 因此服务器越多, 这一步骤耗费越大, 甚至拖累整个几集群的运行速度。</p></li><li><p><code>ZooKeeper</code>的效率<br><code>ZooKeeper</code>的读请求直接发送给一个随机的副本处理, 不需要在真个集群内进行同步, 因此其运行速度更快, 缺点是<strong>除了<code>Leader</code>以外的任何一个副本节点的数据是不一定是最新的</strong></p><blockquote><p>因此, <code>Zookeeper</code>的读操作放弃了线性一致性</p></blockquote></li></ol><h1 id="1-ZooKeeper如何提供服务"><a href="#1-ZooKeeper如何提供服务" class="headerlink" title="1 ZooKeeper如何提供服务?"></a>1 <code>ZooKeeper</code>如何提供服务?</h1><h2 id="1-1-服务保证"><a href="#1-1-服务保证" class="headerlink" title="1.1 服务保证"></a>1.1 服务保证</h2><p>简单来说, <code>ZooKeeper</code>是通过<code>client</code>对一个<strong>分层的命名空间</strong>中节点(<code>znodes</code>)的<code>CRUD</code>操作来实现各种分布式服务, <code>ZooKeeper</code>为这个命名空间的各种操作做出了如下的保证:</p><ol><li><p>写操作的线性一致性 (<code>Linearizable Writes</code>)<br>ZooKeeper保证所有更新其状态的请求都是可序列化的，并且遵循先行顺序。这意味着写操作是原子的，并且系统中的所有其他操作都将看到这一操作之前或之后的状态，而不会有部分更新的现象。这是分布式系统中对于一致性的一个关键保证。</p><blockquote><p>需要注意的是, <code>ZooKeeper</code>中的读操作默认情况下并不是线性一致的，这意味着读操作可能会返回一个稍微过时的数据状态，而不是最新的写操作之后的状态。这样做的目的是为了提高性能，因为读操作可以在没有与其他服务器通信的情况下本地快速完成。如果需要读取最新的数据状态, <code>ZooKeeper</code>提供了后面提到的<code>sync</code>操作</p></blockquote></li><li><p>客户端FIFO顺序 (<code>FIFO Client Order</code>)<br>来自同一个客户端的所有请求都将按照它们被客户端发送的顺序执行。这意味着同一个客户端发起的操作将会按照其发起的顺序被严格处理，保证了客户端视图的顺序性。</p></li><li><p>线性一致性 (<code>A-linearizability</code>)<br><code>ZooKeeper</code>定义的线性一致性称为异步线性一致性（<code>A-linearizability</code>）。在Herlihy的定义中，客户端一次只能有一个操作在执行中（如同一个线程）。而在<code>ZooKeeper</code>的定义中，一个客户端可以有多个未完成的操作，因此可以选择不保证同一客户端的未完成操作的特定顺序，或者保证FIFO顺序。<code>ZooKeeper</code>选择了后者。</p></li><li><p>读操作的本地处理<br>由于只有更新请求是<code>A-linearizable</code>，<code>ZooKeeper</code>将读请求在每个副本上本地处理。这允许服务随着服务器的增加而线性扩展。</p></li><li><p>交互的保证<br>举例来说，如果一个系统中的多个进程选举出一个<code>Leader</code>来指挥工作进程，当一个新的<code>Leader</code>接管系统时，它必须更改许多配置参数，并在完成后通知其他进程。在这种情况下，<code>ZooKeeper</code>需要保证：</p></li></ol><ul><li>当新<code>Leader</code>开始进行更改时，不希望其他进程开始使用正在更改的配置；</li><li>如果新<code>Leader</code>在配置完全更新之前死亡，不希望进程使用这个部分配置。</li></ul><ol start="6"><li>存活性和持久性保证<br><code>ZooKeeper</code>还保证了存活性和持久性：</li></ol><ul><li>只要<code>ZooKeeper</code>服务器的大多数都是活跃的并且能够通信，服务就会可用；</li><li>如果<code>ZooKeeper</code>服务成功响应了一个变更请求，那么只要服务器的法定人数最终能够恢复，该变更就会持续存在，不会因为任何数量的故障而丢失。</li></ul><ol start="7"><li>同步读 (<code>sync</code>)<br>为了处理由于客户端之间通信延迟导致的潜在问题，<code>ZooKeeper</code>提供了<code>sync</code>请求。如果在执行读操作之前使用<code>sync</code>，它会导致服务器先应用所有挂起的写请求再处理读请求，这样客户端就能看到最新的状态，而不需要承担完整写操作的开销。</li></ol><p>通过以上的几项基本保证, 应用程序可以通过<code>ZooKeeper</code>构建许多的分布式服务, 如分布式锁、配置管理等。</p><h2 id="1-2-命名空间"><a href="#1-2-命名空间" class="headerlink" title="1.2 命名空间"></a>1.2 命名空间</h2><p>下图所示为<code>ZooKeeper</code>的命名空间图解， 实际上就是一棵树</p><p><img src="/../../images/ZooKeeper-namespace.png" alt="ZooKeeper-namespace"></p><p>树中的每一个节点用数据结构<code>Znode</code>表示, <code>Znode</code>可以有子节点，并且可以存储数据。每个<code>Znode</code>都由路径唯一标识，例如<code>/app1/myconfig/dbconfig</code>。具体而言, <code>Znode</code>有一下几个类比:</p><ol><li><code>Regular znodes</code>: 一旦创建，就永久存在，除非显示删除</li><li><code>Ephemeral znodes</code>: 与<code>client session</code>绑定, <code>session</code>结束则被删除(通过心跳判断<code>session</code>是否存活)</li><li><code>Sequential znodes</code>: 会自动为指定的文件名再加上一个数字并确保数字不重合且单调递增</li></ol><h2 id="1-3-API"><a href="#1-3-API" class="headerlink" title="1.3 API"></a>1.3 API</h2><p><code>ZooKeeper</code>的设计目标是将分布式协调的复杂性封装起来，为开发人员提供一个简单一致的编程接口。<br>基于您提供的格式，以下是对Apache ZooKeeper核心API的简化解释：</p><ol><li>create(path, data, flags)<br>用于创建一个新的<code>znode</code>。</li></ol><ul><li><code>path</code>: 想要创建的<code>znode</code>的路径。</li><li><code>data</code>: 一个字节数组，您想要存储在新<code>znode</code>中的数据。</li><li><code>flags</code>: 这个参数用来指定创建<code>znode</code>的类型。可以选择创建一个普通<code>znode</code>，一个临时的<code>znode</code>（<code>ephemeral</code>），或者是一个顺序的<code>znode</code>（<code>sequential</code>）。临时<code>znode</code>在创建它的客户端会话结束时会被删除，而顺序<code>znode</code>会有一个唯一的递增序号自动追加到它的路径名中。</li></ul><ol start="2"><li>delete(path, version)<br>删除指定路径的<code>znode</code>，但只在<code>znode</code>的版本号与提供的<code>version</code>参数匹配时才会执行。</li></ol><ul><li><code>path</code>: 要删除的<code>znode</code>的路径。</li><li><code>version</code>: 预期的<code>znode</code>版本号。如果指定的版本号与<code>znode</code>的当前版本号不匹配，删除操作将失败。</li></ul><ol start="3"><li>exists(path, watch)<br>这个API检查指定路径的<code>znode</code>是否存在。</li></ol><ul><li><code>path</code>: 要检查的<code>znode</code>的路径。</li><li><code>watch</code>: 一个布尔值，当设置为<code>true</code>时，如果这个<code>znode</code>的状态发生变化（比如被删除或数据被修改），客户端将被通知。</li></ul><ol start="4"><li>getData(path, watch)<br>获取一个<code>znode</code>的数据和元数据（如版本信息）。</li></ol><ul><li><code>path</code>: <code>znode</code>的路径。</li><li><code>watch</code>: 与<code>exists</code>中的<code>watch</code>相同，允许客户端在这个<code>znode</code>上设置一个监视器。如果这个<code>znode</code>不存在，ZooKeeper不会设置监视器。</li></ul><ol start="5"><li>setData(path, data, version)<br>向指定的<code>znode</code>写入数据，但只在当前版本号与提供的<code>version</code>参数匹配时才会执行。</li></ol><ul><li><code>path</code>: <code>znode</code>的路径。</li><li><code>data</code>: 要写入的数据的字节数组。</li><li><code>version</code>: <code>znode</code>的预期版本号。</li></ul><ol start="6"><li>getChildren(path, watch)<br>获取一个<code>znode</code>的所有子节点的名称集合。</li></ol><ul><li><code>path</code>: 父<code>znode</code>的路径。</li><li><code>watch</code>: 一个布尔值，作用与<code>exists</code>和<code>getData</code>中的<code>watch</code>相同。</li></ul><ol start="7"><li>sync(path)<br>同步API等待所有在操作开始时挂起的更新传播到客户端所连接的服务器。论文中提到目前实现中<code>path</code>参数被忽略，但在将来它可能会被用于指定同步操作的范围。</li></ol><h1 id="2-ZooKeeper的服务案例"><a href="#2-ZooKeeper的服务案例" class="headerlink" title="2 ZooKeeper的服务案例"></a>2 <code>ZooKeeper</code>的服务案例</h1><h2 id="2-1-配置管理"><a href="#2-1-配置管理" class="headerlink" title="2.1 配置管理"></a>2.1 配置管理</h2><p><code>ZooKeeper</code> 可以用来为分布式应用实现动态配置管理。其结构可以如下：</p><ul><li><strong>存储</strong>：配置数据被存储在 <code>ZooKeeper</code> 的一个节点（<code>znode</code>），称为 <code>zc</code>。</li><li><strong>初始化</strong>：进程启动时带有<code>zc</code>的完整路径，并通过读取该<code>znode</code>获取配置。</li><li><strong>监听</strong>：进程在读取配置时对 <code>zc</code> 设置监听（<code>watch flag</code>），以便在配置更新时得到通知。</li><li><strong>通知更新</strong>：一旦 <code>zc</code> 节点更新，进程会收到通知，并读取新的配置信息，并再次设置监听以便未来的更新。</li><li><strong>效率</strong>：监听确保进程始终使用最新的配置信息，并且在连续更新发生时不需要接收多个通知。</li></ul><blockquote><p>为什么需要<code>watch</code>?<br>因为可能存在如下情况:</p><ol><li>某个副本通过<code>exist</code>发现<code>zc</code>存在</li><li><code>Leader</code>删除了<code>zc</code></li><li>副本继续读取后续配置节点信息</li></ol><p>为了避免上述情况, <code>exist</code>查询时还会建立<code>watch</code>, 如果<code>zc</code>有任何变更, <strong>副本会确保在合适的时机返回变化的通知, 并且这是在任何后续的读请求之前完成</strong>, 体现在业务上就是: 读取配置读了一半，收到了<code>zc</code>删除的通知，放弃这次读再重试</p></blockquote><h2 id="2-2-会合点"><a href="#2-2-会合点" class="headerlink" title="2.2 会合点"></a>2.2 会合点</h2><p><code>ZooKeeper</code> 使得分布式系统中的进程能够动态发现对方，尤其是在系统配置未知的情况下：</p><ul><li>**会合点<code>znode</code>**：创建一个会合点<code>znode</code>，<code>zr</code>，用于进程间协调。</li><li><strong>启动参数</strong>：将 <code>zr</code> 的完整路径作为启动参数传递给主进程(master)和工作进程(worker)。</li><li><strong>主进程注册信息</strong>：主进程启动后，将其地址和端口信息写入 <code>zr</code>。</li><li><strong>工作进程发现</strong>：工作进程读取 <code>zr</code> 并设置监听，以便在 <code>zr</code> 更新主进程信息时得到通知。</li><li><strong>临时节点</strong>：如果 <code>zr</code> 是临时节点，主进程和工作进程可以通过监听 <code>zr</code> 的删除来进行清理操作（表示客户端结束）。</li></ul><h2 id="2-3-组成员管理"><a href="#2-3-组成员管理" class="headerlink" title="2.3 组成员管理"></a>2.3 组成员管理</h2><p><code>ZooKeeper</code> 使用临时节点来管理分布式系统中的组成员资格：</p><ul><li><strong>组表示</strong>：指定一个 <code>znode</code>，<code>zg</code>，来代表组。</li><li><strong>成员注册</strong>：成员进程启动时，在 <code>zg</code> 下创建一个临时子节点。</li><li><strong>唯一标识</strong>：子节点以进程的唯一名称或标识符命名，或者使用SEQUENTIAL标志以自动获取唯一名称。</li><li><strong>进程信息</strong>：子节点的数据字段可以包含相关进程信息，例如使用的地址和端口。</li><li><strong>自动清理</strong>：当进程失败或结束时，其在 <code>zg</code> 下代表它的节点会被自动移除。</li><li><strong>发现和监控</strong>：进程通过列出 <code>zg</code> 的子节点来获取组信息，并且可以设置监听来监控组成员资格的变化，接到通知时刷新信息并再次设置监听。</li></ul><h2 id="2-3-分布式锁"><a href="#2-3-分布式锁" class="headerlink" title="2.3 分布式锁"></a>2.3 分布式锁</h2><h3 id="2-3-1-简单锁"><a href="#2-3-1-简单锁" class="headerlink" title="2.3.1 简单锁"></a>2.3.1 简单锁</h3><p>尽管 <code>ZooKeeper</code> 不是专门的锁服务，但它可以用来实现锁。使用 <code>ZooKeeper</code> 的应用程序通常会根据它们的需求使用定制的同步原语，如上所述。下面展示如何使用 <code>ZooKeeper</code> 实现锁，以表明它能够实现多种通用的同步原语。</p><p>最简单的锁实现使用“锁文件”。</p><ol><li>锁由一个 <code>znode</code> 表示。</li><li>为了获得锁，客户端尝试使用 <code>EPHEMERAL</code> 标志创建指定的 <code>znode</code>。如果创建成功，客户端持有锁。否则，客户端可以使用 <code>watch</code> 标志读取 <code>znode</code>，以便在当前领导者死亡时得到通知。客户端在它死亡或显式删除 <code>znode</code> 时释放锁。</li><li>其他等待锁的客户端一旦观察到 <code>znode</code> 被删除，就会再次尝试获得锁。<br>伪代码如下:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WHILE TRUE:</span><br><span class="line">    IF CREATE(<span class="string">&quot;f&quot;</span>, data, ephemeral=TRUE): RETURN</span><br><span class="line">    IF EXIST(<span class="string">&quot;f&quot;</span>, watch=TRUE):</span><br><span class="line">        WAIT</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>这里在获取锁失败后还需要检测锁文件是否存在, 因为<code>CREATE</code>和<code>EXIST</code>之间可能其他客户端删除了锁文件</p></blockquote><p>这种简单的锁定协议虽然有效，但存在一些问题。首先，它会遭受羊群效应（<code>herd effect</code>）。如果有许多客户端等待获得锁，当锁释放时，他们都会争夺锁，尽管只有一个客户端可以获得锁。其次，它只实现了独占锁定。以下两个原语展示如何克服这两个问题。</p><h3 id="2-3-2-不具有羊群效应的锁"><a href="#2-3-2-不具有羊群效应的锁" class="headerlink" title="2.3.2 不具有羊群效应的锁"></a>2.3.2 不具有羊群效应的锁</h3><p>定义一个锁 <code>znode</code> <code>l</code> 来实现这样的锁。直观地，排列所有请求锁的客户端，每个客户端按请求到达的顺序获得锁。因此，希望建立锁的客户端会执行以下操作：</p><p><strong>加锁</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 n = create(l + &quot;/lock-&quot;, EPHEMERAL|SEQUENTIAL)</span><br><span class="line">2 C = getChildren(l, false)</span><br><span class="line">3 if n is the lowest znode in C, exit</span><br><span class="line">4 p = znode in C ordered just before n</span><br><span class="line">5 if exists(p, true) wait for watch event</span><br><span class="line">6 goto 2</span><br></pre></td></tr></table></figure><p><strong>解锁</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 delete(n)</span><br></pre></td></tr></table></figure><p>在加锁的第 1 行中使用 <code>SEQUENTIAL</code> 标志，按顺序排列客户端尝试获得锁的尝试。如果客户端的 <code>znode</code> 在第 3 行时具有最低的序列号，那么该客户端持有锁。否则，客户端等待删除拥有锁或在该客户端的 <code>znode</code> 之前将获得锁的 <code>znode</code>。通过只监视在客户端的 <code>znode</code> 之前的 <code>znode</code>，通过在释放锁或放弃锁请求时只唤醒一个进程来避免羊群效应。一旦客户端正在监视的 <code>znode</code> 消失，客户端必须检查它现在是否持有锁。（之前的锁请求可能被放弃，还有一个具有较低序列号的 <code>znode</code> 仍在等待或持有锁。）</p><p>释放锁就像删除代表锁请求的 <code>znode</code> <code>n</code> 一样简单。通过在创建时使用 EPHEMERAL 标志，崩溃的进程将自动清理它们可能拥有的任何锁请求或释放的锁。</p><p>这种锁定方案有以下优点：</p><ol><li>一个 <code>znode</code> 的移除只会使一个客户端唤醒，因为每个 <code>znode</code> 仅被一个其他客户端监视，所以没有羊群效应；</li><li>没有轮询或超时；</li><li>由于实现锁定的方式，可以通过浏览 <code>ZooKeeper</code> 数据来了解锁竞争的数量，打破锁，以及调试锁定问题。</li></ol><h3 id="2-3-3-读-写锁"><a href="#2-3-3-读-写锁" class="headerlink" title="2.3.3 读&#x2F;写锁"></a>2.3.3 读&#x2F;写锁</h3><p>为实现读&#x2F;写锁，需要稍微修改锁定程序，并且有单独的读锁和写锁程序。解锁程序与全局锁情况相同。</p><p><strong>写锁</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 n = create(l + &quot;/write-&quot;, EPHEMERAL|SEQUENTIAL)</span><br><span class="line">2 C = getChildren(l, false)</span><br><span class="line">3 if n is the lowest znode in C, exit</span><br><span class="line">4 p = znode in C ordered just before n</span><br><span class="line">5 if exists(p, true) wait for event</span><br><span class="line">6 goto 2</span><br></pre></td></tr></table></figure><p><strong>读锁</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 n = create(l + &quot;/read-&quot;, EPHEMERAL|SEQUENTIAL)</span><br><span class="line">2 C = getChildren(l, false)</span><br><span class="line">3 if no write znodes lower than n in C, exit</span><br><span class="line">4 p = write znode in C ordered just before n</span><br><span class="line">5 if exists(p, true) wait for event</span><br><span class="line">6 goto 3</span><br></pre></td></tr></table></figure><p>这种锁定程序与之前的锁略有不同。写锁只在命名上有所不同。由于读锁可以共享，第 3 和第 4 行略有不同，因为只有较早的写锁 <code>znode</code> 会阻止客户端获得读锁。看起来在多个客户端等待读锁时可能会有“羊群效应”，并且在删除序列号较低的“write-” <code>znode</code> 时得到通知；实际上，这是一种期望的行为，所有那些等待读锁的客户端应该被释放，因为他们现在可能持有锁。</p><h2 id="2-4-双重屏障"><a href="#2-4-双重屏障" class="headerlink" title="2.4 双重屏障"></a>2.4 双重屏障</h2><p>双重屏障使客户端能够同步计算的开始和结束。当足够多的进程（由屏障阈值定义）加入屏障时，进程开始他们的计算，并在他们完成后离开屏障。</p><ol><li>用一个称为 <code>b</code> 的 <code>znode</code> 在 <code>ZooKeeper</code> 中表示一个屏障。</li><li>每个进程 <code>p</code> 通过在入口处创建一个作为 <code>b</code> 的子节点的 <code>znode</code> 来注册，并在准备离开时注销（删除该子节点）。</li><li>当 <code>b</code> 的子节点数超过屏障阈值时，进程可以进入屏障。</li><li>当所有进程都移除了它们的子节点时，进程可以离开屏障。</li><li>使用 <code>watches</code> 高效等待进入和退出条件得到满足。</li><li>为了进入，进程监视 <code>b</code> 的一个 <code>ready</code> 子节点的存在，该节点将由导致子节点数超过屏障阈值的进程创建。为了离开，进程监视特定子节点的消失，并且只有在该 <code>znode</code> 被移除后才检查退出条件。</li></ol><h2 id="2-5-并发计数器"><a href="#2-5-并发计数器" class="headerlink" title="2.5 并发计数器"></a>2.5 并发计数器</h2><p>通过<code>ZooKeeper</code>提供的版本号, 可以在无锁的条件下实现一个并发计数器:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WHILE TRUE:</span><br><span class="line">    X, V = GETDATA(<span class="string">&quot;F&quot;</span>)</span><br><span class="line">    IF SETDATA(<span class="string">&quot;f&quot;</span>, X + <span class="number">1</span>, V):</span><br><span class="line">        BREAK</span><br></pre></td></tr></table></figure><p>在这个循环中先调用<code>GETDATA</code>读取一次数据并记录其版本号<code>V</code>, 然后调用<code>SETDATA</code>更新数据, 且这个函数只在办好匹配的情况下才更新数据, 如果版号不匹配则进入下一次循环</p><h1 id="3-ZooKeeper的实现"><a href="#3-ZooKeeper的实现" class="headerlink" title="3 ZooKeeper的实现"></a>3 <code>ZooKeeper</code>的实现</h1><h2 id="3-1-基本架构"><a href="#3-1-基本架构" class="headerlink" title="3.1 基本架构"></a>3.1 基本架构</h2><p><img src="/../../images/ZooKeeper-components.png" alt="ZooKeeper-components"></p><p>上图所示为<code>ZooKeeper </code>服务的组件: 收请求、准备执行请求的<code>request processor</code> 以及对需要多个服务器之间协调的请求（写请求）使用的一致性协议(<code>Atomic Broadcast</code>), 数据将保存在一个内存数据库中, 其包含包含完整的树结构。</p><p>其处理请求的逻辑如下：</p><ul><li><strong>写请求</strong>：需要协调的请求，将通过一致性协议来确保所有服务器都同意状态变更。之后，服务器将更改提交到 <code>ZooKeeper</code> 数据库，该数据库在整个集群的所有服务器之间完全复制。</li><li><strong>读请求</strong>：不需要协调的请求，服务器将直接从本地数据库读取状态并生成响应。</li></ul><h2 id="3-2-Request-Processor"><a href="#3-2-Request-Processor" class="headerlink" title="3.2 Request Processor"></a>3.2 <code>Request Processor</code></h2><p>在 <code>ZooKeeper</code> 的实现中，请求处理器（<code>Request Processor</code>）是负责处理客户端发来的写请求并将其转换为事务的组件。其实现包含了如下特性:</p><ol><li><p><strong>原子性消息层</strong>：<code>ZooKeeper</code> 的消息层是原子性的，这保证了本地副本之间永远不会出现数据分歧。虽然在任何时候，一些服务器可能已经应用了更多的事务。</p></li><li><p><strong>幂等事务</strong>：与来自客户端的请求不同，事务是幂等的，意味着多次执行相同的事务不会改变系统的状态。</p></li><li><p><strong>事务生成</strong>：当<code>Leader</code>服务器接收到写请求时，它会计算出当写操作应用时系统的状态，并将其转换为捕获这种新状态的事务。</p></li><li><p><strong>计算未来状态</strong>：必须计算未来的状态，因为可能有尚未应用到数据库的未完成事务。这意味着，系统的当前状态可能不完全反映所有排队事务的结果。</p></li><li><p><strong>条件写操作</strong>：例如，如果客户端执行了一个条件 <code>setData</code> 操作，且请求中的版本号与更新中的 znode 的未来版本号匹配，那么服务会生成一个包含新数据、新版本号和更新时间戳的 <code>setDataTXN</code>。</p></li><li><p><strong>错误处理</strong>：如果出现错误，如版本号不匹配或待更新的 znode 不存在，则生成一个 <code>errorTXN</code>。这样的错误事务可以用于向客户端指示操作失败的原因。</p></li></ol><p>通过这种方式，请求处理器保证只有当写请求能够成功应用到数据库的未来状态时，才会生成并广播事务。这种设计允许 <code>ZooKeeper</code> 在保持一致性的同时，优化读写操作的处理效率。请求处理器的幂等性质也确保了即使在出现网络重试或其他重复操作的情况下，不会对系统状态产生意外的影响。</p><h2 id="3-3-内存数据库"><a href="#3-3-内存数据库" class="headerlink" title="3.3 内存数据库"></a>3.3 内存数据库</h2><p><code>ZooKeeper</code> 的每个副本都在内存中维护了一个 <code>ZooKeeper</code> 状态的副本。当服务恢复自崩溃时，它需要恢复这个内部状态。如果要通过重放所有已交付的消息来恢复状态，在服务运行一段时间后，这将花费过长时间，因此 <code>ZooKeeper</code> 使用周期性的快照，并且只需要重新交付自快照开始以来的消息。</p><p>快照在 <code>ZooKeeper</code> 中被称为“模糊快照”（<code>fuzzy snapshots</code>），因为在进行快照时，<code>ZooKeeper</code> 不会锁定状态。相反，它会进行一次深度优先扫描，原子性地读取每个 <code>znode</code> 的数据和元数据，并将它们写入磁盘。由于在生成快照期间可能已经应用了一部分状态变更，所以得到的模糊快照可能不对应于 <code>ZooKeeper</code> 在任何时间点的状态。然而，由于状态变更是幂等的，我们可以重复应用它们，只要我们按照顺序应用这些状态变更。</p><h2 id="3-4-Client和Server的交互"><a href="#3-4-Client和Server的交互" class="headerlink" title="3.4 Client和Server的交互"></a>3.4 <code>Client</code>和<code>Server</code>的交互</h2><h3 id="3-4-1-写请求"><a href="#3-4-1-写请求" class="headerlink" title="3.4.1 写请求"></a>3.4.1 写请求</h3><p>在<code>ZooKeeper</code>中，写请求的处理过程是为了确保系统的一致性和数据的同步。这里详细说明写请求的处理：</p><ol><li><p><strong>写请求的提交</strong></p><ol><li><p><strong>客户端发起写请求</strong>：客户端向其连接的<code>ZooKeeper</code>服务器（可能是任何一个<code>follower</code>或者<code>leader</code>）发出一个写请求。</p></li><li><p><strong>请求转发至Leader</strong>：如果客户端连接的不是<code>leader</code>节点，该请求将被转发到<code>leader</code>节点。<code>ZooKeeper</code>集群中的所有写请求都必须由<code>leader</code>节点来协调。</p></li><li><p><strong>Leader预处理请求</strong>：<code>leader</code>节点接收到写请求后，它会为该请求分配一个全局唯一的事务ID，称为<code>zxid</code>。这个ID体现了写请求的顺序，保证了事务的处理顺序与到达顺序相同。</p></li><li><p><strong>提议（Proposal）</strong>：<code>leader</code>节点根据写请求创建一个提议（<code>proposal</code>）并将该提议发送给所有的<code>follower</code>节点。</p></li><li><p><strong>投票（Voting）</strong>：每个<code>follower</code>节点接收到提议后，会进行投票。如果<code>follower</code>节点同意该提议，它将发送一个“赞成”投票给<code>leader</code>。</p></li><li><p><strong>确认（Acknowledge）</strong>：<code>leader</code>节点收集足够多的“赞成”投票（超过半数的<code>follower</code>节点）后，该提议被认为是已经被接受。</p></li></ol></li><li><p><strong>写请求的执行</strong></p><ol><li><p><strong>提交（Commit）</strong>：一旦提议被接受，<code>leader</code>节点会发送一个提交消息给所有<code>follower</code>节点，指示它们将该写操作应用到它们的本地存储。</p></li><li><p><strong>本地写入</strong>：每个<code>follower</code>节点接收到提交消息后，将写操作应用到它们的本地副本上。</p></li><li><p><strong>响应客户端</strong>：写操作被成功应用到数据存储后，每个服务器（包括<code>leader</code>和<code>follower</code>）都会向发起写请求的客户端发送响应，告知写操作已经成功完成。</p></li></ol></li><li><p><strong>写请求的监视（<code>Watches</code>）和通知</strong></p><ol><li><p><strong>设置监视</strong>：客户端可以在节点上设置监视（<code>watch</code>），这样当该节点发生变化时，客户端会收到通知。</p></li><li><p><strong>通知过程</strong>：当写请求导致节点发生变化时（例如数据更新、节点创建或删除等），<code>ZooKeeper</code>服务器会触发监视事件，并向设置了监视的客户端发送通知。</p></li></ol></li></ol><p>通过上述步骤，<code>ZooKeeper</code>保障了写请求的顺序性、一致性和可靠性。此外，通过要求写操作在大多数节点上被提交，<code>ZooKeeper</code>还确保了数据的持久性和容错性。这些是<code>ZooKeeper</code>作为分布式协调服务的核心特性。</p><h3 id="3-4-2-读请求"><a href="#3-4-2-读请求" class="headerlink" title="3.4.2 读请求"></a>3.4.2 读请求</h3><p><strong>从服务视角看读请求</strong>:</p><ol><li>读请求在每个服务器本地处理，不需要磁盘活动或运行共识协议。</li><li>每个读请求都会被标记一个<code>zxid</code>（<code>ZooKeeper</code>事务ID），该ID指示服务器看到的最后一次事务，为读请求相对于写请求定义了部分顺序。</li><li>本地处理读取请求确保了极好的性能，因为这只是在本地服务器上的内存操作。</li></ol><p><strong>从<code>log</code>的视角看读请求</strong>:</p><p>如果<code>client</code>以某种顺序读某个数据, 那么读请求需要在<code>Log</code>的某个特定的点执行, 并且后续的读请求只允许在第一个读请求对应的<code>Log</code>位置或者更后的位置执行。</p><p>但是如果出现了故障呢? <code>client</code>在一个副本执行了一个读请求并看到了对应于<code>Log</code>中这个点的状态, 此后副本故障了, <code>client</code>切换到了一个新的副本并且发起了另一个读请求, 在新的副本的读请求，必须在之前读请求对应的<code>Log</code>点或者之后的点执行。如何实现呢? </p><p>答案是, 每个<code>Log</code>条目都会被<code>Leader</code>打上<code>zxid</code>的标签，这些标签就是<code>Log</code>对应的条目号。任何时候一个副本回复一个<code>client</code>的读请求，首先这个读请求是在<code>Log</code>的某个特定点执行的，其次回复里面会带上<code>zxid</code>，对应的就是<code>Log</code>中执行点的前一条<code>Log</code>条目号。<code>client</code>会记住最高的<code>zxid</code>，当<code>client</code>发出一个请求到一个相同或者不同的副本时，它会在它的请求中带上这个最高的<code>zxid</code>。这样，其他的副本就知道，应该至少在<code>Log</code>中这个点或者之后执行这个读请求。</p><blockquote><p>如果第二个副本并没有最新的<code>Log</code>，当它从<code>client</code>收到一个请求，<code>client</code>说，上一次我的读请求在其他副本Log的这个位置执行。那么在获取到对应这个位置的Log之前，这个副本不能响应客户端请求。</p></blockquote><h3 id="3-4-3-同步原语（Sync-Primitive）"><a href="#3-4-3-同步原语（Sync-Primitive）" class="headerlink" title="3.4.3 同步原语（Sync Primitive）"></a>3.4.3 同步原语（Sync Primitive）</h3><ul><li>对于需要最新读取信息的应用程序，<code>ZooKeeper</code>提供了<code>sync</code>原语。</li><li><code>sync</code>在领导者处理完所有挂起的写操作到其本地副本之后按顺序执行，并且是异步的。</li><li>为了获取最新的更新，客户端可以先调用<code>sync</code>然后再进行读操作，以确保读取反映了<code>sync</code>之前的任何更改。</li></ul><blockquote><p>实际上, 可以把<code>sync</code>看出空的写操作</p></blockquote><h3 id="3-4-4-实施细节"><a href="#3-4-4-实施细节" class="headerlink" title="3.4.4 实施细节"></a>3.4.4 实施细节</h3><ul><li>由于采用了基于领导者的算法，<code>sync</code>不需要原子广播；它只是在领导者和执行<code>sync</code>的服务器之间请求队列的末尾。</li><li>执行<code>sync</code>的服务器必须确信领导者仍然是领导者；否则，领导者会在排序<code>sync</code>之前发出一个空事务来提交。</li><li>系统设计避免在领导者负载下产生额外的广播流量，并通过超时设置来防止不必要的空事务。</li></ul><h3 id="3-4-5-客户端会话管理"><a href="#3-4-5-客户端会话管理" class="headerlink" title="3.4.5 客户端会话管理"></a>3.4.5 客户端会话管理</h3><ul><li><code>ZooKeeper</code>服务器以FIFO顺序处理客户端请求，响应包括它们相对的<code>zxid</code>。</li><li>无活动期间发送的心跳消息包括客户端连接的服务器所看到的最后一个<code>zxid</code>。</li><li>如果客户端连接到新服务器，服务器通过比较<code>zxid</code>来确保其视图至少像客户端的视图一样最新。</li><li>客户端可以确保找到一个具有系统最新视图的服务器，因为它们只看到已经复制到<code>ZooKeeper</code>服务器多数的更改，确保了持久性。</li></ul><h3 id="3-4-6-会话失败和超时"><a href="#3-4-6-会话失败和超时" class="headerlink" title="3.4.6 会话失败和超时"></a>3.4.6 会话失败和超时</h3><ul><li><code>ZooKeeper</code>使用超时来检测客户端会话失败；如果在会话超时期间没有服务器收到客户端的任何消息，则假定会话失败。</li><li>在活动低时期或在没有通信的足够时间过去后，客户端会发送心跳消息来避免会话超时。</li><li>客户端库在会话空闲时间达到会话超时的三分之一后发送心跳，并在超过会话超时的三分之二时间内没有从服务器收到消息时切换到新服务器。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本次课程介绍了&lt;code&gt;ZooKeeper&lt;/code&gt;, 并且我结合教授的课程和原论文总结了&lt;code&gt;ZooKeeper&lt;/code&gt;的关键知识点形成了本文&lt;/p&gt;
&lt;p&gt;课程主页: &lt;a href=&quot;https://pdos.csail.mit.edu/6.824/</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="ZooKeeper" scheme="http://example.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.5840(6.824) Lec09笔记: 线性一致性</title>
    <link href="http://example.com/2024/01/16/MIT6.5840/Lec09%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/01/16/MIT6.5840/Lec09%E7%AC%94%E8%AE%B0/</id>
    <published>2024-01-16T08:26:22.000Z</published>
    <updated>2024-01-19T16:27:19.551Z</updated>
    
    <content type="html"><![CDATA[<p>课程主页: <a href="https://pdos.csail.mit.edu/6.824/schedule.html">https://pdos.csail.mit.edu/6.824/schedule.html</a></p><h1 id="1-分布式系统正确性的定义"><a href="#1-分布式系统正确性的定义" class="headerlink" title="1 分布式系统正确性的定义"></a>1 分布式系统正确性的定义</h1><p>这里, 课程还是给出了一个<code>K/V存储</code>的案例来说明如何定义分布式系统重操作的正确性, 并引入了线性一致性</p><h2 id="2-1-场景描述"><a href="#2-1-场景描述" class="headerlink" title="2.1 场景描述"></a>2.1 场景描述</h2><p>课程中的<code>K/V存储</code>的案例用<code>Python</code>代码描述如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KVStore</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._data = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        self._data[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> self._data.get(key, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>对于什么是正确的操作, 最直观的理解是:<strong><code>Get</code> 操作必须反映应用所有先前 <code>Put</code> 操作的结果</strong>, </p><p>在非并发的单机单线程环境下, 以上要求是自然被满足的, 但我们需要考虑的是如下一个分布式场景:</p><p>![Lec09-KV-case1]..&#x2F;..&#x2F;images&#x2F;(Lec09-KV-case1.png)</p><p>上图的每一个操作的全过程用一个矩形条来表示, 左边表示操作开始, 右边表示操作结束。在上图的场景下， 很难确定<code>Get(&quot;x&quot;)</code>返回值究竟是多少, 因为并发场景下, 我们不知道两个<code>Put</code>操作真正被执行时<code>Get</code>操作到哪一步了。为了定义在上述场景下的操作正确性，引入了<strong>线性一致性</strong>的概念</p><h2 id="2-2-线性一致性的定义"><a href="#2-2-线性一致性的定义" class="headerlink" title="2.2 线性一致性的定义"></a>2.2 线性一致性的定义</h2><p>什么是线性一致性(<code>Linearizability</code>)? 简单来说, 线性一致性是指一个系统表现得就像只有一个服务器，并且服务器没有故障，每次执行一个客户端请求，并且没有奇怪的事情发生。在线性一致性系统中，执行历史是一系列的客户端请求，可以按照一个顺序排列，并且排列顺序与客户端请求的实际时间相符合。这意味着操作是非并发的，每一个读操作都看到的是最近一次写入的值。</p><h2 id="2-3-案例"><a href="#2-3-案例" class="headerlink" title="2.3 案例"></a>2.3 案例</h2><p>考虑下面的这个场景：</p><p><img src="/../../images/Lec09-KV-case2.png" alt="Lec09-KV-case2"></p><p>该场景是可线性化的，其结果如下：</p><p><img src="/../../images/Lec09-KV-case3.png" alt="Lec09-KV-case3"></p><p>但下面这个场景就是不可线性化的:</p><p><img src="/../../images/Lec09-KV-case4.png" alt="Lec09-KV-case4"></p><p>原因在于, 既然<code>Client 3</code>得到了1这个结果, 那么<code>Client 2</code>的<code>Put</code>操作一定在<code>Client 3</code>的<code>Get</code>操作结束前完成了, 那么<code>Client 4</code>的<code>Get</code>操作就不应该得到旧值0</p><ul><li>总结一下, 如何判断操作是否线性一致:<br>如果能构建一个操作序列, 满足每个才做读取的值都是前一个操作实际写入的结果, 那么其就是线性一致的</li></ul><p>换言之，<strong>不允许一个存储在系统中的数据有不同的演进过程。</strong></p><h2 id="2-4-非线性一致的另一种解释-环"><a href="#2-4-非线性一致的另一种解释-环" class="headerlink" title="2.4 非线性一致的另一种解释:环"></a>2.4 非线性一致的另一种解释:环</h2><p><img src="/../../images/Lec09-Ring.png" alt="Lec09-ring"></p><p>上图所示为<code>KV</code>场景下的一个非线性一致案例, <code>Client4</code>读取到<code>x=1</code>, 因此<code>Client1</code>的<code>Put(x,1)</code>应该先于<code>Client4</code>的第一个<code>Get</code>完成, 我们用一个从<code>Client1</code>的<code>Put</code>指向<code>Client4</code>的第一个<code>Get</code>的箭头表示这种先后关系。同理，也存在这样一条从<code>Client2</code>的<code>Put</code>指向<code>Client3</code>的第一个<code>Get</code>的箭头。由于<code>Client4</code>的第二个<code>Get</code>读取到了2, 因此第一个<code>Get</code>完成后, <code>Client2</code>的<code>Put</code>一定先于<code>Client4</code>的第2个<code>Get</code>, 因此存在从<code>Client4</code>的第一个<code>Get</code>指向<code>Client2</code>的<code>Put</code>的箭头。同理, 也存在从<code>Client3</code>的第一个<code>Get</code>指向<code>Client1</code>的第二个<code>Put</code>的箭头。</p><p>到这里为止，就出现了上图所示的<strong>环</strong>，这也是另一种非线性一致的表达方式。</p><h1 id="3-重复的RPC和线性一致的关联"><a href="#3-重复的RPC和线性一致的关联" class="headerlink" title="3 重复的RPC和线性一致的关联"></a>3 重复的<code>RPC</code>和线性一致的关联</h1><p>由于我们目前已经完成了<code>Lab2</code>的实验, 在<code>Lab2: raft</code>中, 请求失败后将导致<code>cleint</code>重新发送请求, 但在<code>cleint</code>侧看到的只是第一个请求失败了, 其可能的状况是:</p><ol><li><code>Leader</code>根本就没有执行过这个请求, 因为<code>Leader</code>发生了网络分区</li><li><code>Leader</code>已经执行过这个请求了, 但回复时发生了丢包</li><li><code>Leader</code>收到了第一次请求, 但执行过程中故障了</li><li>第一次请求本身就发生了丢包</li><li>…</li></ol><p>因此<code>client</code>不能判断具体的原因, 但这将导致第二个请求可能被<code>Leader</code>(可能是新的, 也可能是旧的)看做一个重复的请求, 而有些请求被再次执行将导致状态机错误, 因此服务端应该能够判断这是不是一个重复的请求, 最简单的方案就是为每一个请求加上一个全局的索引, 服务端维护一个请求索引的哈希表烂判断请求是否重复。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;课程主页: &lt;a href=&quot;https://pdos.csail.mit.edu/6.824/schedule.html&quot;&gt;https://pdos.csail.mit.edu/6.824/schedule.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-分布式系统正确性的</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="线性一致性" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.5840(6.824) Lab2: Raft 2D</title>
    <link href="http://example.com/2024/01/15/MIT6.5840/Lab2D/"/>
    <id>http://example.com/2024/01/15/MIT6.5840/Lab2D/</id>
    <published>2024-01-15T11:25:43.000Z</published>
    <updated>2024-02-27T06:02:43.810Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍<code>lab2D</code>部分的实现, <code>lab2D</code>要求实现<code>raft</code>中的快照功能。从个人体验而言, <code>lab2D</code>是目前所有<code>Lab</code>中最难的一个, 各种边界情况层出不穷, <code>debug</code>时看着上千行的<code>debug</code>日志, 一度感到绝望…好在反复调试后终于实现了<code>raft</code>, 还是有点小感动☺️</p><p>主要难度在于:</p><ol><li>将日志数组截断后, 需要实现全局索引和数组索引之前的转化, 需要考虑更多数组越界的边界条件</li><li>在接收<code>InstallSnapshot RPC</code>安装快照后, <code>lastApplied</code>可能已经落后于快照产生时的日志索引, 是无效的日志项, 不应该被应用</li><li>由于安装快照后, <code>Leader</code>的<code>nextIndex</code>在回退时可能出现索引越界, 需要考虑边界情况</li></ol><p>个人体会是, 本<code>Lab</code>的核心技能是: <strong>一定要学会从日志输出中诊断问题!!!</strong></p><p><code>Lab文档</code>见: <a href="https://pdos.csail.mit.edu/6.824/labs/lab-raft.html">https://pdos.csail.mit.edu/6.824/labs/lab-raft.html</a></p><p>我的代码: <a href="https://github.com/ToniXWD/MIT6.5840/tree/lab2D">https://github.com/ToniXWD/MIT6.5840/tree/lab2D</a></p><h1 id="1-代码层级关系梳理"><a href="#1-代码层级关系梳理" class="headerlink" title="1 代码层级关系梳理"></a>1 代码层级关系梳理</h1><p>我们需要实现的<code>SnapShot</code>是在<code>raft</code>之上的<code>service</code>层提供的, 因为<code>raft</code>层并不理解所谓的<code>状态机</code>内部状态的机制, 因此有必要了解整个代码的层次结构:</p><p><img src="/../../images/raft_diagram.png" alt="raft_diagram"></p><p>官方的指导书贴心地给出了代码层级的和接口的示意图, 如上。<br><code>service</code>与<code>raft</code>的交互逻辑如下：</p><ol><li>日志复制与应用<br>具体的<code>service</code>, 如<code>Lab3</code>中将实现的KV存储, 位于<code>raft</code>层之上, 通过<code>Start</code>发送命令给<code>Leader</code>一侧的<code>raft</code>层, <code>Leader raft</code>会将日志项复制给集群内的其他<code>Follower raft</code>, <code>Follower raft</code>通过<code>applyCh</code>这个管道将已经提交的包含命令的日志项向上发送给<code>Follower</code>侧的<code>service</code>。</li><li>快照请求与传输<br>某一时刻， <code>service</code>为了减小内存压力，将<code>状态机状态</code>封装成一个<code>SnapShot</code>并将请求发送给<code>Leader</code>一侧的<code>raft</code>(<code>Follower</code>侧的<code>sevice</code>也会会存在快照操作), <code>raft</code>层保存<code>SnapShot</code>并截断自己的<code>log</code>数组, 当通过心跳发现<code>Follower</code>的节点的<code>log</code>落后<code>SnapShot</code>时, 通过<code>InstallSnapshot</code>发送给<code>Follower</code>, <code>Follower</code>保存<code>SnapShot</code>并将快照发送给<code>service</code></li><li>持久化存储<br><code>raft</code>之下还存在一个持久化层<code>Persistent Storage</code>, 也就是<code>Make</code>函数提供的<code>Persister</code>, 调用相应的接口实现持久化存储和读取</li></ol><h1 id="2-SnapShot设计"><a href="#2-SnapShot设计" class="headerlink" title="2 SnapShot设计"></a>2 <code>SnapShot</code>设计</h1><h2 id="2-1-日志截断和结构体设计"><a href="#2-1-日志截断和结构体设计" class="headerlink" title="2.1 日志截断和结构体设计"></a>2.1 日志截断和结构体设计</h2><p>由于发送<code>SnapShot</code>后需要截断日志, 而<code>raft</code>结构体中的字段如<code>commitIndex</code>, <code>lastApplied</code>等, 存储的仍然是全局递增的索引, 由官方的<code>Hint</code>:</p><blockquote><p>Even when the log is trimmed, your implemention still needs to properly send the term and index of the entry prior to new entries in AppendEntries RPCs; this may require saving and referencing the latest snapshot’s lastIncludedTerm&#x2F;lastIncludedIndex (consider whether this should be persisted).</p></blockquote><p>因此, 在<code>raft</code>结构体中额外增加字段:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">snapShot          []<span class="type">byte</span> <span class="comment">// 快照</span></span><br><span class="line">lastIncludedIndex <span class="type">int</span>    <span class="comment">// 日志中的最高索引</span></span><br><span class="line">lastIncludedTerm  <span class="type">int</span>    <span class="comment">// 日志中的最高Term</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我将全局真实递增的索引称为<code>Virtual Index</code>, 将<code>log</code>切片使用的索引称为<code>Real Index</code>, 因此如果<code>SnapShot</code>中包含的最高索引: <code>lastIncludedIndex</code>, 转换的函数应该为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RealLogIdx(vIdx <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 调用该函数需要是加锁的状态</span></span><br><span class="line"><span class="keyword">return</span> vIdx - rf.lastIncludedIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> VirtualLogIdx(rIdx <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 调用该函数需要是加锁的状态</span></span><br><span class="line"><span class="keyword">return</span> rIdx + rf.lastIncludedIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上的转换函数中, 所有有效的日志项索引从1开始, 这与最开始没有日志和持久化数据时的<code>log</code>数组一致:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="type">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span></span> *Raft &#123;</span><br><span class="line">DPrintf(<span class="string">&quot;server %v 调用Make启动&quot;</span>, me)</span><br><span class="line">...</span><br><span class="line">rf.log = <span class="built_in">make</span>([]Entry, <span class="number">0</span>)</span><br><span class="line">rf.log = <span class="built_in">append</span>(rf.log, Entry&#123;Term: <span class="number">0</span>&#125;)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我之前的<code>Make</code>中, 0索引处需要一个空的日志项占位, 截断日志时, 则使用<code>lastIncludedIndex</code>占位</p><p>有了<code>RealLogIdx</code>和<code>VirtualLogIdx</code>, 我的代码将遵循以下的<strong>规则</strong>:</p><ol><li>访问<code>rf.log</code>一律使用真实的切片索引, 即<code>Real Index</code></li><li>其余情况, 一律使用全局真实递增的索引<code>Virtual Index</code></li></ol><p>设计完成这两个函数后, 修改所有代码中对索引的操作, 调用<code>RealLogIdx</code>将<code>Virtual Index</code>转化为<code>Real Index</code>, 或调用<code>VirtualLogIdx</code>将<code>Real Index</code>转化为<code>Virtual Index</code>, 由于涉及代码太多且并不复杂, 此处不贴代码, 可以参考仓库</p><h2 id="2-2-Snapshot函数设计"><a href="#2-2-Snapshot函数设计" class="headerlink" title="2.2 Snapshot函数设计"></a>2.2 <code>Snapshot</code>函数设计</h2><p><code>Snapshot</code>很简单, 接收<code>service</code>层的快照请求, 并截断自己的<code>log</code>数组, 但还是有几个点需要说明:</p><ol><li>判断是否接受<code>Snapshot</code><ol><li>创建<code>Snapshot</code>时, 必须保证其<code>index</code>小于等于<code>commitIndex</code>, 如果<code>index</code>大于<code>commitIndex</code>, 则会有包括未提交日志项的风险。快照中不应包含未被提交的日志项</li><li>创建<code>Snapshot</code>时, 必须保证其<code>index</code>小于等于<code>lastIncludedIndex</code>, 因为这可能是一个重复的或者更旧的快照请求<code>RPC</code>, 应当被忽略</li></ol></li><li>将<code>snapshot</code>保存<br>因为后续<code>Follower</code>可能需要<code>snapshot</code>, 以及持久化时需要找到<code>snapshot</code>进行保存, 因此此时要保存以便后续发送给<code>Follower</code></li><li>除了更新<code>lastIncludedTerm</code>和<code>lastIncludedIndex</code>外, 还需要检查<code>lastApplied</code>是否位于<code>Snapshot</code>之前, 如果是, 需要调整到与<code>index</code>一致</li><li>调用<code>persist</code>持久化</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Snapshot(index <span class="type">int</span>, snapshot []<span class="type">byte</span>) &#123;</span><br><span class="line"><span class="comment">// Your code here (2D).</span></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rf.commitIndex &lt; index || index &lt;= rf.lastIncludedIndex &#123;</span><br><span class="line">DPrintf(<span class="string">&quot;server %v 拒绝了 Snapshot 请求, 其index=%v, 自身commitIndex=%v, lastIncludedIndex=%v\n&quot;</span>, rf.me, index, rf.commitIndex, rf.lastIncludedIndex)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DPrintf(<span class="string">&quot;server %v 同意了 Snapshot 请求, 其index=%v, 自身commitIndex=%v, 原来的lastIncludedIndex=%v, 快照后的lastIncludedIndex=%v\n&quot;</span>, rf.me, index, rf.commitIndex, rf.lastIncludedIndex, index)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存snapshot</span></span><br><span class="line">rf.snapShot = snapshot</span><br><span class="line"></span><br><span class="line">rf.lastIncludedTerm = rf.log[rf.RealLogIdx(index)].Term</span><br><span class="line"><span class="comment">// 截断log</span></span><br><span class="line">rf.log = rf.log[rf.RealLogIdx(index):] <span class="comment">// index位置的log被存在0索引处</span></span><br><span class="line">rf.lastIncludedIndex = index</span><br><span class="line"><span class="keyword">if</span> rf.lastApplied &lt; index &#123;</span><br><span class="line">rf.lastApplied = index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.persist()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-相关持久化函数"><a href="#2-3-相关持久化函数" class="headerlink" title="2.3 相关持久化函数"></a>2.3 相关持久化函数</h2><h3 id="2-3-1-persist函数"><a href="#2-3-1-persist函数" class="headerlink" title="2.3.1 persist函数"></a>2.3.1 <code>persist</code>函数</h3><p>添加快照后, 调用<code>persist</code>时还需要编码额外的字段<code>lastIncludedIndex</code>和<code>lastIncludedTerm</code>, 在调用<code>Save</code>函数时需要传入快照<code>rf.snapShot</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> persist() &#123;</span><br><span class="line"><span class="comment">// DPrintf(&quot;server %v 开始持久化, 最后一个持久化的log为: %v:%v&quot;, rf.me, len(rf.log)-1, rf.log[len(rf.log)-1].Cmd)</span></span><br><span class="line"></span><br><span class="line">w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">e := labgob.NewEncoder(w)</span><br><span class="line"><span class="comment">// 2C</span></span><br><span class="line">e.Encode(rf.votedFor)</span><br><span class="line">e.Encode(rf.currentTerm)</span><br><span class="line">e.Encode(rf.log)</span><br><span class="line"><span class="comment">// 2D</span></span><br><span class="line">e.Encode(rf.lastIncludedIndex)</span><br><span class="line">e.Encode(rf.lastIncludedTerm)</span><br><span class="line">raftstate := w.Bytes()</span><br><span class="line"></span><br><span class="line">rf.persister.Save(raftstate, rf.snapShot)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-读取持久化状态和快照"><a href="#2-3-2-读取持久化状态和快照" class="headerlink" title="2.3.2 读取持久化状态和快照"></a>2.3.2 读取持久化状态和快照</h3><p><code>readPersist</code>和<code>readSnapshot</code>分别读取持久化状态和快照:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> readPersist(data []<span class="type">byte</span>) &#123;</span><br><span class="line"><span class="comment">// 目前只在Make中调用, 因此不需要锁</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">r := bytes.NewBuffer(data)</span><br><span class="line">d := labgob.NewDecoder(r)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> votedFor <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> currentTerm <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> log []Entry</span><br><span class="line"><span class="keyword">var</span> lastIncludedIndex <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> lastIncludedTerm <span class="type">int</span></span><br><span class="line"><span class="keyword">if</span> d.Decode(&amp;votedFor) != <span class="literal">nil</span> ||</span><br><span class="line">d.Decode(&amp;currentTerm) != <span class="literal">nil</span> ||</span><br><span class="line">d.Decode(&amp;log) != <span class="literal">nil</span> ||</span><br><span class="line">d.Decode(&amp;lastIncludedIndex) != <span class="literal">nil</span> ||</span><br><span class="line">d.Decode(&amp;lastIncludedTerm) != <span class="literal">nil</span> &#123;</span><br><span class="line">DPrintf(<span class="string">&quot;server %v readPersist failed\n&quot;</span>, rf.me)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 2C</span></span><br><span class="line">rf.votedFor = votedFor</span><br><span class="line">rf.currentTerm = currentTerm</span><br><span class="line">rf.log = log</span><br><span class="line"><span class="comment">// 2D</span></span><br><span class="line">rf.lastIncludedIndex = lastIncludedIndex</span><br><span class="line">rf.lastIncludedTerm = lastIncludedTerm</span><br><span class="line"></span><br><span class="line">rf.commitIndex = lastIncludedIndex</span><br><span class="line">rf.lastApplied = lastIncludedIndex</span><br><span class="line">DPrintf(<span class="string">&quot;server %v  readPersist 成功\n&quot;</span>, rf.me)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> readSnapshot(data []<span class="type">byte</span>) &#123;</span><br><span class="line"><span class="comment">// 目前只在Make中调用, 因此不需要锁</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span> &#123;</span><br><span class="line">DPrintf(<span class="string">&quot;server %v 读取快照失败: 无快照\n&quot;</span>, rf.me)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">rf.snapShot = data</span><br><span class="line">DPrintf(<span class="string">&quot;server %v 读取快照c成功\n&quot;</span>, rf.me)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于目前尽在<code>Make</code>函数中调用这两个函数, 此时没有协程在执行, 因此不需要加锁, 需要额外注意的是:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rf.commitIndex = lastIncludedIndex</span><br><span class="line">rf.lastApplied = lastIncludedIndex</span><br></pre></td></tr></table></figure><p>此操作保证了<code>commitIndex</code>和<code>lastApplied</code>的下限, 因为快照包含的索引一定是被提交和应用的, 此操作可以避免后续的索引越界问题</p><h3 id="2-3-3-Make函数修改"><a href="#2-3-3-Make函数修改" class="headerlink" title="2.3.3 Make函数修改"></a>2.3.3 <code>Make</code>函数修改</h3><p>由于初始化状态时, 索引需要变为<code>Virtual Index</code>, 因此需要借助读取的持久化状态, 代码修改如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="type">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span></span> *Raft &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">rf := &amp;Raft&#123;&#125;</span><br><span class="line">rf.peers = peers</span><br><span class="line">rf.persister = persister</span><br><span class="line">rf.me = me</span><br><span class="line"></span><br><span class="line">rf.log = <span class="built_in">make</span>([]Entry, <span class="number">0</span>)</span><br><span class="line">rf.log = <span class="built_in">append</span>(rf.log, Entry&#123;Term: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line">rf.nextIndex = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(peers))</span><br><span class="line">rf.matchIndex = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(peers))</span><br><span class="line">...</span><br><span class="line"><span class="comment">// initialize from state persisted before a crash</span></span><br><span class="line"><span class="comment">// 如果读取成功, 将覆盖log, votedFor和currentTerm</span></span><br><span class="line">rf.readSnapshot(persister.ReadSnapshot())</span><br><span class="line">rf.readPersist(persister.ReadRaftState())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.nextIndex); i++ &#123;</span><br><span class="line">rf.nextIndex[i] = rf.VirtualLogIdx(<span class="built_in">len</span>(rf.log)) <span class="comment">// raft中的index是从1开始的</span></span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果日志和持久化存储为空, 则<code>readSnapshot</code>和<code>readPersist</code>无作用, 初始化过程和以往相同</p><h1 id="3-InstallSnapshot-RPC设计"><a href="#3-InstallSnapshot-RPC设计" class="headerlink" title="3 InstallSnapshot RPC设计"></a>3 <code>InstallSnapshot RPC</code>设计</h1><h2 id="3-1-RPC结构体设计"><a href="#3-1-RPC结构体设计" class="headerlink" title="3.1 RPC结构体设计"></a>3.1 <code>RPC</code>结构体设计</h2><p>先贴上原论文的描述图</p><p><img src="/../../images/InstallSnapshot-RPC.png" alt="InstallSnapshot-RPC"></p><p>根据图中的描述, 设计<code>RPC</code>结构体如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> InstallSnapshotArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Term              <span class="type">int</span>         <span class="comment">// leader’s term</span></span><br><span class="line">LeaderId          <span class="type">int</span>         <span class="comment">// so follower can redirect clients</span></span><br><span class="line">LastIncludedIndex <span class="type">int</span>         <span class="comment">// the snapshot replaces all entries up through and including this index</span></span><br><span class="line">LastIncludedTerm  <span class="type">int</span>         <span class="comment">// term of lastIncludedIndex snapshot file</span></span><br><span class="line">Data              []<span class="type">byte</span>      <span class="comment">//[] raw bytes of the snapshot chunk</span></span><br><span class="line">LastIncludedCmd   <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 自己新加的字段, 用于在0处占位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> InstallSnapshotReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Term <span class="type">int</span> <span class="comment">// currentTerm, for leader to update itself</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意, 由于我的设计中, <code>log</code>数据组索引从1开始, 0索引需要<code>LastIncludedIndex</code>位置的日志项进行占位, 因此我在<code>InstallSnapshotArgs</code>中额外添加了<code>LastIncludedCmd</code>字段以补全这个占位用的日志项</p><h2 id="3-2-InstallSnapshot-RPC发起端设计"><a href="#3-2-InstallSnapshot-RPC发起端设计" class="headerlink" title="3.2 InstallSnapshot RPC发起端设计"></a>3.2 <code>InstallSnapshot RPC</code>发起端设计</h2><h3 id="3-2-1-InstallSnapshot-RPC发送时机"><a href="#3-2-1-InstallSnapshot-RPC发送时机" class="headerlink" title="3.2.1 InstallSnapshot RPC发送时机"></a>3.2.1 <code>InstallSnapshot RPC</code>发送时机</h3><p>阅读论文可知, 当<code>Leader</code>发现<code>Follower</code>要求回退的日志已经被<code>SnapShot</code>截断时, 需要发生<code>InstallSnapshot RPC</code>, 在我设计的代码中, 以下2个场景会出现:</p><h4 id="3-2-1-1-心跳发送函数发起"><a href="#3-2-1-1-心跳发送函数发起" class="headerlink" title="3.2.1.1 心跳发送函数发起"></a>3.2.1.1 心跳发送函数发起</h4><p><code>SendHeartBeats</code>发现<code>PrevLogIndex &lt; lastIncludedIndex</code>, 表示其要求的日志项已经被截断, 需要改发送心跳为发送<code>InstallSnapshot RPC</code></p><p>代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> SendHeartBeats() &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line">...</span><br><span class="line">args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">Term:         rf.currentTerm,</span><br><span class="line">LeaderId:     rf.me,</span><br><span class="line">PrevLogIndex: rf.nextIndex[i] - <span class="number">1</span>,</span><br><span class="line">LeaderCommit: rf.commitIndex,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sendInstallSnapshot := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.PrevLogIndex &lt; rf.lastIncludedIndex &#123;</span><br><span class="line"><span class="comment">// 表示Follower有落后的部分且被截断, 改为发送同步心跳</span></span><br><span class="line">DPrintf(<span class="string">&quot;leader %v 取消向 server %v 广播新的心跳, 改为发送sendInstallSnapshot, lastIncludedIndex=%v, nextIndex[%v]=%v, args = %+v \n&quot;</span>, rf.me, i, rf.lastIncludedIndex, i, rf.nextIndex[i], args)</span><br><span class="line">sendInstallSnapshot = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> rf.VirtualLogIdx(<span class="built_in">len</span>(rf.log)<span class="number">-1</span>) &gt; args.PrevLogIndex &#123;</span><br><span class="line"><span class="comment">// 如果有新的log需要发送, 则就是一个真正的AppendEntries而不是心跳</span></span><br><span class="line">args.Entries = rf.log[rf.RealLogIdx(args.PrevLogIndex+<span class="number">1</span>):]</span><br><span class="line">DPrintf(<span class="string">&quot;leader %v 开始向 server %v 广播新的AppendEntries, lastIncludedIndex=%v, nextIndex[%v]=%v, args = %+v\n&quot;</span>, rf.me, i, rf.lastIncludedIndex, i, rf.nextIndex[i], args)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果没有新的log发送, 就发送一个长度为0的切片, 表示心跳</span></span><br><span class="line">DPrintf(<span class="string">&quot;leader %v 开始向 server %v 广播新的心跳, lastIncludedIndex=%v, nextIndex[%v]=%v, args = %+v \n&quot;</span>, rf.me, i, rf.lastIncludedIndex, i, rf.nextIndex[i], args)</span><br><span class="line">args.Entries = <span class="built_in">make</span>([]Entry, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sendInstallSnapshot &#123;</span><br><span class="line"><span class="keyword">go</span> rf.handleInstallSnapshot(i)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">args.PrevLogTerm = rf.log[rf.RealLogIdx(args.PrevLogIndex)].Term</span><br><span class="line"><span class="keyword">go</span> rf.handleAppendEntries(i, args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-1-2-心跳回复处理函数发起"><a href="#3-2-1-2-心跳回复处理函数发起" class="headerlink" title="3.2.1.2 心跳回复处理函数发起"></a>3.2.1.2 心跳回复处理函数发起</h4><p><code>handleAppendEntries</code>检查心跳(和<code>AppendEntries</code>是一致的)<code>RPC</code>的回复, 并进行相应的回退, 如果发现已经回退到<code>lastIncludedIndex</code>还不能满足要求, 就需要发送<code>InstallSnapshot RPC</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> handleAppendEntries(serverTo <span class="type">int</span>, args *AppendEntriesArgs) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> reply.Term == rf.currentTerm &amp;&amp; rf.role == Leader &#123;</span><br><span class="line"><span class="comment">// term仍然相同, 且自己还是leader, 表名对应的follower在prevLogIndex位置没有与prevLogTerm匹配的项</span></span><br><span class="line"><span class="comment">// 快速回退的处理</span></span><br><span class="line"><span class="keyword">if</span> reply.XTerm == <span class="number">-1</span> &#123;</span><br><span class="line"><span class="comment">// PrevLogIndex这个位置在Follower中不存在</span></span><br><span class="line">DPrintf(<span class="string">&quot;leader %v 收到 server %v 的回退请求, 原因是log过短, 回退前的nextIndex[%v]=%v, 回退后的nextIndex[%v]=%v\n&quot;</span>, rf.me, serverTo, serverTo, rf.nextIndex[serverTo], serverTo, reply.XLen)</span><br><span class="line"><span class="keyword">if</span> rf.lastIncludedIndex &gt;= reply.XLen &#123;</span><br><span class="line"><span class="comment">// 由于snapshot被截断</span></span><br><span class="line"><span class="comment">// 添加InstallSnapshot的处理</span></span><br><span class="line"><span class="keyword">go</span> rf.handleInstallSnapshot(serverTo)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rf.nextIndex[serverTo] = reply.XLen</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i := rf.nextIndex[serverTo] - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i &lt; rf.lastIncludedIndex &#123;</span><br><span class="line">i = rf.lastIncludedIndex</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i &gt; rf.lastIncludedIndex &amp;&amp; rf.log[rf.RealLogIdx(i)].Term &gt; reply.XTerm &#123;</span><br><span class="line">i -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i == rf.lastIncludedIndex &amp;&amp; rf.log[rf.RealLogIdx(i)].Term &gt; reply.XTerm &#123;</span><br><span class="line"><span class="comment">// 要找的位置已经由于snapshot被截断</span></span><br><span class="line"><span class="comment">// 添加InstallSnapshot的处理</span></span><br><span class="line"><span class="keyword">go</span> rf.handleInstallSnapshot(serverTo)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> rf.log[rf.RealLogIdx(i)].Term == reply.XTerm &#123;</span><br><span class="line"><span class="comment">// 之前PrevLogIndex发生冲突位置时, Follower的Term自己也有</span></span><br><span class="line"></span><br><span class="line">DPrintf(<span class="string">&quot;leader %v 收到 server %v 的回退请求, 冲突位置的Term为%v, server的这个Term从索引%v开始, 而leader对应的最后一个XTerm索引为%v, 回退前的nextIndex[%v]=%v, 回退后的nextIndex[%v]=%v\n&quot;</span>, rf.me, serverTo, reply.XTerm, reply.XIndex, i, serverTo, rf.nextIndex[serverTo], serverTo, i+<span class="number">1</span>)</span><br><span class="line">rf.nextIndex[serverTo] = i + <span class="number">1</span> <span class="comment">// i + 1是确保没有被截断的</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 之前PrevLogIndex发生冲突位置时, Follower的Term自己没有</span></span><br><span class="line">DPrintf(<span class="string">&quot;leader %v 收到 server %v 的回退请求, 冲突位置的Term为%v, server的这个Term从索引%v开始, 而leader对应的XTerm不存在, 回退前的nextIndex[%v]=%v, 回退后的nextIndex[%v]=%v\n&quot;</span>, rf.me, serverTo, reply.XTerm, reply.XIndex, serverTo, rf.nextIndex[serverTo], serverTo, reply.XIndex)</span><br><span class="line"><span class="keyword">if</span> reply.XIndex &lt;= rf.lastIncludedIndex &#123;</span><br><span class="line"><span class="comment">// XIndex位置也被截断了</span></span><br><span class="line"><span class="comment">// 添加InstallSnapshot的处理</span></span><br><span class="line"><span class="keyword">go</span> rf.handleInstallSnapshot(serverTo)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rf.nextIndex[serverTo] = reply.XIndex</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会有3个情况触发发送<code>InstallSnapshot RPC</code>:</p><ol><li><code>Follower</code>的日志过短(<code>PrevLogIndex</code>这个位置在Follower中不存在), 甚至短于<code>lastIncludedIndex</code></li><li><code>Follower</code>的日志在<code>PrevLogIndex</code>这个位置发生了冲突, 回退时发现即使到了<code>lastIncludedIndex</code>也找不到匹配项(大于或小于这个<code>Xterm</code>)</li><li><code>nextIndex</code>中记录的索引本身就小于<code>lastIncludedIndex</code></li></ol><p>前2个情况很容易想到, 但第3个情况容易被忽视(单次运行测例很容易测不出这种情况, 需要多次运行测例)</p><h3 id="3-2-2-InstallSnapshot发送"><a href="#3-2-2-InstallSnapshot发送" class="headerlink" title="3.2.2 InstallSnapshot发送"></a>3.2.2 <code>InstallSnapshot</code>发送</h3><p>这里的实现相对简单, 只要构造相应的请求结构体即可, 但需要注意:</p><ol><li>需要额外发生<code>Cmd</code>字段, 因为构造0索引时的占位日志项, 尽管其已经被包含在了快照中</li><li>发送<code>RPC</code>时不要持有锁</li><li>发送成功后, 需要将<code>nextIndex</code>设置为<code>VirtualLogIdx(1)</code>, 因为0索引处是占位, 其余的部分已经不需要再发送了</li><li>和心跳一样, 需要根据回复检查自己是不是旧<code>Leader</code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> handleInstallSnapshot(serverTo <span class="type">int</span>) &#123;</span><br><span class="line">reply := &amp;InstallSnapshotReply&#123;&#125;</span><br><span class="line"></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="comment">// DPrintf(&quot;server %v handleInstallSnapshot 获取锁mu&quot;, rf.me)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rf.role != Leader &#123;</span><br><span class="line"><span class="comment">// 自己已经不是Lader了, 返回</span></span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">args := &amp;InstallSnapshotArgs&#123;</span><br><span class="line">Term:              rf.currentTerm,</span><br><span class="line">LeaderId:          rf.me,</span><br><span class="line">LastIncludedIndex: rf.lastIncludedIndex,</span><br><span class="line">LastIncludedTerm:  rf.lastIncludedTerm,</span><br><span class="line">Data:              rf.snapShot,</span><br><span class="line">LastIncludedCmd:   rf.log[<span class="number">0</span>].Cmd,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"><span class="comment">// DPrintf(&quot;server %v handleInstallSnapshot 释放锁mu&quot;, rf.me)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送RPC时不要持有锁</span></span><br><span class="line">ok := rf.sendInstallSnapshot(serverTo, args, reply)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="comment">// RPC发送失败, 下次再触发即可</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="comment">// DPrintf(&quot;server %v handleInstallSnapshot 获取锁mu&quot;, rf.me)</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// DPrintf(&quot;server %v handleInstallSnapshot 释放锁mu&quot;, rf.me)</span></span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line"><span class="comment">// 自己是旧Leader</span></span><br><span class="line">rf.currentTerm = reply.Term</span><br><span class="line">rf.role = Follower</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">rf.ResetTimer()</span><br><span class="line">rf.persist()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.nextIndex[serverTo] = rf.VirtualLogIdx(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-2-3-InstallSnapshot响应"><a href="#3-2-3-InstallSnapshot响应" class="headerlink" title="3.2.3 InstallSnapshot响应"></a>3.2.3 <code>InstallSnapshot</code>响应</h3><p><code>InstallSnapshot</code>响应需要考虑更多的边界情况:</p><ol><li>如果是旧<code>leader</code>, 拒绝</li><li>如果<code>Term</code>更大, 证明这是新的<code>Leader</code>, 需要更改自身状态, 但不影响继续接收快照</li><li>如果<code>LastIncludedIndex</code>位置的日志项存在, 即尽管需要创建快照, 但并不导致自己措施日志项, 只需要截断日志数组即可</li><li>如果<code>LastIncludedIndex</code>位置的日志项不存在, 需要清空切片, 并将0位置构造<code>LastIncludedIndex</code>位置的日志项进行占位</li><li>需要检查<code>lastApplied</code>和<code>commitIndex</code> 是否小于<code>LastIncludedIndex</code>, 如果是, 更新为<code>LastIncludedIndex</code></li><li>完成上述操作后, 需要将快照发送到<code>service</code>层</li><li>由于<code>InstallSnapshot</code>可能是替代了一次心跳函数, 因此需要重设定时器</li></ol><blockquote><p>第5, 7点最容易被忽略, 因此代码里需要提供足够的日志信息来协助debug</p></blockquote><p>代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InstallSnapshot handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="comment">// DPrintf(&quot;server %v InstallSnapshot 获取锁mu&quot;, rf.me)</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">rf.ResetTimer()</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">DPrintf(<span class="string">&quot;server %v 接收到 leader %v 的InstallSnapshot, 重设定时器&quot;</span>, rf.me, args.LeaderId)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Reply immediately if term &lt; currentTerm</span></span><br><span class="line"><span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">DPrintf(<span class="string">&quot;server %v 拒绝来自 %v 的 InstallSnapshot, 更小的Term\n&quot;</span>, rf.me, args.LeaderId)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不需要实现分块的RPC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">rf.currentTerm = args.Term</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">DPrintf(<span class="string">&quot;server %v 接受来自 %v 的 InstallSnapshot, 且发现了更大的Term\n&quot;</span>, rf.me, args.LeaderId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.role = Follower</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. If existing log entry has same index and term as snapshot’s last included entry, retain log entries following it and reply</span></span><br><span class="line">hasEntry := <span class="literal">false</span></span><br><span class="line">rIdx := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; rIdx &lt; <span class="built_in">len</span>(rf.log); rIdx++ &#123;</span><br><span class="line"><span class="keyword">if</span> rf.VirtualLogIdx(rIdx) == args.LastIncludedIndex &amp;&amp; rf.log[rIdx].Term == args.LastIncludedTerm &#123;</span><br><span class="line">hasEntry = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg := &amp;ApplyMsg&#123;</span><br><span class="line">SnapshotValid: <span class="literal">true</span>,</span><br><span class="line">Snapshot:      args.Data,</span><br><span class="line">SnapshotTerm:  args.LastIncludedTerm,</span><br><span class="line">SnapshotIndex: args.LastIncludedIndex,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> hasEntry &#123;</span><br><span class="line">DPrintf(<span class="string">&quot;server %v InstallSnapshot: args.LastIncludedIndex= %v 位置存在, 保留后面的log\n&quot;</span>, rf.me, args.LastIncludedIndex)</span><br><span class="line"></span><br><span class="line">rf.log = rf.log[rIdx:]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">DPrintf(<span class="string">&quot;server %v InstallSnapshot: 清空log\n&quot;</span>, rf.me)</span><br><span class="line">rf.log = <span class="built_in">make</span>([]Entry, <span class="number">0</span>)</span><br><span class="line">rf.log = <span class="built_in">append</span>(rf.log, Entry&#123;Term: rf.lastIncludedTerm, Cmd: args.LastIncludedCmd&#125;) <span class="comment">// 索引为0处占位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. Discard the entire log</span></span><br><span class="line"><span class="comment">// 8. Reset state machine using snapshot contents (and load snapshot’s cluster configuration)</span></span><br><span class="line"></span><br><span class="line">rf.snapShot = args.Data</span><br><span class="line">rf.lastIncludedIndex = args.LastIncludedIndex</span><br><span class="line">rf.lastIncludedTerm = args.LastIncludedTerm</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rf.commitIndex &lt; args.LastIncludedIndex &#123;</span><br><span class="line">rf.commitIndex = args.LastIncludedIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rf.lastApplied &lt; args.LastIncludedIndex &#123;</span><br><span class="line">rf.lastApplied = args.LastIncludedIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">rf.applyCh &lt;- *msg</span><br><span class="line">rf.persist()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-其他边界情况与bug修复"><a href="#4-其他边界情况与bug修复" class="headerlink" title="4 其他边界情况与bug修复"></a>4 其他边界情况与bug修复</h1><h2 id="4-1-并发优化"><a href="#4-1-并发优化" class="headerlink" title="4.1 并发优化"></a>4.1 并发优化</h2><p>这里指的并发优化专指<code>CommitChecker</code>函数, 这个函数是单独的一个协程运行, 不断地将需要应用的日志发送到应用层。 </p><p>但在我完成前3节的任务后, 运行测例发现最基本的<code>TestSnapshotBasic2D</code>出现了永久运行但不成功输出结果情况, 观察日志后发现，<code>Snapshot</code>函数获永久地阻塞在获取锁的代码上, 而上一个获取锁的函数正是<code>CommitChecker</code>函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> CommitChecker() &#123;</span><br><span class="line"><span class="comment">// 检查是否有新的commit</span></span><br><span class="line"><span class="comment">// DPrintf(&quot;server %v 的 CommitChecker 开始运行&quot;, rf.me)</span></span><br><span class="line"><span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">for</span> rf.commitIndex &lt;= rf.lastApplied &#123;</span><br><span class="line">rf.condApply.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> rf.commitIndex &gt; rf.lastApplied &#123;</span><br><span class="line">rf.lastApplied += <span class="number">1</span></span><br><span class="line">msg := &amp;ApplyMsg&#123;</span><br><span class="line">CommandValid: <span class="literal">true</span>,</span><br><span class="line">Command:      rf.log[rf.lastApplied].Cmd,</span><br><span class="line">CommandIndex: rf.lastApplied,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DPrintf(&quot;server %v 准备commit, log = %v:%v&quot;, rf.me, rf.lastApplied, rf.log[rf.lastApplied].Cmd)</span></span><br><span class="line">rf.applyCh &lt;- *msg</span><br><span class="line"><span class="comment">// DPrintf(&quot;server %v 准备将命令 %v(索引为 %v ) 应用到状态机\n&quot;, rf.me, msg.Command, msg.CommandIndex)</span></span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察代码可知, 原来的实现中, 将<code>commitIndex</code>和<code>lastApplied</code>之间的所有日志项发送到<code>applyCh</code>进行应用时, 全阶段都是持有锁的状态, 而<code>applyCh</code>通道可能长时间阻塞, 因此出现了上述的<strong>死锁</strong>现象。</p><p>解决方案是，先将要发送的<code>msg</code>缓存到一个切片后, 然后释放锁以避免死锁, 再发送到<code>applyCh</code>中, 因此不难写出下面的代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> CommitChecker() &#123;</span><br><span class="line"><span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="comment">// DPrintf(&quot;server %v CommitChecker 获取锁mu&quot;, rf.me)</span></span><br><span class="line"><span class="keyword">for</span> rf.commitIndex &lt;= rf.lastApplied &#123;</span><br><span class="line">rf.condApply.Wait()</span><br><span class="line">&#125;</span><br><span class="line">msgBuf := <span class="built_in">make</span>([]*ApplyMsg, <span class="number">0</span>, rf.commitIndex-rf.lastApplied)</span><br><span class="line"><span class="keyword">for</span> rf.commitIndex &gt; rf.lastApplied &#123;</span><br><span class="line">rf.lastApplied += <span class="number">1</span></span><br><span class="line">msg := &amp;ApplyMsg&#123;</span><br><span class="line">CommandValid: <span class="literal">true</span>,</span><br><span class="line">Command:      rf.log[rf.RealLogIdx(rf.lastApplied)].Cmd,</span><br><span class="line">CommandIndex: rf.lastApplied,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msgBuf = <span class="built_in">append</span>(msgBuf, msg)</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"><span class="comment">// DPrintf(&quot;server %v CommitChecker 释放锁mu&quot;, rf.me)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, msg := <span class="keyword">range</span> msgBuf &#123;</span><br><span class="line"><span class="comment">// DPrintf(&quot;server %v 准备commit, log = %v:%v&quot;, rf.me, rf.lastApplied, rf.log[rf.lastApplied].Cmd)</span></span><br><span class="line">rf.applyCh &lt;- *msg</span><br><span class="line"><span class="comment">// DPrintf(&quot;server %v 准备将命令 %v(索引为 %v ) 应用到状态机\n&quot;, rf.me, msg.Command, msg.CommandIndex)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码看齐来没有问题, 但是实际运行测例时发现, 仍然会出现与预期不一样的要<code>apply</code>的日志项, 原因在于高并发场景下, 执行<code>rf.mu.Unlock()</code>释放锁后, 可能切换到了<code>InstallSnapshot</code>响应函数, 并更新了<code>lastApplied</code>, 这也意味着, 之后发送到<code>applyCh</code>要应用的日志项已经包含在了快照中, 再次应用这个已经包含在了快照中的日志项是不合理的, 因此还需要再次进行检查:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> CommitChecker() &#123;</span><br><span class="line"><span class="comment">// 检查是否有新的commit</span></span><br><span class="line"><span class="comment">// DPrintf(&quot;server %v 的 CommitChecker 开始运行&quot;, rf.me)</span></span><br><span class="line"><span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="comment">// DPrintf(&quot;server %v CommitChecker 获取锁mu&quot;, rf.me)</span></span><br><span class="line"><span class="keyword">for</span> rf.commitIndex &lt;= rf.lastApplied &#123;</span><br><span class="line">rf.condApply.Wait()</span><br><span class="line">&#125;</span><br><span class="line">msgBuf := <span class="built_in">make</span>([]*ApplyMsg, <span class="number">0</span>, rf.commitIndex-rf.lastApplied)</span><br><span class="line">tmpApplied := rf.lastApplied</span><br><span class="line"><span class="keyword">for</span> rf.commitIndex &gt; tmpApplied &#123;</span><br><span class="line">tmpApplied += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> tmpApplied &lt;= rf.lastIncludedIndex &#123;</span><br><span class="line"><span class="comment">// tmpApplied可能是snapShot中已经被截断的日志项, 这些日志项就不需要再发送了</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">msg := &amp;ApplyMsg&#123;</span><br><span class="line">CommandValid: <span class="literal">true</span>,</span><br><span class="line">Command:      rf.log[rf.RealLogIdx(tmpApplied)].Cmd,</span><br><span class="line">CommandIndex: tmpApplied,</span><br><span class="line">SnapshotTerm: rf.log[rf.RealLogIdx(tmpApplied)].Term,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msgBuf = <span class="built_in">append</span>(msgBuf, msg)</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"><span class="comment">// DPrintf(&quot;server %v CommitChecker 释放锁mu&quot;, rf.me)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意, 在解锁后可能又出现了SnapShot进而修改了rf.lastApplied</span></span><br><span class="line"><span class="keyword">for</span> _, msg := <span class="keyword">range</span> msgBuf &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> msg.CommandIndex != rf.lastApplied+<span class="number">1</span> &#123;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">DPrintf(<span class="string">&quot;server %v 准备commit, log = %v:%v, lastIncludedIndex=%v&quot;</span>, rf.me, msg.CommandIndex, msg.SnapshotTerm, rf.lastIncludedIndex)</span><br><span class="line"></span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"><span class="comment">// 注意, 在解锁后可能又出现了SnapShot进而修改了rf.lastApplied</span></span><br><span class="line"></span><br><span class="line">rf.applyCh &lt;- *msg</span><br><span class="line"></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> msg.CommandIndex != rf.lastApplied+<span class="number">1</span> &#123;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">rf.lastApplied = msg.CommandIndex</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上这个代码在发送消息后再次检查了<code>lastApplied</code>, 对于通过测例已经没有问题了, 但还是存在这样的问题:<br>在一个极端情况下的并发场景下,在 <code>rf.applyCh &lt;- *msg</code> 执行之前，即在 <code>rf.mu.Unlock()</code> 与 <code>rf.applyCh &lt;- *msg</code> 之间的时间窗口内，发生了接收快照的操作，导致 <code>rf.lastApplied</code> 被修改，那么 <code>msg</code> 可能就不再是应该应用的消息。对于这个问题, 持有锁发送能保证线程安全, 但实际上会导致死锁, 目前这个潜在的bug暂且搁置…</p><h2 id="4-2-新Leader的初始化"><a href="#4-2-新Leader的初始化" class="headerlink" title="4.2 新Leader的初始化"></a>4.2 新<code>Leader</code>的初始化</h2><p>新<code>Leader</code>需要对<code>nextIndex</code>和<code>matchIndex</code>进行如下初始化:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.nextIndex); i++ &#123;</span><br><span class="line">rf.nextIndex[i] = rf.VirtualLogIdx(<span class="built_in">len</span>(rf.log))</span><br><span class="line">rf.matchIndex[i] = rf.lastIncludedIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>lastIncludedIndex</code>保证不高于<code>commitIndex</code>, 因此其<code>matchIndex</code>至少设置为<code>matchIndex</code>是合理的, 这会加速正确的<code>commitIndex</code>的恢复</p><h2 id="4-3-常见数组索引越界原因"><a href="#4-3-常见数组索引越界原因" class="headerlink" title="4.3 常见数组索引越界原因"></a>4.3 常见数组索引越界原因</h2><p>在我调试代码的过程中, 发现了很多次数组索引越界, 而且写代码时很多数组索引越界的原因并没有记录在<code>git commit</code>中, 因此无法逐一提及, (<em>自己也忘了</em>), 但索引越界的原因大多是差不多的, 总结如下:</p><ol><li>快照接收时, 没有检查<code>commitIndex</code></li><li>快照接收时, 没有检查<code>lastApplied</code></li><li>没有进行索引转化</li><li>没有设置<code>lastIncludedIndex</code>为<code>for</code>循环的下限, 例如确定<code>N</code>时的<code>for</code>循环</li><li>新的<code>Leader</code>没有使用索引转化进行<code>nextIndex</code>和<code>matchIndex</code>的初始化</li></ol><h1 id="5-测试"><a href="#5-测试" class="headerlink" title="5 测试"></a>5 测试</h1><h2 id="5-1-常规测试"><a href="#5-1-常规测试" class="headerlink" title="5.1 常规测试"></a>5.1 常规测试</h2><blockquote><p>如果使用 -race的话需要注释掉所有的<code>DPrintf</code>, 因为在输出日志时并没有仔细考虑线程同步的问题, 可能引起数据竞争, 除<code>DPrintf</code>的其他的部分我自己检查是不存在数据竞争的</p></blockquote><p>执行测试命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -v -run 2D</span><br></pre></td></tr></table></figure><p>结果如下:</p><p><img src="/../../images/lab2D-test1.png" alt="lab2D-test1"></p><p>用时230s, 快于官方的293s, 还可以</p><h2 id="5-2-多次测试"><a href="#5-2-多次测试" class="headerlink" title="5.2 多次测试"></a>5.2 多次测试</h2><p><code>raft</code>的许多特性导致其一次测试并不准确, 有些bug需要多次测试才会出现, 编写如下脚本命名为<code>manyTest_2D.sh</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化计数器</span></span><br><span class="line">count=0</span><br><span class="line">success_count=0</span><br><span class="line">fail_count=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置测试次数</span></span><br><span class="line">max_tests=50</span><br><span class="line"></span><br><span class="line">for ((i=1; i&lt;=max_tests; i++))</span><br><span class="line">do</span><br><span class="line">    echo &quot;Running test iteration $i of $max_tests...&quot;</span><br><span class="line"></span><br><span class="line">    # 运行 go 测试命令</span><br><span class="line">    go test -v -run 2D &amp;&gt; output2D.log</span><br><span class="line"></span><br><span class="line">    # 检查 go 命令的退出状态</span><br><span class="line">    if [ &quot;$?&quot; -eq 0 ]; then</span><br><span class="line">        # 测试成功</span><br><span class="line">        success_count=$((success_count+1))</span><br><span class="line">        echo &quot;Test iteration $i passed.&quot;</span><br><span class="line">        # 如果想保存通过的测试日志，取消下面行的注释</span><br><span class="line">        # mv output2D.log &quot;success_$i.log&quot;</span><br><span class="line">    else</span><br><span class="line">        # 测试失败</span><br><span class="line">        fail_count=$((fail_count+1))</span><br><span class="line">        echo &quot;Test iteration $i failed, check &#x27;failure2D_$i.log&#x27; for details.&quot;</span><br><span class="line">        mv output2D.log &quot;failure2D_$i.log&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">报告测试结果</span></span><br><span class="line">echo &quot;Testing completed: $max_tests iterations run.&quot;</span><br><span class="line">echo &quot;Successes: $success_count&quot;</span><br><span class="line">echo &quot;Failures: $fail_count&quot;</span><br></pre></td></tr></table></figure><p>再次进行测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./manyTest_2D.sh</span><br></pre></td></tr></table></figure><p>结果:</p><p><img src="/../../images/lab2D-test2.png" alt="lab2D-test2"></p><h2 id="5-3-lab2完整测试"><a href="#5-3-lab2完整测试" class="headerlink" title="5.3 lab2完整测试"></a>5.3 <code>lab</code>2完整测试</h2><p>执行测试命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -run 2</span><br></pre></td></tr></table></figure><p>结果如下:</p><p><img src="/../../images/lab2-test.png" alt="lab2-test"></p><p>耗时444s, 和文档要求的6分钟da</p><h1 id="6-lab2总结"><a href="#6-lab2总结" class="headerlink" title="6 lab2总结"></a>6 lab2总结</h1><p><code>lab2</code>是一个相对庞大且复杂的实验, 难度相对<code>lab1</code>大很多, 而且<code>lab2</code>需要考虑的边界条件更多, 并发场景更加复杂。</p><ol><li><p>复杂的并发场景<br>实现<code>raft</code>的过程中, 代码语法方面的错误是相对容易<code>debug</code>的, 但难以<code>debug</code>是忽略高并发场景下各种边界条件处理的逻辑<code>bug</code></p></li><li><p>阅读原论文的重要性<br>实现<code>raft</code>时, 吃透论文是十分重要的, 我在做<code>lab</code>前通读了一遍论文, 有些细节不太理解, 做<code>lab</code>过程中还再次阅读了论文</p></li><li><p>日志调试的重要性<br>适当的日志输出是解决测例<code>bug</code>最有效的方法, 日志输出应当详略得当, 提供有效信息而忽略一些垃圾信息, 比如我是在加锁时输出日志才定位到了<code>CommitChecker</code>函数的死锁问题, 此时需要关闭其他如心跳的无关输出以避免日志混乱</p></li></ol><hr><p>终于从头到尾实现了<code>raft</code>, 尽管性能也就那样, 自己的代码还是写得太乱, 但成就感还是满满的!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将介绍&lt;code&gt;lab2D&lt;/code&gt;部分的实现, &lt;code&gt;lab2D&lt;/code&gt;要求实现&lt;code&gt;raft&lt;/code&gt;中的快照功能。从个人体验而言, &lt;code&gt;lab2D&lt;/code&gt;是目前所有&lt;code&gt;Lab&lt;/code&gt;中最难的一个, 各种边界情</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="Lab笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/Lab%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Go" scheme="http://example.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.5840(6.824) Lab2: Raft 2C</title>
    <link href="http://example.com/2024/01/13/MIT6.5840/Lab2C/"/>
    <id>http://example.com/2024/01/13/MIT6.5840/Lab2C/</id>
    <published>2024-01-13T09:15:38.000Z</published>
    <updated>2024-02-27T06:02:43.809Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍<code>lab2C</code>部分的实现, <code>lab2C</code>要求实现<code>raft</code>中的持久化功能, 相比<code>lab2A</code>,和<code>lab2B</code>, 本节的难度其实很小, 但复杂的是<code>lab2A</code>,和<code>lab2B</code>中的一些微小的<code>bug</code>会在<code>2C</code>中显现, 并且相对不太容易注意到。</p><p><code>Lab文档</code>见: <a href="https://pdos.csail.mit.edu/6.824/labs/lab-raft.html">https://pdos.csail.mit.edu/6.824/labs/lab-raft.html</a></p><p>我的代码: <a href="https://github.com/ToniXWD/MIT6.5840/tree/lab2C">https://github.com/ToniXWD/MIT6.5840/tree/lab2C</a></p><p><a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">raft原论文</a></p><h1 id="1-bug修复：重复的RPC"><a href="#1-bug修复：重复的RPC" class="headerlink" title="1 bug修复：重复的RPC"></a>1 <code>bug</code>修复：重复的<code>RPC</code></h1><p>在之前的<code>AppendEntries</code>中有这样的代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args.Entries) != <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(rf.log) &gt; args.PrevLogIndex+<span class="number">1</span> &amp;&amp; rf.log[args.PrevLogIndex+<span class="number">1</span>].Term != args.Entries[<span class="number">0</span>].Term &#123;</span><br><span class="line">    <span class="comment">// 发生了冲突, 移除冲突位置开始后面所有的内容</span></span><br><span class="line">    DPrintf(<span class="string">&quot;server %v 的log与args发生冲突, 进行移除\n&quot;</span>, rf.me)</span><br><span class="line">    rf.log = rf.log[:args.PrevLogIndex+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">rf.log = <span class="built_in">append</span>(rf.log, args.Entries...)</span><br></pre></td></tr></table></figure><p>这段代码所做的事情是, 如果将要追加的位置存在日志项, 且日志项与<code>RPC</code>中的日子切片的第一个发生冲突(<code>Term</code>不匹配), 则将冲突位置及其之后的日志项清除掉。</p><p>这段代码看起来没有问题，但在高并发的场景下，会存在如下问题:</p><ol><li><code>Leader</code>先发送了<code>AppendEntries RPC</code>, 我们记为<code>RPC1</code></li><li><code>Follower</code>收到<code>RPC1</code>, 发生上述代码描述的冲突, 将冲突部分的内容清除, 并追加<code>RPC1</code>中的日志切片</li><li>由于并发程度高, <code>Leader</code>在<code>RPC1</code>没有收到回复时又发送了下一个<code>AppendEntries RPC</code>, 由于<code>nextIndex</code>和<code>matchIndex</code>只有在收到回复后才会修改, 因此这个新的<code>AppendEntries RPC</code>, 我们记为<code>RPC2</code>, 与<code>RPC1</code>是一致的</li><li><code>Follower</code>收到<code>RPC2</code>, 由于<code>RPC2</code>和<code>RPC1</code>完全相同, 因此其一定不会发生冲突, 结果是<code>Follower</code>将相同的一个日志项切片追加了2次!</li></ol><p>在考虑另一个场景:</p><ol><li><code>Leader</code>先发送了<code>AppendEntries RPC</code>, 我们记为<code>RPC1</code></li><li>由于网络问题, <code>RPC1</code>没有即时到达<code>Follower</code></li><li><code>Leader</code>又追加了新的<code>log</code>, 此时又发送了<code>AppendEntries RPC</code>, 我们记为<code>RPC2</code></li><li>由于网络问题, 后发送的<code>RPC2</code>先到达<code>Follower</code>, <code>Follower</code>把<code>RPC2</code>的日志项追加</li><li>此时<code>RPC1</code>到达了<code>Follower</code>, <code>Follower</code>把<code>RPC1</code>的日志项强行追加时将导致<code>log</code>被缩短</li></ol><p><strong>解决方案:</strong><br>也就是说, 除了考虑冲突外, 还需要考虑重复的<code>RPC</code>以及顺序颠倒的<code>RPC</code>, 因此需要检查每个位置的<code>log</code>是否匹配, 不匹配就覆盖, 否则不做更改。</p><p>这样对于重复的<code>RPC</code>就不会重复追加， 并且如果<code>RPC</code>顺序颠倒，也就是让<code>Leader</code>多通过一次心跳同步</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, log := <span class="keyword">range</span> args.Entries &#123;</span><br><span class="line">ridx := args.PrevLogIndex + <span class="number">1</span> + idx</span><br><span class="line"><span class="keyword">if</span> ridx &lt; <span class="built_in">len</span>(rf.log) &amp;&amp; rf.log[ridx].Term != log.Term &#123;</span><br><span class="line"><span class="comment">// 某位置发生了冲突, 覆盖这个位置开始的所有内容</span></span><br><span class="line">rf.log = rf.log[:ridx]</span><br><span class="line">rf.log = <span class="built_in">append</span>(rf.log, args.Entries[idx:]...)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ridx == <span class="built_in">len</span>(rf.log) &#123;</span><br><span class="line"><span class="comment">// 没有发生冲突但长度更长了, 直接拼接</span></span><br><span class="line">rf.log = <span class="built_in">append</span>(rf.log, args.Entries[idx:]...)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的bug是完成<code>lab3</code>后才发现的<code>bug</code>, <code>lab2</code>分支的代码还没有进行这样的修改也能通过测例。原因是在我的设计中，<code>Start</code>并没有立即广播心跳, 因此不会存在<code>RPC</code>顺序颠倒的情况, 如果想看最新的代码修改, 参见: <a href="https://github.com/ToniXWD/MIT6.5840/blob/lab3A/src/raft/raft.go#L606">https://github.com/ToniXWD/MIT6.5840/blob/lab3A/src/raft/raft.go#L606</a></p></blockquote><h1 id="2-优化-快速回退"><a href="#2-优化-快速回退" class="headerlink" title="2 优化: 快速回退"></a>2 优化: 快速回退</h1><p>在之前的回退实现中, 如果有<code>Follower</code>的日志不匹配, 每次<code>RPC</code>中, <code>Leader</code>会将其<code>nextIndex</code>自减1来重试, 但其在某些情况下会导致效率很低, 因此需要<code>AppendEntries RPC</code>的回复信息携带更多的字段以加速回退, 核心思想就是:<strong><code>Follower</code>返回更多信息给<code>Leader</code>，使其可以以<code>Term</code>为单位来回退</strong></p><p>教授在课堂上已经介绍了快速回退的实现机制, 可以看我整理的<a href="/2024/01/12/MIT6.5840/Lec06%E7%AC%94%E8%AE%B0/">笔记</a> </p><p>我的实现和课堂的介绍基本一致, 只是将<code>XLen</code>从<code>空白的Log槽位数</code>改为<code>Log的长度</code>:</p><h2 id="2-1-结构体定义"><a href="#2-1-结构体定义" class="headerlink" title="2.1 结构体定义"></a>2.1 结构体定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendEntriesReply <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your data here (2A).</span></span><br><span class="line">Term    <span class="type">int</span>  <span class="comment">// currentTerm, for leader to update itself</span></span><br><span class="line">Success <span class="type">bool</span> <span class="comment">// true if follower contained entry matching prevLogIndex and prevLogTerm</span></span><br><span class="line">XTerm   <span class="type">int</span>  <span class="comment">// Follower中与Leader冲突的Log对应的Term</span></span><br><span class="line">XIndex  <span class="type">int</span>  <span class="comment">// Follower中，对应Term为XTerm的第一条Log条目的索引</span></span><br><span class="line">XLen    <span class="type">int</span>  <span class="comment">// Follower的log的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-Follower侧的AppendEntries"><a href="#2-2-Follower侧的AppendEntries" class="headerlink" title="2.2 Follower侧的AppendEntries"></a>2.2 <code>Follower</code>侧的<code>AppendEntries</code></h2><p>发现冲突时, 回复的逻辑为:</p><ol><li>如果<code>PrevLogIndex</code>位置不存在日志项, 通过设置<code>reply.XTerm = -1</code>告知<code>Leader</code>, 并将<code>reply.XLen</code>设置为自身日志长度</li><li>如果<code>PrevLogIndex</code>位置日志项存在但<code>Term</code>冲突, 通过<code>reply.XTerm</code>和<code>reply.XIndex</code>分别告知冲突位置的<code>Term</code>和这个<code>Term</code>在<code>Follower</code>中第一次出现的位置</li></ol><p>具体代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">    ...</span><br><span class="line">isConflict := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验PrevLogIndex和PrevLogTerm不合法</span></span><br><span class="line"><span class="comment">// 2. Reply false if log doesn’t contain an entry at prevLogIndex whose term matches prevLogTerm (§5.3)</span></span><br><span class="line"><span class="keyword">if</span> args.PrevLogIndex &gt;= <span class="built_in">len</span>(rf.log) &#123;</span><br><span class="line"><span class="comment">// PrevLogIndex位置不存在日志项</span></span><br><span class="line">reply.XTerm = <span class="number">-1</span></span><br><span class="line">reply.XLen = <span class="built_in">len</span>(rf.log) <span class="comment">// Log长度</span></span><br><span class="line">isConflict = <span class="literal">true</span></span><br><span class="line">DPrintf(<span class="string">&quot;server %v 的log在PrevLogIndex: %v 位置不存在日志项, Log长度为%v\n&quot;</span>, rf.me, args.PrevLogIndex, reply.XLen)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;</span><br><span class="line"><span class="comment">// PrevLogIndex位置的日志项存在, 但term不匹配</span></span><br><span class="line">reply.XTerm = rf.log[args.PrevLogIndex].Term</span><br><span class="line">i := args.PrevLogIndex</span><br><span class="line"><span class="keyword">for</span> rf.log[i].Term == reply.XTerm &#123;</span><br><span class="line">i -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">reply.XIndex = i + <span class="number">1</span></span><br><span class="line">isConflict = <span class="literal">true</span></span><br><span class="line">DPrintf(<span class="string">&quot;server %v 的log在PrevLogIndex: %v 位置Term不匹配, args.Term=%v, 实际的term=%v\n&quot;</span>, rf.me, args.PrevLogIndex, args.PrevLogTerm, reply.XTerm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isConflict &#123;</span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">reply.Success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-leader侧的handleAppendEntries"><a href="#2-3-leader侧的handleAppendEntries" class="headerlink" title="2.3 leader侧的handleAppendEntries"></a>2.3 <code>leader</code>侧的<code>handleAppendEntries</code></h2><p>如果需要回退, <code>leader</code>的处理逻辑是:</p><ol><li>如果<code>XTerm == -1</code>, 表示<code>PrevLogIndex</code>位置在<code>Follower</code>中不存在<code>log</code>, 需要将<code>nextIndex</code>设置为<code>Follower</code>的<code>log</code>长度即<code>XLen</code></li><li>如果<code>XTerm != -1</code>, 表示<code>PrevLogIndex</code>位置在<code>Follower</code>中存在<code>log</code>但其<code>Term</code>为<code>XTerm</code>, 与<code>prevLogTerm</code>不匹配, 同时<code>XIndex</code>表示这个<code>Term</code>在<code>Follower</code>中第一次出现的位置, 需要如下进行判断:<ol><li>如果<code>Follower</code>中存在<code>XTerm</code>, 将<code>nextIndex</code>设置为<code>Follower</code>中最后一个<code>term == XTerm</code>的日志项的下一位</li><li>否则, 将<code>nextIndex</code>设置为<code>XIndex</code></li></ol></li></ol><p>具体代码为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> handleAppendEntries(serverTo <span class="type">int</span>, args *AppendEntriesArgs) &#123;</span><br><span class="line"><span class="comment">// 目前的设计, 重试自动发生在下一次心跳函数, 所以这里不需要死循环</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reply.Term == rf.currentTerm &amp;&amp; rf.role == Leader &#123;</span><br><span class="line"><span class="comment">// term仍然相同, 且自己还是leader, 表名对应的follower在prevLogIndex位置没有与prevLogTerm匹配的项</span></span><br><span class="line"><span class="comment">// 快速回退的处理</span></span><br><span class="line"><span class="keyword">if</span> reply.XTerm == <span class="number">-1</span> &#123;</span><br><span class="line"><span class="comment">// PrevLogIndex这个位置在Follower中不存在</span></span><br><span class="line">DPrintf(<span class="string">&quot;leader %v 收到 server %v 的回退请求, 原因是log过短, 回退前的nextIndex[%v]=%v, 回退后的nextIndex[%v]=%v\n&quot;</span>, rf.me, serverTo, serverTo, rf.nextIndex[serverTo], serverTo, reply.XLen)</span><br><span class="line">rf.nextIndex[serverTo] = reply.XLen</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i := rf.nextIndex[serverTo] - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i &gt; <span class="number">0</span> &amp;&amp; rf.log[i].Term &gt; reply.XTerm &#123;</span><br><span class="line">i -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> rf.log[i].Term == reply.XTerm &#123;</span><br><span class="line"><span class="comment">// 之前PrevLogIndex发生冲突位置时, Follower的Term自己也有</span></span><br><span class="line"></span><br><span class="line">DPrintf(<span class="string">&quot;leader %v 收到 server %v 的回退请求, 冲突位置的Term为%v, server的这个Term从索引%v开始, 而leader对应的最后一个XTerm索引为%v, 回退前的nextIndex[%v]=%v, 回退后的nextIndex[%v]=%v\n&quot;</span>, rf.me, serverTo, reply.XTerm, reply.XIndex, i, serverTo, rf.nextIndex[serverTo], serverTo, i+<span class="number">1</span>)</span><br><span class="line">rf.nextIndex[serverTo] = i + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 之前PrevLogIndex发生冲突位置时, Follower的Term自己没有</span></span><br><span class="line">DPrintf(<span class="string">&quot;leader %v 收到 server %v 的回退请求, 冲突位置的Term为%v, server的这个Term从索引%v开始, 而leader对应的XTerm不存在, 回退前的nextIndex[%v]=%v, 回退后的nextIndex[%v]=%v\n&quot;</span>, rf.me, serverTo, reply.XTerm, reply.XIndex, serverTo, rf.nextIndex[serverTo], serverTo, reply.XIndex)</span><br><span class="line">rf.nextIndex[serverTo] = reply.XIndex</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-持久化"><a href="#3-持久化" class="headerlink" title="3 持久化"></a>3 持久化</h1><p>持久化的内容只包括: <code>votedFor</code>, <code>currentTerm</code>, <code>log</code>, 为什么只需要持久化这三个变量, 也可以参考<a href="/2024/01/12/MIT6.5840/Lec06%E7%AC%94%E8%AE%B0/">课堂笔记</a></p><h2 id="3-1-持久化函数"><a href="#3-1-持久化函数" class="headerlink" title="3.1 持久化函数"></a>3.1 持久化函数</h2><p><code>persist</code>函数和<code>readPersist</code>函数很简单, 只需要根据注释的提示完成即可:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> persist() &#123;</span><br><span class="line"><span class="comment">// DPrintf(&quot;server %v 开始持久化, 最后一个持久化的log为: %v:%v&quot;, rf.me, len(rf.log)-1, rf.log[len(rf.log)-1].Cmd)</span></span><br><span class="line"></span><br><span class="line">w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">e := labgob.NewEncoder(w)</span><br><span class="line">e.Encode(rf.votedFor)</span><br><span class="line">e.Encode(rf.currentTerm)</span><br><span class="line">e.Encode(rf.log)</span><br><span class="line">raftstate := w.Bytes()</span><br><span class="line">rf.persister.Save(raftstate, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// restore previously persisted state.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> readPersist(data []<span class="type">byte</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> data == <span class="literal">nil</span> || <span class="built_in">len</span>(data) &lt; <span class="number">1</span> &#123; <span class="comment">// bootstrap without any state?</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> data == <span class="literal">nil</span> || <span class="built_in">len</span>(data) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">r := bytes.NewBuffer(data)</span><br><span class="line">d := labgob.NewDecoder(r)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> votedFor <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> currentTerm <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> log []Entry</span><br><span class="line"><span class="keyword">if</span> d.Decode(&amp;votedFor) != <span class="literal">nil</span> ||</span><br><span class="line">d.Decode(&amp;currentTerm) != <span class="literal">nil</span> ||</span><br><span class="line">d.Decode(&amp;log) != <span class="literal">nil</span> &#123;</span><br><span class="line">DPrintf(<span class="string">&quot;readPersist failed\n&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rf.votedFor = votedFor</span><br><span class="line">rf.currentTerm = currentTerm</span><br><span class="line">rf.log = log</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-持久化位置"><a href="#3-2-持久化位置" class="headerlink" title="3.2 持久化位置"></a>3.2 持久化位置</h2><p><code>lab</code>的持久化方案很粗糙, 只要修改了<code>votedFor</code>, <code>currentTerm</code>, <code>log</code>中的任意一个, 则进行持久化, 因此只需要在相应位置调用<code>persist</code>即可, 这里旧不给出代码了, 感兴趣可以直接看我提供的仓库。</p><p>特别需要说明的是，当崩溃恢复时，其调用的函数仍然是<code>Make</code>函数, 而<code>nextIndex</code>需要在执行了<code>readPersist</code>后再初始化, 因为<code>readPersist</code>修改了<code>log</code>, 而<code>nextIndex</code>需初始化为<code>log</code>长度</p><h2 id="3-3-持久化时是否需要锁"><a href="#3-3-持久化时是否需要锁" class="headerlink" title="3.3 持久化时是否需要锁?"></a>3.3 持久化时是否需要锁?</h2><p>按照我的理解, 持久化时不需要锁保护<code>log</code>, 原因如下:</p><ul><li><code>Leader</code>视角<br><code>Leader</code>永远不会删除自己的<code>log</code>(此时没有快照), 因此不需要锁保护</li><li><code>Follower</code>视角<br>尽管<code>Follower</code>可能截断<code>log</code>, 但永远不会截断在<code>commit</code>的<code>log</code>之前, 而持久化只需要保证已经<code>commit</code>的<code>log</code>, 因此也不需要锁</li></ul><h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h1><h2 id="4-1-常规测试"><a href="#4-1-常规测试" class="headerlink" title="4.1 常规测试"></a>4.1 常规测试</h2><ol><li><code>2B</code>测试<br>由于我们实现了快速回退, 此时可以测试<code>2B</code>, 看看是否速度有显著提升:<br>执行测试命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -v -run 2B</span><br></pre></td></tr></table></figure>结果如下:</li></ol><p><img src="/../../images/lab2-2C-test2B.png" alt="lab2-2C-test2B"></p><p>相比于之前快了15s左右, 勉勉强强满足了任务书中的一份子以内… 看了实现还是不够精妙啊</p><ol start="2"><li><code>2C</code>测试<br>执行测试命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -v -run 2C</span><br></pre></td></tr></table></figure>结果如下:</li></ol><p><img src="/../../images/lab2-2C-test2C.png" alt="lab2-2C-test2C"></p><p>比官方的示例满了4s, 还不错</p><h2 id="4-2-多次测试"><a href="#4-2-多次测试" class="headerlink" title="4.2 多次测试"></a>4.2 多次测试</h2><p><code>raft</code>的许多特性导致其一次测试并不准确, 有些bug需要多次测试才会出现, 编写如下脚本命名为<code>manyTest_2B.sh</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化计数器</span></span><br><span class="line">count=0</span><br><span class="line">success_count=0</span><br><span class="line">fail_count=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置测试次数</span></span><br><span class="line">max_tests=50</span><br><span class="line"></span><br><span class="line">for ((i=1; i&lt;=max_tests; i++))</span><br><span class="line">do</span><br><span class="line">    echo &quot;Running test iteration $i of $max_tests...&quot;</span><br><span class="line">    </span><br><span class="line">    # 运行 go 测试命令</span><br><span class="line">    go test -v -run 2C &amp;&gt; output2C.log</span><br><span class="line">    </span><br><span class="line">    # 检查 go 命令的退出状态</span><br><span class="line">    if [ &quot;$?&quot; -eq 0 ]; then</span><br><span class="line">        # 测试成功</span><br><span class="line">        success_count=$((success_count+1))</span><br><span class="line">        echo &quot;Test iteration $i passed.&quot;</span><br><span class="line">        # 如果想保存通过的测试日志，取消下面行的注释</span><br><span class="line">        # mv output2C.log &quot;success_$i.log&quot;</span><br><span class="line">    else</span><br><span class="line">        # 测试失败</span><br><span class="line">        fail_count=$((fail_count+1))</span><br><span class="line">        echo &quot;Test iteration $i failed, check &#x27;failure2C_$i.log&#x27; for details.&quot;</span><br><span class="line">        mv output2C.log &quot;failure2C_$i.log&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">报告测试结果</span></span><br><span class="line">echo &quot;Testing completed: $max_tests iterations run.&quot;</span><br><span class="line">echo &quot;Successes: $success_count&quot;</span><br><span class="line">echo &quot;Failures: $fail_count&quot;</span><br></pre></td></tr></table></figure><p>再次进行测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./manyTest_2C.sh</span><br></pre></td></tr></table></figure><p>结果:</p><p><img src="/../../images/lab2-2C-test2C-2.png" alt="lab2-2B-test2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将介绍&lt;code&gt;lab2C&lt;/code&gt;部分的实现, &lt;code&gt;lab2C&lt;/code&gt;要求实现&lt;code&gt;raft&lt;/code&gt;中的持久化功能, 相比&lt;code&gt;lab2A&lt;/code&gt;,和&lt;code&gt;lab2B&lt;/code&gt;, 本节的难度其实很小, 但复杂的是&lt;</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="Lab笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/Lab%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Go" scheme="http://example.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.5840(6.824) Lec06笔记: raft论文解读2: 恢复、持久化和快照</title>
    <link href="http://example.com/2024/01/12/MIT6.5840/Lec06%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/01/12/MIT6.5840/Lec06%E7%AC%94%E8%AE%B0/</id>
    <published>2024-01-12T01:19:15.000Z</published>
    <updated>2024-01-16T08:28:50.036Z</updated>
    
    <content type="html"><![CDATA[<p>课程主页: <a href="https://pdos.csail.mit.edu/6.824/schedule.html">https://pdos.csail.mit.edu/6.824/schedule.html</a></p><p>本节课是介绍<code>Raft</code>共识算法的第一部分, 建议阅读<a href="https://pdos.csail.mit.edu/6.824/papers/gfs.pdf">论文</a>, 如果要做<code>Lab</code>的话, 论文是一定要看的, 尤其是要吃透论文中的图2。</p><p>本节课介绍的内容包括: 日志恢复、选举限制、持久化、快照和一致性。</p><h1 id="1-日志恢复"><a href="#1-日志恢复" class="headerlink" title="1 日志恢复"></a>1 日志恢复</h1><h2 id="1-1-日志恢复的案例"><a href="#1-1-日志恢复的案例" class="headerlink" title="1.1 日志恢复的案例"></a>1.1 日志恢复的案例</h2><p>为了举例说明<code>Raft</code>是如何进行日志恢复的, 我们假设有如下表格的情形:</p><table><thead><tr><th align="left">节点\log索引</th><th align="right">10</th><th align="right">11</th><th align="right">12</th><th align="right">13</th></tr></thead><tbody><tr><td align="left">S1</td><td align="right">3</td><td align="right"></td><td align="right"></td><td align="right"></td></tr><tr><td align="left">S2</td><td align="right">3</td><td align="right">3</td><td align="right">4</td><td align="right"></td></tr><tr><td align="left">S3</td><td align="right">3</td><td align="right">3</td><td align="right">5</td><td align="right"></td></tr></tbody></table><p>表格中存在3个节点<code>S1,S2,S3</code>, 存放的值是每个日志槽位的<code>Term</code>。 假设其在日志槽位<code>0-9</code>都保持完全一致。以下说明了为什么某一时刻会出现上表的状态：</p><ol><li>到槽位<code>10</code>的日志为止， 所有的节点网络正常且工作正常, 此时最高<code>Term</code>为3, <code>Leader</code>为<code>S3</code></li><li>此后<code>S1</code>故障, 因此槽位<code>11</code>的<code>log</code>只被复制在了<code>S2</code>和<code>S3</code></li><li>之后<code>S2,S3</code>之间的网络也出现了故障<code>S2</code>进行选举</li><li>恰好选举时<code>S1</code>恢复了, <code>S1,S2</code>都为<code>S2</code>投票, <code>S2</code>因为获得了超过半数投票而被选为新<code>Leader</code>, 新的<code>Term</code>为4</li><li>新<code>Leader S2</code>向自身槽位12处追加一个<code>Term</code>为4的<code>log</code>, 然后故障了, 因此槽位12处<code>Term</code>为4的<code>log</code>只存在于<code>S2</code></li><li>此时<code>S3</code>触发选举超时, 并获取了<code>S1</code>和<code>S3</code>的选票成为新<code>Leader</code>, 新的<code>Term</code>为5</li><li>新<code>Leader S3</code>向自身槽位12处追加一个<code>Term</code>为5的<code>log</code>, 然后准备开始广播, 并且广播前<code>S2</code>也恢复了</li></ol><p>以上就是为什么会出现表中所示的内容的原因, 而<code>Raft</code>的日志恢复的目的是, 将<code>Leader</code>的日志强行复制到其他节点, 介绍这个机制前, 需要引入<code>Leader</code>维护的几个变量和<code>AppendEntries RPC</code>中的参数:</p><p><strong><code>Leader</code>维护的变量</strong></p><ul><li><code>nextIndex[]</code>: <code>Leader</code>认为下一个追加的日志在每个节点的索引</li><li><code>matchIndex[]</code>: <code>Leader</code>认为每个节点中已经复制的日志项的最高索引</li></ul><p><strong><code>AppendEntries RPC</code>中的参数</strong></p><ul><li><code>term</code>: <code>Leader</code>的任期</li><li><code>leaderId</code>: <code>Leader</code>的<code>id</code></li><li><code>prevLogIndex</code>: 追加的新日志前的日志索引</li><li><code>prevLogTerm</code>: 追加的新日志前的日志的<code>Term</code></li><li><code>entries[]</code>: 日志项切片</li><li><code>leaderCommit</code>: <code>Leader</code>记录的已经<code>commit</code>的日志项的最高索引</li></ul><p>因此, 按照论文<a href="../../images/raft-figure2.png">Figure 2</a>中的描述, 新的<code>Leader</code>将把<code>nextIndex[]</code>初始化为自身日志数组长度, 发送时的<code>PrevLogIndex</code>就是<code>nextIndex[i] - 1</code>, 因此<code>Leader S3</code>向<code>S1</code>和<code>S2</code>发送的<code>AppendEntries RPC</code>为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">    Term:         <span class="number">5</span>,</span><br><span class="line">    LeaderId:     <span class="number">3</span>,</span><br><span class="line">    PrevLogIndex: <span class="number">11</span>,</span><br><span class="line">    PrevLogTerm:  <span class="number">3</span>,</span><br><span class="line">    LeaderCommit: <span class="number">1</span>,</span><br><span class="line">    Entrie:       ...,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此, <code>Follower</code>收到<code>AppendEntries RPC</code>会根据<code>PrevLogIndex</code>, <code>PrevLogTerm</code>进行检查:</p><ul><li><code>S1</code>发现自己没有<code>槽位11</code>的<code>log</code>, 返回<code>false</code></li><li><code>S2</code>发现自己有<code>槽位11</code>的<code>log</code>, 其<code>Term</code>为3也与<code>AppendEntriesArgs</code>匹配, 因此其使用<code>AppendEntriesArgs</code>中的覆盖原来槽位12处的<code>log</code>, 返回<code>true</code></li></ul><p><code>Leader S3</code>收到<code>S1</code>和<code>S2</code>回复的<code>AppendEntries RPC</code>后, 会做如下处理:</p><ol><li>发现<code>S2</code>回复了<code>true</code>, 因此将<code>S2</code>的<code>matchIndex[S2]</code>设置为<code>PrevLogIndex+len(Entries)</code>, 将<code>nextIndex[S2]</code>设置为<code>matchIndex[S2]+1</code></li><li>发现<code>S1</code>回复了<code>false</code>, 于是将其<code>nextIndex[S1]</code>自减, 再次发送的<code>AppendEntries RPC</code>为:</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">    Term:         <span class="number">5</span>,</span><br><span class="line">    LeaderId:     <span class="number">3</span>,</span><br><span class="line">    PrevLogIndex: <span class="number">10</span>,</span><br><span class="line">    PrevLogTerm:  <span class="number">3</span>,</span><br><span class="line">    LeaderCommit: <span class="number">1</span>,</span><br><span class="line">    Entrie:       ...,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时<code>S1</code>发现自己有<code>槽位10</code>的<code>log</code>, 其<code>Term</code>也与<code>AppendEntriesArgs</code>匹配, 因此进行追加并返回<code>true</code>, <code>Leader S3</code>按照相同的逻辑处理<code>nextIndex[S1]</code>和<code>matchIndex[S1]</code></p><h2 id="1-2-日志恢复的逻辑"><a href="#1-2-日志恢复的逻辑" class="headerlink" title="1.2 日志恢复的逻辑"></a>1.2 日志恢复的逻辑</h2><p>从上述的日志恢复的机制我们可以看出, <code>Raft</code>强制将<code>Leader</code>的日志条目覆盖到<code>Follower</code>上, 这一机制的根本前提是: <strong><code>Leader</code>的日志是最新和完整的</strong>, 这一前提的实现就是接下来介绍了<strong>选举约束</strong></p><h1 id="2-选举约束"><a href="#2-选举约束" class="headerlink" title="2 选举约束"></a>2 选举约束</h1><h2 id="2-1-机制描述"><a href="#2-1-机制描述" class="headerlink" title="2.1 机制描述"></a>2.1 机制描述</h2><p><code>Raft</code>中选举约束的机制是:</p><ol><li>如果<code>Term</code>更小, 直接拒绝投票</li><li><code>Candidate</code>的最后一条<code>Log</code>的<code>Term</code>大于本地最后一条<code>Log</code>的<code>Term</code>, 投票</li><li>否则, <code>Candidate</code>的最后一条<code>Log</code>的<code>Term</code>等于本地最后一条<code>Log</code>的<code>Term</code>, 且<code>Candidate</code>的<code>Log数组</code>长度更长, 投票</li><li>否则, 拒绝投票</li></ol><p>在之前的<code>AppendEntries RPC</code>中的参数中, 包含了<code>Term</code>, 其表示<code>Candidate</code>的<code>Term</code>, 为什么不使用<code>Candidate</code>的<code>Term</code>进行比较而实用最后一条<code>Log</code>的<code>Term</code>进行比较呢? 因为使用<code>Candidate</code>的<code>Term</code>进行比较会出现很多问题, 例如孤立节点:</p><ol><li>某一时刻一个<code>server</code>网络出现了问题(称其为<code>S</code>), 其自增<code>currentTerm</code>(即记录自身的<code>Term</code>的字段)后发出选举， 经过多次选举超时后其<code>currentTerm</code>已经远大于离开集群时的<code>currentTerm</code></li><li>后来网络恢复了正常, 这时其他的服务器收到了<code>S</code>的选举请求, 这个选举请求有更新的term, 因此都同意向它投票, <code>S</code>成为了最新的<code>leader</code></li><li>由于<code>S</code>离开集群时集群其他的服务器已经提交了多个<code>log</code>, 这些提交在<code>S</code>中不存在, 而<code>S</code>信任自己的<code>log</code>, 并将自己的<code>log</code>复制到所有的<code>follower</code>上, 这将覆盖已经提交了多个<code>log</code>, 导致了错误</li></ol><h2 id="2-2-案例"><a href="#2-2-案例" class="headerlink" title="2.2 案例"></a>2.2 案例</h2><p>此处还是举之前的那一个例子:</p><table><thead><tr><th align="left">节点\log索引</th><th align="right">10</th><th align="right">11</th><th align="right">12</th><th align="right">13</th></tr></thead><tbody><tr><td align="left">S1</td><td align="right">3</td><td align="right"></td><td align="right"></td><td align="right"></td></tr><tr><td align="left">S2</td><td align="right">3</td><td align="right">3</td><td align="right">4</td><td align="right"></td></tr><tr><td align="left">S3</td><td align="right">3</td><td align="right">3</td><td align="right">5</td><td align="right"></td></tr></tbody></table><p>但我们假设这个到达这个状态(<code>S3</code>是<code>Leader</code>, <code>Term</code>为5, 且向自身追加<code>log</code>前已经发送了心跳, 即同步了<code>Term</code>)后, <code>S3</code>又故障了, 然后其马上又恢复, 此时没有<code>Leader</code>, 将触发选举超时, 假设<code>S1</code>先触发选举超时, 其广播投票的<code>RequestVote RPC</code>, 其论文<a href="../../images/raft-figure2.png">Figure2</a>描述的请求参数为:</p><ul><li><code>term</code>: <code>candidate</code> 的<code>Term</code></li><li><code>candidateId</code>: <code>candidate</code> 的<code>id</code></li><li><code>lastLogIndex</code>: <code>candidate</code> 最后一个日志项的索引</li><li><code>lastLogTerm</code>: <code>candidate</code> 最后一个日志项的<code>Term</code></li></ul><p>因此, <code>S1</code>发出的<code>RequestVote RPC</code>参数为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">args := &amp;RequestVoteArgs&#123;</span><br><span class="line">    Term:         <span class="number">5</span>,</span><br><span class="line">    candidateId:  <span class="number">1</span>,</span><br><span class="line">    lastLogIndex: <span class="number">10</span>,</span><br><span class="line">    lastLogTerm:  <span class="number">3</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余节点的反应为:</p><ul><li><code>S2</code>和<code>S3</code>发现其<code>RequestVoteArgs</code>的<code>Term</code>为5, 进行下一步判断, 但发现<code>lastLogTerm</code>比自己的<code>4</code>和<code>5</code>更小, 因此拒绝投票</li></ul><p>此后, <code>S2</code>发起了选举, <code>RequestVote RPC</code>参数为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">args := &amp;RequestVoteArgs&#123;</span><br><span class="line">    Term:         <span class="number">5</span>,</span><br><span class="line">    candidateId:  <span class="number">2</span>,</span><br><span class="line">    lastLogIndex: <span class="number">12</span>,</span><br><span class="line">    lastLogTerm:  <span class="number">4</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余节点的反应为:</p><ul><li><code>S1</code>发现其<code>RequestVoteArgs</code>的<code>Term</code>为5, 进行下一步判断, 发现<code>lastLogTerm</code>为4, 比自己的3更大, 投票</li><li><code>S3</code>发现其<code>RequestVoteArgs</code>的<code>Term</code>为5, 进行下一步判断, 发现<code>lastLogTerm</code>为4, 比自己的5更小, 拒绝投票</li></ul><p><code>S2</code>收获了自身和<code>S1</code>两张选票, 满足过半的要求, 成为新的<code>Leader</code>, 并在稍后将通过心跳将自己的<code>Term</code>为4的那个<code>log</code>覆盖掉<code>S3</code>中相同位置的<code>log</code></p><h1 id="3-快速恢复"><a href="#3-快速恢复" class="headerlink" title="3 快速恢复"></a>3 快速恢复</h1><h2 id="3-1-快速恢复的需求"><a href="#3-1-快速恢复的需求" class="headerlink" title="3.1 快速恢复的需求"></a>3.1 快速恢复的需求</h2><p>在之前<strong>日志恢复</strong>的介绍中, 如果有<code>Follower</code>的日志不匹配, 每次<code>RPC</code>中, <code>Leader</code>会将其<code>nextIndex</code>自减1来重试, 但其在某些情况下会导致效率很低(说的就是<code>Lab2</code>的测例), 其情况为:</p><ol><li>某一时刻, 发生了网络分区, 旧的<code>leader</code>正好在数量较少的那一个分区, 且这个分区无法满足<code>commit</code>过半的要求</li><li>另一个大的分区节点数量更多, 能满足投票过半和<code>commit</code>过半的要求, 因此选出了<code>Leader</code>并追加并<code>commit</code>了很多新的<code>log</code></li><li>于此同时, 旧的<code>leader</code>也在向其分区内的节点追加很多新的<code>log</code>, 只是其永远也无法<code>commit</code></li><li>某一时刻, 网络恢复正常, 旧的<code>Leader</code>被转化为<code>Follower</code>, 其需要进行新的<code>Leader</code>的日志恢复, 由于其<code>log数组</code>差异巨大, 因此将<code>nextIndex</code>自减1来重试将耗费大量的时间</li></ol><p>因此, 在上述情况下, 需要进行<strong>快速恢复</strong>的优化</p><h2 id="3-1-快速恢复的机制"><a href="#3-1-快速恢复的机制" class="headerlink" title="3.1 快速恢复的机制"></a>3.1 快速恢复的机制</h2><p>论文中描述如下:</p><blockquote><p>If desired, the protocol can be optimized to reduce the number of rejected AppendEntries RPCs. For example, when rejecting an AppendEntries request, the follower can include the term of the conflicting entry and the first index it stores for that term. With this information, the leader can decrement nextIndex to bypass all of the conflicting entries in that term; one AppendEntries RPC will be required for each term with conflicting entries, rather than one RPC per entry. In practice, we doubt this optimization is necessary, since failures happen infrequently and it is unlikely that there will be many inconsistent entries.</p></blockquote><p>论文中的描述过于简略, 教授在课堂上进行了进一步的解释, 其思想在于:<strong><code>Follower</code>返回更多信息给<code>Leader</code>，使其可以以<code>Term</code>为单位来回退</strong></p><p>具体而言, 需要在<code>AppendEntriesReplay</code>中增加下面几个字段:</p><ul><li><code>XTerm</code>: <code>Follower</code>中与<code>Leader</code>冲突的<code>Log</code>对应的<code>Term</code>, 如果<code>Follower</code>在对应位置没有<code>Log</code>将其设置为-1</li><li><code>XIndex</code>: <code>Follower</code>中，对应<code>Term</code>为<code>XTerm</code>的第一条<code>Log</code>条目的索引</li><li><code>XLen</code>: 空白的<code>Log</code>槽位数, 如果<code>Follower</code>在对应位置没有<code>Log</code>，那么<code>XTerm</code>设置为-1</li></ul><p>当<code>Follower</code>收到回复后, 按如下规则做出反应:</p><ol><li>如果<code>XTerm != -1</code>, 表示<code>PrevLogIndex</code>这个位置发生了冲突, <code>Follower</code>检查自身是否有<code>Term</code>为<code>XTerm</code>的日志项<ol><li>如果有, 则将<code>nextIndex[i]</code>设置为自己<code>Term</code>为<code>XTerm</code>的最后一个日志项的下一位, 这样的情况出现在<code>Follower</code>有着更多旧<code>Term</code>的日志项(<code>Leader</code>也有这样<code>Term</code>的日志项), 这种回退会一次性覆盖掉多余的旧<code>Term</code>的日志项</li><li>如果没有, 则将<code>nextIndex[i]</code>设置为<code>XIndex</code>, 这样的情况出现在<code>Follower</code>有着<code>Leader</code>所没有的<code>Term</code>的旧日志项, 这种回退会一次性覆盖掉没有出现在<code>Leader</code>中的<code>Term</code>的日志项</li></ol></li><li>如果<code>XTerm == -1</code>, 表示<code>Follower</code>中的日志不存在<code>PrevLogIndex</code>处的日志项, 这样的情况出现在<code>Follower</code>的<code>log数组长度</code>更短的情况下, 此时将<code>nextIndex[i]</code>减去<code>XLen</code></li></ol><h2 id="3-2-案例说明"><a href="#3-2-案例说明" class="headerlink" title="3.2 案例说明"></a>3.2 案例说明</h2><p>如下所示为各个节点的状态, 此时<code>Leader</code>为<code>S3</code>, 其将要广播<code>Term</code>为6的<code>AppendEntries RPC</code>给<code>Follower</code>:</p><table><thead><tr><th align="left">节点\log索引</th><th align="right">10</th><th align="right">11</th><th align="right">12</th><th align="right">13</th></tr></thead><tbody><tr><td align="left">S0</td><td align="right">4</td><td align="right"></td><td align="right"></td><td align="right"></td></tr><tr><td align="left">S1</td><td align="right">4</td><td align="right">5</td><td align="right">5</td><td align="right"></td></tr><tr><td align="left">S2</td><td align="right">4</td><td align="right">4</td><td align="right">4</td><td align="right"></td></tr><tr><td align="left">S3</td><td align="right">4</td><td align="right">6</td><td align="right">6</td><td align="right">6</td></tr></tbody></table><p>其请求的<code>AppendEntriesArgs</code>为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">    Term:         <span class="number">6</span>,</span><br><span class="line">    LeaderId:     <span class="number">3</span>,</span><br><span class="line">    PrevLogIndex: <span class="number">12</span>,</span><br><span class="line">    PrevLogTerm:  <span class="number">6</span>,</span><br><span class="line">    LeaderCommit: <span class="number">1</span>,</span><br><span class="line">    Entrie:       ...,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>情况1: <code>S0</code>:<ul><li><code>S0</code>在<code>PrevLogIndex</code>位置不存在<code>log</code>, 其返回<code>XTerm=-1 &amp;&amp; XLen=2</code></li><li><code>Follower</code>收到回复后, 将<code>nextIndex[S0]</code>减去<code>XLen=2</code>, 下次发送时<code>PrevLogIndex=10</code>. 将进行正常的追加日志</li></ul></li><li>情况2: <code>S1</code>:<ul><li><code>S1</code>在<code>PrevLogIndex</code>位置的<code>Term</code>发生了冲突, 其返回<code>XTerm=5 &amp;&amp; XIndex=11</code></li><li><code>Follower</code>收到回复后, 发现自己没有<code>Term =5</code>的日志项, 将<code>nextIndex[S1]</code>设置为<code>XIndex=11</code>, 下次发送时<code>PrevLogIndex=10</code>. 将进行正常的追加日志并覆盖掉<code>Term=5</code>的部分</li></ul></li><li>情况3: <code>S2</code>:<ul><li><code>S2</code>在<code>PrevLogIndex</code>位置的<code>Term</code>发生了冲突, 其返回<code>XTerm=4 &amp;&amp; XIndex=10</code></li><li><code>Follower</code>收到回复后, 发现自己也有<code>Term =4</code>的日志项, 将<code>nextIndex[S1]</code>设置为<code>Term=4</code>的最后一个<code>log</code>的下一位, 即11, 下次发送时<code>PrevLogIndex=10</code>. 将进行正常的追加日志并覆盖掉多余的<code>Term=4</code>的部分</li></ul></li></ol><h1 id="4-持久化"><a href="#4-持久化" class="headerlink" title="4 持久化"></a>4 持久化</h1><h2 id="4-1-持久化的内容"><a href="#4-1-持久化的内容" class="headerlink" title="4.1 持久化的内容"></a>4.1 持久化的内容</h2><p>持久化存储的目的是为了在服务器重启时利用持久化存储的数据恢复节点上一个工作时刻的状态。并且，持久化的内容仅仅是<code>Raft</code>层, 其应用层不做要求。</p><p>论文中提到需要持久花的数据包括:</p><ol><li><code>votedFor</code>:<br><code>votedFor</code>记录了一个节点在某个<code>Term</code>内的投票记录, 因此如果不将这个数据持久化, 可能会导致如下情况:<ol><li>在一个<code>Term</code>内某个节点向某个<code>Candidate</code>投票, 随后故障</li><li>故障重启后, 又收到了另一个<code>RequestVote RPC</code>, 由于其没有将<code>votedFor</code>持久化, 因此其不知道自己已经投过票, 结果是再次投票, 这将导致同一个<code>Term</code>可能出现2个<code>Leader</code></li></ol></li><li><code>currentTerm</code>:<br><code>currentTerm</code>的作用也是实现一个任期内最多只有一个<code>Leader</code>, 因为如果一个几点重启后不知道现在的<code>Term</code>时多少, 其无法再进行投票时将<code>currentTerm</code>递增到正确的值, 也可能导致有多个<code>Leader</code>在同一个<code>Term</code>中出现</li><li><code>Log</code>:<br>这个很好理解, 需要用<code>Log</code>来恢复自身的状态</li></ol><p>这里值得思考的是：<strong>为什么只需要持久化<code>votedFor</code>, <code>currentTerm</code>, <code>Log</code>？</strong></p><p>原因是其他的数据， 包括 <code>commitIndex</code>、<code>lastApplied</code>、<code>nextIndex</code>、<code>matchIndex</code>都可以通过心跳的发送和回复逐步被重建, <code>Leader</code>会根据回复信息判断出哪些<code>Log</code>被<code>commit</code>了。</p><h2 id="4-2-什么时候持久化"><a href="#4-2-什么时候持久化" class="headerlink" title="4.2 什么时候持久化"></a>4.2 什么时候持久化</h2><p>由于将任何数据持久化到硬盘上都是巨大的开销, 其开销远大于<code>RPC</code>, 因此需要仔细考虑什么时候将数据持久化。</p><p>如果每次修改三个需要持久化的数据: <code>votedFor</code>, <code>currentTerm</code>, <code>Log</code>时, 都进行持久化, 其持久化的开销将会很大， 很容易想到的解决方案是进行批量化操作， 例如只在回复一个<code>RPC</code>或者发送一个<code>RPC</code>时，才进行持久化操作。</p><h1 id="5-快照"><a href="#5-快照" class="headerlink" title="5 快照"></a>5 快照</h1><h2 id="5-1-为什么需要快照？"><a href="#5-1-为什么需要快照？" class="headerlink" title="5.1 为什么需要快照？"></a>5.1 为什么需要快照？</h2><p><code>Log</code>实际上是描述了某个应用的操作, 以一个<code>K/V数据库</code>为例, <code>Log</code>就是<code>Put</code>或者<code>Get</code>, 当这个应用运行了相当长的时间后, 其积累的<code>Log</code>将变得很长, 但<code>K/V数据库</code>实际上键值对并不多, 因为<code>Log</code>包含了大量的对同一个键的赋值或取值操作。</p><p>因此， 应当设计一个阈值，例如1M， 将应用程序的状态做一个快照，然后丢弃这个快照之前的<code>Log</code>。</p><p>这里有两大关键点：</p><ol><li>快照是<code>Raft</code>要求上层的应用程序做的, 因为<code>Raft</code>本身并不理解应用程序的状态和各种命令</li><li><code>Raft</code>需要选取一个<code>Log</code>作为快照的分界点, 在这个分界点要求应用程序做快照, 并删除这个分界点之前的<code>Log</code></li><li>在持久化快照的同时也持久化这个分界点之后的<code>Log</code></li></ol><p>引入快照后, <code>Raft</code>启动时需要检查是否有之前创建的快照, 并迫使应用程序应用这个快照。</p><h2 id="5-2-快照造成的Follower日志缺失问题"><a href="#5-2-快照造成的Follower日志缺失问题" class="headerlink" title="5.2 快照造成的Follower日志缺失问题"></a>5.2 快照造成的<code>Follower</code>日志缺失问题</h2><p>假设有一个<code>Follower</code>的日志数组长度很短, 短于<code>Leader</code>做出快照的分界点, 那么这中间缺失的<code>Log</code>将无法通过心跳<code>AppendEntries RPC</code>发给<code>Follower</code>, 因此这个确实的<code>Log</code>将永久无法被补上。</p><ul><li>解决方案1：<br>如果<code>Leader</code>发现有<code>Follower</code>的<code>Log</code>落后作快照的分界点，那么<code>Leader</code>就不丢弃快照之前的<code>Log</code>。</li></ul><p>这个方案的缺陷在于如果一个<code>Follower</code>落后太多(例如关机了一周), 这个<code>Follower</code>的<code>Log</code>长度将使<code>Leader</code>无法通过快照来减少内存消耗。</p><ul><li>解决方案2：<br>这也是<code>Raft</code>采用的方案。<code>Leader</code>可以丢弃<code>Follower</code>落后作快照的分界点的<code>Log</code>。通过一个新的<code>InstallSnapshot RPC</code>来补全丢失的<code>Log</code>, 具体来说过程如下:<ol><li><code>Follower</code>通过<code>AppendEntries</code>发现自己的<code>Log</code>更短, 强制<code>Leader</code>回退自己的<code>Log</code></li><li>回退到在某个点时，<code>Leader</code>不能再回退，因为它已经到了自己<code>Log</code>的起点, 更早的<code>Log</code>已经由于快照而被丢弃</li><li><code>Leader</code>将自己的快照发给<code>Follower</code></li><li><code>Leader</code>稍后通过<code>AppendEntries</code>发送快照后的<code>Log</code></li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;课程主页: &lt;a href=&quot;https://pdos.csail.mit.edu/6.824/schedule.html&quot;&gt;https://pdos.csail.mit.edu/6.824/schedule.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本节课是介绍&lt;code&gt;Raft</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Raft" scheme="http://example.com/tags/Raft/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.5840(6.824) Lec05笔记: raft论文解读1：选举和日志</title>
    <link href="http://example.com/2024/01/11/MIT6.5840/Lec05%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/01/11/MIT6.5840/Lec05%E7%AC%94%E8%AE%B0/</id>
    <published>2024-01-11T01:33:25.000Z</published>
    <updated>2024-01-16T08:05:55.038Z</updated>
    
    <content type="html"><![CDATA[<p>课程主页: <a href="https://pdos.csail.mit.edu/6.824/schedule.html">https://pdos.csail.mit.edu/6.824/schedule.html</a></p><p>本节课是介绍<code>Raft</code>共识算法的第一部分, 建议阅读<a href="https://pdos.csail.mit.edu/6.824/papers/gfs.pdf">论文</a>, 如果要做<code>Lab</code>的话, 论文是一定要看的, 尤其是要吃透论文中的图2。</p><h1 id="1-引入-脑裂（split-brain）"><a href="#1-引入-脑裂（split-brain）" class="headerlink" title="1 引入: 脑裂（split brain）"></a>1 引入: 脑裂（split brain）</h1><p>脑裂的定义:</p><blockquote><p>当系统中的节点因为网络故障而无法相互通信时，可能会发生脑裂现象，即系统被分割成两个或多个互不连通的子集，每个子集都可能认为自己是完整的系统。</p></blockquote><p>在介绍<code>raft</code>算法之前, 课程首先总结了之前课程中的几个分布式应用程序的共性和潜在的问题:</p><ul><li><code>MapReduce</code>: 主节点管理<code>Map</code>和<code>Reduce</code>任务的派发和信息收集, 自始至终没有发生变化</li><li><code>GFS</code>: 主节点管理<code>Chunk</code>信息、租约管理等, 主节点通过日志的形式避免宕机后信息的丢失</li><li><code>VMware FT</code>: 通过一个原子测试完成<code>Primary</code>和<code>Backup</code>之间的切换</li></ul><p>以上讨论的问题都是主节点失效后系统能否正常工作的场景, 看起来<code>VMware FT</code>可以满足在一个服务器宕机后剩下的服务器也能正常运行的需求, 但这里仍然存在问题: <strong>其原子测试本身也是一个<code>Test-and-Set服务</code></strong></p><p>下图为课程中展示的案例:</p><p><img src="/../../images/Lec06-split.png" alt="split-brain"></p><p>因为<code>Test-and-Set服务</code>本身也算是一个分布式应用, 其也存在主从备份的概念, 因此会出现上图中描述 的场景:</p><ol><li><code>Primary</code>和<code>Backup</code>之间的网络出现问题, 都认为自己是唯一的服务节点</li><li><code>Primary</code>与<code>Test-and-Set Server1</code>之间网络正常, 与<code>Test-and-Set Server2</code>之间网络不正常; <code>Backup</code>与<code>Test-and-Set Server1</code>之间网络不正常, 与<code>Test-and-Set Server2</code>之间网络正常</li><li><code>Primary</code>和<code>Backup</code>的<code>Test-and-Set</code>测试都成功了, 此时存在2个上线的服务器, 这就是一种<strong>脑裂</strong>现象</li></ol><p>以上的问题是一种<strong>脑裂</strong>现象, 因为<code>Primary</code>和<code>Backup</code>之间出现了网络分区, 每个区域之间不能彼此访问。</p><p><strong>补充:另外二者对脑裂现象的处理</strong>:</p><ul><li><code>MapReduce</code>中没有提及解决方案</li><li><code>GFS</code>的主节点会将关键的元数据信息存储在持久化的操作日志中，这个日志会被复制到多个地方，确保其可用性。如果发生网络分区，那么分布在不同分区的节点可能无法与主节点通信，但<code>GFS</code>的设计允许系统在某种程度的网络分区后仍然能够继续操作，只要分区中有足够的副本存在。</li></ul><h1 id="2-多数投票（Majority-Vote）"><a href="#2-多数投票（Majority-Vote）" class="headerlink" title="2 多数投票（Majority Vote）"></a>2 多数投票（Majority Vote）</h1><p>以上的问题在于不同的网络分区并不知道自己是否在别的网络分区工作的同时也在工作， 为了解决这个问题， <code>raft</code>算法提出了<code>Majority Vote</code>: <strong>任何决策必须要求过半的节点的投票支持</strong>。这是<code>Raft</code>最基本的一个概念, 而且这个概念还有一个重要的前提: <strong>节点数量必须是奇数</strong></p><p>因为如果是奇数的节点构成的分布式应用, 至多只有一个数量过半的网络分区, 因此至多只有一个网络分区能够完成正常的决策工作, 避免了脑裂。同时， 这个机制还表达了<code>raft</code>的容错能力: <strong>至多允许一半的节点异常</strong>。</p><h1 id="3-raft的运行案例"><a href="#3-raft的运行案例" class="headerlink" title="3 raft的运行案例"></a>3 raft的运行案例</h1><p>课程中为了展示<code>raft</code>在实际应用中如何工作, 给出了<code>lab3</code>中将实现的<code>kv存储</code>的例子:</p><p><img src="/../../images/Lec06-raft-kv.png" alt="raft-kv"></p><ol><li>客户端请请求(<code>Get</code>或<code>Put</code>)发送给<code>Leader</code>的服务层</li><li><code>Leader</code>的服务层将这个<code>Get</code>或<code>Put</code>命令向下发送到<code>Raft</code>层</li><li><code>Raft</code>层将操作封装成日志发送给多个<code>Follower</code>的<code>Raft</code>层</li><li><code>Follower</code>的<code>Raft</code>层复制日志后回复</li><li><code>Leader</code>的<code>Raft</code>层收到过半节点回复后, 向上发送一个通知到应用程序表示真正的执行这个操作了。</li><li><code>Leader</code>的服务执行命令改变自身<code>Table</code>的状态, 并回复给客户端执行结果</li><li><code>Follower</code>的应用层也应用<code>Raft</code>层的日志改变自身<code>Table</code>的状态(这里需要<code>Leader</code>告知哪些<code>log</code>是<code>commited</code>, 通常是通过心跳告知, 图中未画出, 而且这个操作通常有延迟, 客户端不需要等待这个操作完成)</li></ol><p><strong>接口函数说明</strong></p><ol><li><code>Start</code>函数<br>应用程序通过<code>Start</code>函数将一个操作传递给<code>Raft</code>层，返回值包括，这个请求将会存放在<code>Log</code>中的索引(如果成功<code>commit</code>的话)</li><li><code>applyCh channel</code><br>当之前请求的操作<code>commit</code>之后, 通过<code>applyCh channel</code>向应用程序发出消息通知, 应用程序读取这个消息。</li></ol><p>具体而言, 客户端调用应用层的<code>RPC</code>，应用层收到<code>RPC</code>之后，会调用<code>Start</code>函数，<code>Start</code>函数会立即返回，但是这时，应用层不会返回消息给客户端，因为它还没有执行客户端请求，它也不知道这个请求是否会被<code>Raft</code>层<code>commit</code>。只有在某一时刻，对应于这个客户端请求的消息在<code>applyCh channel</code>中出现, 应用层才会执行这个请求，并返回响应给客户端。</p><h1 id="4-Log"><a href="#4-Log" class="headerlink" title="4 Log"></a>4 Log</h1><p><code>Raft</code>中的<code>Log</code>会被添加到节点的<code>Log数组</code>中, 每一个<code>Log</code>包含了以下内容:</p><ul><li>具体的命令, 取决于应用</li><li>任期<code>Term</code>, 用于判断这个<code>Log</code>是否有效</li></ul><p><code>Leader</code>节点需要维护每个<code>Follower</code>的<code>Log</code>状态:</p><ol><li>目前已经复制的<code>Log</code>在数组中的索引</li><li>下一个追加的<code>Log</code>应该从哪个索引开始</li></ol><p>同时<code>Leader</code>也需要维护全局的日志状态:</p><ul><li>目前已经提交的<code>Log</code>在日志数组中的索引</li></ul><p><code>Log</code>有3大作用:</p><ol><li>用于<code>Leader</code>和<code>Follower</code>之间的同步</li><li>包含命令用以改变应用程序的状态</li><li>每个<code>Raft</code>节点都需要将<code>Log</code>写入到它的磁盘中, 因此<code>Log</code>还可以被<code>Raft</code>节点用来从头执行其中的操作进而重建故障前的状态</li></ol><p><strong>重启后<code>Leader</code>如何利用<code>Log</code>进行恢复?</strong></p><ol><li>首先重启后进行<code>Leader</code>选举，其中一个节点被选为<code>Leader</code></li><li><code>Leader</code>通过心跳来确定目前已经提交的日志的索引位置</li><li>在这个索引位置以前, 所有的节点的日志是相同的, 可以应用到自身的状态机</li><li>在这个索引位置以后, <code>Leader</code>迫使其他所有副本的<code>Log</code>与自己保持一致</li></ol><h1 id="5-Leader选举"><a href="#5-Leader选举" class="headerlink" title="5 Leader选举"></a>5 Leader选举</h1><h2 id="5-1-选举机制"><a href="#5-1-选举机制" class="headerlink" title="5.1 选举机制"></a>5.1 选举机制</h2><p>每一个运行的<code>raft</code>节点都包含一个任期号(<code>Term</code>), 每个任期只能有一个<code>Leader</code>。</p><p>如何保证每个任期只能有一个<code>Leader</code>？</p><p>首先， 每一个运行的<code>raft</code>节点只能是如下几个角色之一：</p><ul><li><code>Leader</code></li><li><code>Follower</code></li><li><code>Candidate</code></li></ul><p>每个<code>Raft</code>节点都有一个选举定时器, 每次收到心跳<code>RPC</code>或追加<code>log</code>的<code>RPC</code>(都通过<code>AppendEntries</code>)时, 都将重置这个选举定时器, 在选举定时器没有到期时, 发出<code>AppendEntries</code>的节点是<code>Leader</code>, 接收<code>AppendEntries</code>的节点是<code>Follower</code>, 一旦因为没有接收到消息导致选举定时器到期, 节点转化为<code>Candidate</code>并进行投票选举。</p><p>每一次选举会增加<code>Term</code>，通过<code>RequestVote</code>向其他节点寻求投票, 由于节点数量是奇数, 而投票选举成功要求过半的投票, 因此只有一个<code>Leader</code>将在一个特定的<code>Term</code>内选举成功。</p><p>拿到过半投票的<code>Leader</code>将通过心跳告知新<code>Leader</code>的诞生, 如果没有这样的节点, 则再次自增<code>Term</code>进行新一轮的选举。</p><h2 id="5-2-避免选票分裂"><a href="#5-2-避免选票分裂" class="headerlink" title="5.2 避免选票分裂"></a>5.2 避免选票分裂</h2><p>因为每个<code>Candidate</code>都会给自己投票, 因此如果所有的<code>Follower</code>同时转化为<code>Candidate</code>并发起选举, 结果一定是各自一张投票, 形成了选票分裂(<code>Split Vote</code>), 并且恶心循环地再次进行新一轮选举。</p><p>为了避免这种情况，不同的服务器都应该选取随机的超时时间。先超时的节点有更大的概率获得更多的选票，因此避免了多次选票分裂的情况。</p><blockquote><p>PS: 选举超时的设定要求: 至少大于<code>Leader</code>的心跳间隔, 否则该节点会在收到正常的心跳之前触发选举</p></blockquote><h2 id="5-3-Raft未考虑的情形-单向网络故障"><a href="#5-3-Raft未考虑的情形-单向网络故障" class="headerlink" title="5.3 Raft未考虑的情形: 单向网络故障"></a>5.3 <code>Raft</code>未考虑的情形: 单向网络故障</h2><p>以下的情形会导致<code>Raft</code>不能正常工作:</p><ol><li><code>Leader</code>可以发出心跳，但是又不能收到任何客户端请求</li><li><code>Leader</code>的心跳会抑制其他服务器开始一次新的选举</li></ol><p>以上情形将导致客户端请求永远不被执行, 教授提出的解决方案是:<strong>通过一个双向的心跳解决</strong>: </p><ol><li><code>Follower</code>需要回复心跳</li><li>如果<code>Leader</code>一段时间没有收到自己发出心跳的回复，将让出<code>Leader</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;课程主页: &lt;a href=&quot;https://pdos.csail.mit.edu/6.824/schedule.html&quot;&gt;https://pdos.csail.mit.edu/6.824/schedule.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本节课是介绍&lt;code&gt;Raft</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Raft" scheme="http://example.com/tags/Raft/"/>
    
  </entry>
  
</feed>
