<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="本文不会将原本rCore文档的内容重复太多, 主要是补充学习过程中遇到的知识点, 因此还需结合原文使用, 原文在后面的链接中 这一章引入了页表和虚拟内存。回顾之前构建的OS, 其内核和应用是共用一份地址空间的。这也就意味着， 某个应用程序可以任意访问其他应用程序甚至内核的代码和数据， 这是不安全的， 并且， 编写应用程序的程序员还需要显式地指定链接的地址。因此， 虚拟内存应运而生。同时， 引入虚拟">
<meta property="og:type" content="article">
<meta property="og:title" content="清华大学开源操作系统训练营: rCore chapter4笔记">
<meta property="og:url" content="http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="ToniBlog">
<meta property="og:description" content="本文不会将原本rCore文档的内容重复太多, 主要是补充学习过程中遇到的知识点, 因此还需结合原文使用, 原文在后面的链接中 这一章引入了页表和虚拟内存。回顾之前构建的OS, 其内核和应用是共用一份地址空间的。这也就意味着， 某个应用程序可以任意访问其他应用程序甚至内核的代码和数据， 这是不安全的， 并且， 编写应用程序的程序员还需要显式地指定链接的地址。因此， 虚拟内存应运而生。同时， 引入虚拟">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/LearningOS/ch4-address-space.png">
<meta property="og:image" content="http://example.com/images/LearningOS/ch4-page.png">
<meta property="og:image" content="http://example.com/images/LearningOS/ch4-vaddr-paddr.png">
<meta property="og:image" content="http://example.com/images/LearningOS/ch4-translate.png">
<meta property="og:image" content="http://example.com/images/LearningOS/ch4-kernel-space.png">
<meta property="og:image" content="http://example.com/images/LearningOS/ch4-kernel-space-2.png">
<meta property="og:image" content="http://example.com/images/LearningOS/ch4-user-space.png">
<meta property="og:image" content="http://example.com/images/LearningOS/ch4-switch.png">
<meta property="article:published_time" content="2024-02-20T13:22:29.000Z">
<meta property="article:modified_time" content="2024-10-03T17:47:36.144Z">
<meta property="article:author" content="ToniXWD">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="riscv">
<meta property="article:tag" content="Rust">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/LearningOS/ch4-address-space.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/flash_dc.png">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/flash_dc.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/flash_dc.png">
        
      
    
    <!-- title -->
    <title>清华大学开源操作系统训练营: rCore chapter4笔记</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="ToniBlog" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2024/02/28/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/rCore-chapter4%E7%BB%83%E4%B9%A0/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2024/02/15/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch3%E7%AC%94%E8%AE%B0/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/&text=清华大学开源操作系统训练营: rCore chapter4笔记"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/&title=清华大学开源操作系统训练营: rCore chapter4笔记"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/&is_video=false&description=清华大学开源操作系统训练营: rCore chapter4笔记"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=清华大学开源操作系统训练营: rCore chapter4笔记&body=Check out this article: http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/&title=清华大学开源操作系统训练营: rCore chapter4笔记"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/&title=清华大学开源操作系统训练营: rCore chapter4笔记"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/&title=清华大学开源操作系统训练营: rCore chapter4笔记"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/&title=清华大学开源操作系统训练营: rCore chapter4笔记"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/&name=清华大学开源操作系统训练营: rCore chapter4笔记&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/&t=清华大学开源操作系统训练营: rCore chapter4笔记"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%BC%95%E5%85%A5%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">1.</span> <span class="toc-text">1 引入虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 虚拟地址空间的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 分页管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-SV39%E5%88%86%E9%A1%B5%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 SV39分页介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-SV39%E5%88%86%E9%A1%B5%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 SV39分页的代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E9%A1%B5%E5%B8%A7%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.4.1 页帧分配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E9%A1%B5%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.4.2 页表的查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%8B%86%E9%99%A4"><span class="toc-number">1.4.3.</span> <span class="toc-text">1.4.3 页表的创建与拆除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8E%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">2.</span> <span class="toc-text">2 基于虚拟内存的地址空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 地址空间结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%96%B0%E5%BB%BA%E5%92%8C%E6%8B%86%E9%99%A4MapArea%E6%98%A0%E5%B0%84"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 新建和拆除MapArea映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%86%85%E6%A0%B8%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 内核地址空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E5%86%85%E6%A0%B8%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%A6%82%E8%BF%B0"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 内核地址空间概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E5%BA%94%E7%94%A8%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%A6%82%E8%BF%B0"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 应用地址空间概述</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%BC%95%E5%85%A5%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%90%8E%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">3 引入虚拟内存后的上下文切换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%80%9D%E8%80%83%E5%92%8Cch3%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 思考和ch3的变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%BB%8E%E6%96%B0%E7%9A%84trap-S%E5%88%86%E6%9E%90TrapContext%E5%92%8CTrampoline"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 从新的trap.S分析TrapContext和Trampoline</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%BC%95%E5%85%A5%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%90%8E%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">4 引入虚拟内存后的任务控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 任务控制块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%BB%BB%E5%8A%A1%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 任务运行的实例</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        清华大学开源操作系统训练营: rCore chapter4笔记
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">ToniXWD</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-02-20T13:22:29.000Z" class="dt-published" itemprop="datePublished">2024-02-20</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/">训练营笔记</a> › <a class="category-link" href="/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A52023/">清华大学开源操作系统训练营2023</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/OS/" rel="tag">OS</a>, <a class="p-category" href="/tags/Rust/" rel="tag">Rust</a>, <a class="p-category" href="/tags/riscv/" rel="tag">riscv</a>, <a class="p-category" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>本文不会将原本<code>rCore文档</code>的内容重复太多, 主要是补充学习过程中遇到的知识点, 因此还需结合原文使用, 原文在后面的链接中</p>
<p>这一章引入了页表和虚拟内存。回顾之前构建的<code>OS</code>, 其内核和应用是共用一份地址空间的。这也就意味着， 某个应用程序可以任意访问其他应用程序甚至内核的代码和数据， 这是不安全的， 并且， 编写应用程序的程序员还需要显式地指定链接的地址。因此， 虚拟内存应运而生。同时， 引入虚拟内存后， 还需要重新设计上下文切换和进程控制快, 因此这一章的代码相对复杂。</p>
<p>本章的内容包括:</p>
<ol>
<li>基于<code>SV39</code>引入虚拟内存和页表</li>
<li>重新设计进程控制块结构体</li>
<li>重新设计上下文切换</li>
</ol>
<p>完整版官方文档： <a target="_blank" rel="noopener" href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/index.html">https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/index.html</a></p>
<p>精简版文档： <a target="_blank" rel="noopener" href="https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter4/index.html">https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter4/index.html</a></p>
<h1 id="1-引入虚拟内存"><a href="#1-引入虚拟内存" class="headerlink" title="1 引入虚拟内存"></a>1 引入虚拟内存</h1><h2 id="1-1-虚拟地址空间的概念"><a href="#1-1-虚拟地址空间的概念" class="headerlink" title="1.1 虚拟地址空间的概念"></a>1.1 虚拟地址空间的概念</h2><p>文档中对地址空间的介绍已经很完善了, 这里只做简要总结:</p>
<p><img src="/../../../images/LearningOS/ch4-address-space.png" alt="ch4-address-space"></p>
<p>上图摘自官方文档, 根据这个图简单介绍什么是地址空间</p>
<ol>
<li>为什么叫<strong>虚拟地址空间</strong>?<br>因为地址不是真正的物理内存地址, 而是需要经过一系列操作映射到物理地址。想象一下， 编写不同C语言程序时，我们的数据可以防止同样的地址中， 但这些不同的应用都可以同时运行，显然他们不是同一个物理地址</li>
<li>如何转化为<strong>物理地址</strong>？<br>通过硬件单元<code>MMU</code>进行转化, <code>MMU</code>会根据一个映射表查询虚拟地址对应的物理地址, 这个映射表就叫<strong>页表</strong>, 根页表的地址存放在指定的寄存器中, <code>riscv</code>中是<code>satp</code>寄存器</li>
<li>如何实现隔离<ol>
<li><code>U</code>表示用户态是否可以访问, <code>U</code>标记实现了内核和应用程序之间的隔离</li>
<li>每个应用程序有自己的页表, 并且页表项中的<code>V</code>标记位表示页表项是否有效, 不属于应用程序的地址没有设置<code>V</code>标记, 这实现了应用程序间的隔离</li>
</ol>
</li>
</ol>
<h2 id="1-2-分页管理"><a href="#1-2-分页管理" class="headerlink" title="1.2 分页管理"></a>1.2 分页管理</h2><p>由于地址的数量是近乎无限的, 不可能以每一个地址为粒度进行映射, 因此将<code>4096</code>个字节作为一个映射单位, 这就是<strong>分页</strong>的概念, 除了这个原因外, 分页还有一个好处就是<strong>方便在硬盘和内存之间加载和替换数据</strong>, 因为一次硬盘的<code>IO</code>是昂贵的, 因此一次硬盘的<code>IO</code>应当包含足够大的空间, 通常也就是一个扇区, 大小通常也是<code>4096</code>个字节。</p>
<blockquote>
<blockquote>
<p>目前的<code>rCore</code>没有文件系统, 因此虚拟内存的分页也没有在硬盘和内存中进行加载和替换的功能, 只是实现虚拟内存的抽象罢了</p>
</blockquote>
</blockquote>
<p>虚拟内存中的分页机制可以用一个贴近生活的比喻来理解：假设你有一本非常厚的书（这里的书就像是一个程序需要的内存空间），书架（物理内存）的空间有限，你不能同时把所有的书放在书架上。所以，你决定只把当前正在阅读的几页（活跃的内存页）放在书架上，而把其他的页暂时存放在一个大箱子里（硬盘上的交换空间）。当你想读书中的其他部分时，你会从箱子里取出你需要的页，并把不再需要的页放回箱子里。</p>
<p><strong>虚拟内存分页机制：</strong></p>
<ol>
<li><p><strong>分页的基本概念</strong>：<br>就像上面的比喻中，分页机制将虚拟内存分割成许多固定大小的块，每一块称为一个“页”或“页面”。同样地，物理内存也被分割成同样大小的块，称为“页帧”或“物理页”。</p>
</li>
<li><p><strong>页表映射</strong>：<br>为了追踪哪些虚拟页对应于物理内存中的哪些页帧，操作系统维护着一张映射表，这就是所谓的页表。当程序尝试访问其虚拟内存中的数据时，操作系统查看页表来找出那个虚拟页在物理内存中的位置。</p>
</li>
<li><p><strong>内存访问</strong>：<br>当程序访问一个虚拟地址时，这个地址被分成两部分：页号和页内偏移。页号用于在页表中查找对应的物理页帧，而页内偏移决定了在这个页帧内的具体位置。</p>
</li>
<li><p><strong>缺页中断</strong>：<br>如果程序需要访问的页当前不在物理内存中（也就是说，它在硬盘的交换空间里），这会触发一个叫做缺页中断（page fault）的事件。操作系统随后会选择一个物理页（如果需要，可能会将当前的内容保存到硬盘上），并从硬盘上加载所需的虚拟页到这个物理页中，然后更新页表，并重新开始执行刚才中断的指令。</p>
</li>
<li><p><strong>页替换算法</strong>：<br>当物理内存满了，而需要加载新的页时，操作系统必须决定哪些页将被移出物理内存以为新页腾出空间。这涉及到页替换算法，如最近最少使用（LRU）、先进先出（FIFO）等，用于选择被替换的页。</p>
</li>
</ol>
<p>通过这种分页机制，操作系统可以非常高效地管理内存，即使物理内存有限，程序也可以使用比物理内存大得多的地址空间。这样不仅提高了内存的使用效率，也简化了程序员的工作，因为他们不需要关心内存的物理限制，只需要关注于程序的逻辑结构。</p>
<p>最后贴上官方文档的图:</p>
<p><img src="/../../../images/LearningOS/ch4-page.png" alt="ch4-page"></p>
<p>页表中包含3个部分:</p>
<ol>
<li>映射的物理页号</li>
<li>页的操作权限</li>
</ol>
<blockquote>
<blockquote>
<p>图中的<code>FrameNumber</code>实际上在页表中是没有的</p>
</blockquote>
</blockquote>
<h2 id="1-3-SV39分页介绍"><a href="#1-3-SV39分页介绍" class="headerlink" title="1.3 SV39分页介绍"></a>1.3 <code>SV39</code>分页介绍</h2><p>这里介绍如何实现映射, 这里采用的是<code>riscv</code>的<code>SV39</code>分页机制:</p>
<p>首先看看虚拟地址和物理地址的格式:</p>
<p><img src="/../../../images/LearningOS/ch4-vaddr-paddr.png" alt="ch4-vaddr-paddr"></p>
<ol>
<li>虚拟地址被分为39位，意味着虚拟地址空间的大小可以达到2<sup>39</sup>字节，即512GB。其中低12位是页内的偏移量, 高27位可以分为3份, 每份9位, 表示的是在各级页表中的索引(如果看不懂就去看后面给出的地址翻译流程图)</li>
<li>物理地址的低12位表示一个页内的偏移, <code>12-55</code>位表示了页号</li>
</ol>
<p>下面是详细的<code>SV39分</code>页机制：</p>
<ol>
<li><p><strong>三级页表结构</strong>：在SV39分页模式下，地址翻译使用三级页表。这意味着虚拟地址被分为四部分：<code>VPN[2]、VPN[1]、VPN[0]</code>和页内偏移。这里的VPN代表虚拟页号（Virtual Page Number），不同级别的页表项（PTE）由不同的VPN部分索引。</p>
</li>
<li><p><strong>页大小</strong>：SV39通常使用4KB的页大小，这是最常见的页大小，但也支持大页，如2MB和1GB的大页。因为地址是8字节, 因此一个存放页表项的页就包含了<code>4096/1024</code>&#x3D;<code>512</code>个页表项</p>
</li>
<li><p><strong>地址转换</strong>：虚拟地址转换为物理地址的过程涉及查找三级页表。首先使用VPN[2]在一级页表中查找，得到二级页表的地址；然后使用VPN[1]在二级页表中查找，得到三级页表的地址；最后使用VPN[0]在三级页表中查找，得到物理页号（PPN）。页内偏移保持不变，直接用于定位物理页内的具体地址。</p>
</li>
<li><p><strong>地址翻译缓存（TLB）</strong>：由于地址翻译过程可能相当耗时，因为它涉及到多次内存访问，RISC-V处理器通常会使用<code>TLB</code>来缓存最近的地址翻译结果，来加快地址翻译速度。</p>
</li>
</ol>
<p>接下来是地址翻译的流程, 摘自<code>MIT6.S081</code>:</p>
<p><img src="/../../../images/LearningOS/ch4-translate.png" alt="ch4-translate"></p>
<ol>
<li><code>L2</code>是根页表的索引, 2<sup>9</sup> &#x3D; 512正好能表示所有的索引, 根页表的页表项记录了<code>L1</code>对应页表的物理页号<code>PPN</code></li>
<li>用之前拿到的物理页号<code>PPN</code>找到<code>L1</code>对应页表的物理页, 用同样的思路找到索引<code>L1</code>的页表项, 其记录了<code>L0</code>对应页表的物理页号<code>PPN</code></li>
<li>用之前的<code>PPN</code>, 结合索引<code>L0</code>拿到实际的数据页的页号<code>PPN</code></li>
<li>用最终得到的页号<code>PPN</code>找到数据页, 使用页内便宜<code>OffSet</code>就找到了最终的物理地址</li>
</ol>
<h2 id="1-4-SV39分页的代码实现"><a href="#1-4-SV39分页的代码实现" class="headerlink" title="1.4 SV39分页的代码实现"></a>1.4 <code>SV39</code>分页的代码实现</h2><p>文档中详细地介绍了页表和地址空间相关数据结构, 这里不详细展开了, 很多内容都是涉及页表号、地址之间的转化以及地址转货为结构体或切片的方法，比较繁琐。 这里只介绍我认为其中比较重要的代码</p>
<h3 id="1-4-1-页帧分配器"><a href="#1-4-1-页帧分配器" class="headerlink" title="1.4.1 页帧分配器"></a>1.4.1 页帧分配器</h3><p>这里管理内存既然是以页为单位的，自然需要一个页分配器，分配的页的单位称为页框：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    current: <span class="type">usize</span>,</span><br><span class="line">    end: <span class="type">usize</span>,</span><br><span class="line">    recycled: <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, l: PhysPageNum, r: PhysPageNum) &#123;</span><br><span class="line">        <span class="keyword">self</span>.current = l.<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.end = r.<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// trace!(&quot;last &#123;&#125; Physical Frames.&quot;, self.end - self.current);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的结构体中, 物理页号区间 <code>[ current , end )</code> 此前均 从未 被分配出去过，而容器 <code>recycled</code> 以后入先出的方式保存了被回收的物理页号,<br>具体分配和回收的方法如下:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">FrameAllocator</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">alloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;PhysPageNum&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">dealloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, ppn: PhysPageNum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FrameAllocator</span> <span class="keyword">for</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            current: <span class="number">0</span>,</span><br><span class="line">            end: <span class="number">0</span>,</span><br><span class="line">            recycled: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">alloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;PhysPageNum&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(ppn) = <span class="keyword">self</span>.recycled.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(ppn.<span class="title function_ invoke__">into</span>())</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">self</span>.current == <span class="keyword">self</span>.end &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.current += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>((<span class="keyword">self</span>.current - <span class="number">1</span>).<span class="title function_ invoke__">into</span>())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">dealloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, ppn: PhysPageNum) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ppn</span> = ppn.<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// validity check</span></span><br><span class="line">        <span class="keyword">if</span> ppn &gt;= <span class="keyword">self</span>.current || <span class="keyword">self</span>.recycled.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">any</span>(|&amp;v| v == ppn) &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Frame ppn=&#123;:#x&#125; has not been allocated!&quot;</span>, ppn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// recycle</span></span><br><span class="line">        <span class="keyword">self</span>.recycled.<span class="title function_ invoke__">push</span>(ppn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分配和回收页帧逻辑都很简单:</p>
<ol>
<li>分配时优先从<code>recycled</code>中重复利用回收的页帧, 否则对<code>current</code>自增完成分配</li>
<li>回收时将其放入<code>recycled</code></li>
</ol>
<p>这里有一个很有意思的地方, 就是实际分配时是在前面的<code>StackFrameAllocator</code>基础上再再进行了一层封装:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Allocate a physical page frame in FrameTracker style</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">frame_alloc</span>() <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;FrameTracker&gt; &#123;</span><br><span class="line">    FRAME_ALLOCATOR</span><br><span class="line">        .<span class="title function_ invoke__">exclusive_access</span>()</span><br><span class="line">        .<span class="title function_ invoke__">alloc</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(FrameTracker::new)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Deallocate a physical page frame with a given ppn</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">frame_dealloc</span>(ppn: PhysPageNum) &#123;</span><br><span class="line">    FRAME_ALLOCATOR.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">dealloc</span>(ppn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="comment">/// physical page number</span></span><br><span class="line">    <span class="keyword">pub</span> ppn: PhysPageNum,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">frame_dealloc</span>(<span class="keyword">self</span>.ppn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还是熟悉的 <code>RAII</code> 的思想，将一个物理页帧的生命周期绑定到一个 <code>FrameTracker</code> 变量上，当其生命周期结束时, 使用自定义的<code>drop</code>方法将其回收到<code>StackFrameAllocator</code>的<code>recycle</code>容器中, 这种思想和方法以后还会看到</p>
<h3 id="1-4-2-页表的查询"><a href="#1-4-2-页表的查询" class="headerlink" title="1.4.2 页表的查询"></a>1.4.2 页表的查询</h3><p>页表的方法很多, 这里我只列出自己认为比较重要的方法, 首先就是查询页表的方法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Find PageTableEntry by VirtPageNum, create a frame for a 4KB page table if not exist</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">find_pte_create</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">for</span> (i, idx) <span class="keyword">in</span> idxs.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = &amp;<span class="keyword">mut</span> ppn.<span class="title function_ invoke__">get_pte_array</span>()[*idx];</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">            result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(frame.ppn, PTEFlags::V);</span><br><span class="line">            <span class="keyword">self</span>.frames.<span class="title function_ invoke__">push</span>(frame);</span><br><span class="line">        &#125;</span><br><span class="line">        ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// Find PageTableEntry by VirtPageNum</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">find_pte</span>(&amp;<span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">for</span> (i, idx) <span class="keyword">in</span> idxs.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = &amp;<span class="keyword">mut</span> ppn.<span class="title function_ invoke__">get_pte_array</span>()[*idx];</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">            result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>find_pte_create</code>和<code>find_pte</code>逻辑类似, 都是实现了之前<code>MIT6.S081</code>中地址翻译的过程, 这里就不重复其过程了</p>
<h3 id="1-4-3-页表的创建与拆除"><a href="#1-4-3-页表的创建与拆除" class="headerlink" title="1.4.3 页表的创建与拆除"></a>1.4.3 页表的创建与拆除</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Create a new page table</span></span><br><span class="line">    <span class="comment">/// set the map between virtual page number and physical page number</span></span><br><span class="line">    <span class="meta">#[allow(unused)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte_create</span>(vpn).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">assert!</span>(!pte.<span class="title function_ invoke__">is_valid</span>(), <span class="string">&quot;vpn &#123;:?&#125; is mapped before mapping&quot;</span>, vpn);</span><br><span class="line">        *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(ppn, flags | PTEFlags::V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// remove the map between virtual page number and physical page number</span></span><br><span class="line">    <span class="meta">#[allow(unused)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte</span>(vpn).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">assert!</span>(pte.<span class="title function_ invoke__">is_valid</span>(), <span class="string">&quot;vpn &#123;:?&#125; is invalid before unmapping&quot;</span>, vpn);</span><br><span class="line">        *pte = PageTableEntry::<span class="title function_ invoke__">empty</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>页表的创建与拆除就是调用<code>find_pte_create</code>或<code>find_pte</code>, 然后设置页表项完成映射或拆除映射</p>
<h1 id="2-基于虚拟内存的地址空间"><a href="#2-基于虚拟内存的地址空间" class="headerlink" title="2 基于虚拟内存的地址空间"></a>2 基于虚拟内存的地址空间</h1><h2 id="2-1-地址空间结构体"><a href="#2-1-地址空间结构体" class="headerlink" title="2.1 地址空间结构体"></a>2.1 地址空间结构体</h2><p>完成了虚拟内存的实现后, 下一步是基于虚拟内存实现地址空间的抽象, 在<code>rCore</code>中, 地址空间被进一步划分为多个逻辑段:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MemorySet</span> &#123;</span><br><span class="line">    page_table: PageTable,</span><br><span class="line">    areas: <span class="type">Vec</span>&lt;MapArea&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里, <code>MemorySet</code>就是一个地址空间, 其中有多个逻辑段存放于一个容器<code>Vec</code>中, 这里也是<code>RAII</code>的思想</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MapArea</span> &#123;</span><br><span class="line">    vpn_range: VPNRange,</span><br><span class="line">    data_frames: BTreeMap&lt;VirtPageNum, FrameTracker&gt;,</span><br><span class="line">    map_type: MapType,</span><br><span class="line">    map_perm: MapPermission,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MapArea</code>的<code>vpn_range</code>表示虚拟页号的返回, <code>data_frames</code>同样是将<code>FrameTracker</code>的生命周期绑定到<code>BTreeMap</code>中</p>
<p>接下来, 只介绍<code>MemorySet</code>和<code>MapArea</code>中比较关键的方法, 因为所有的方法太繁杂了…</p>
<h2 id="2-2-新建和拆除MapArea映射"><a href="#2-2-新建和拆除MapArea映射" class="headerlink" title="2.2 新建和拆除MapArea映射"></a>2.2 新建和拆除<code>MapArea</code>映射</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map_one</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, vpn: VirtPageNum) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ppn</span>: PhysPageNum;</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.map_type &#123;</span><br><span class="line">        MapType::Identical =&gt; &#123;</span><br><span class="line">            ppn = <span class="title function_ invoke__">PhysPageNum</span>(vpn.<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MapType::Framed =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            ppn = frame.ppn;</span><br><span class="line">            <span class="keyword">self</span>.data_frames.<span class="title function_ invoke__">insert</span>(vpn, frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pte_flags</span> = PTEFlags::<span class="title function_ invoke__">from_bits</span>(<span class="keyword">self</span>.map_perm.bits).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    page_table.<span class="title function_ invoke__">map</span>(vpn, ppn, pte_flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[allow(unused)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmap_one</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, vpn: VirtPageNum) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.map_type == MapType::Framed &#123;</span><br><span class="line">        <span class="keyword">self</span>.data_frames.<span class="title function_ invoke__">remove</span>(&amp;vpn);</span><br><span class="line">    &#125;</span><br><span class="line">    page_table.<span class="title function_ invoke__">unmap</span>(vpn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>map_one</code>的思路如下:</p>
<ol>
<li>新建一个虚拟页到物理页的映射<ol>
<li>如果映射类型是<code>MapType::Framed</code>: 从 <code>FRAME_ALLOCATOR</code> 处分配一个物理页<code>frame,</code> 并将 <code>vpn</code> 和 <code>frame</code> 插入到 <code>data_frames</code> 中</li>
<li>如果映射类型是<code>MapType::Identical</code>, <code>ppn</code>和<code>vpn</code>相等</li>
</ol>
</li>
<li>无论是那种类型, 都在<code>page_table</code>中插入 <code>vpn</code> 到 <code>ppn</code> 的映射</li>
</ol>
<p><code>unmap_one</code>也是调用<code>PageTable</code>的<code>unmap</code>方法, 思路类似</p>
<p>这里可以看到, <code>MapArea</code>只是逻辑上管理一个虚拟地址段的数据结构, 真正的映射实现还是通过外部提供的<code>PageTable</code>的<code>map</code>实现, 正因如此, <code>MapArea</code>需要被托管到上层的结构体进行管理</p>
<p>最后, <code>map_one</code>和<code>unmap_one</code>只是映射和拆除单一的虚拟页, 因此, 如果在地址空间的所有虚拟页中调用这2个方法, 就完成了整个地址空间的建立和拆除:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">vpn</span> <span class="keyword">in</span> <span class="keyword">self</span>.vpn_range &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">map_one</span>(page_table, vpn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[allow(unused)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">vpn</span> <span class="keyword">in</span> <span class="keyword">self</span>.vpn_range &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">unmap_one</span>(page_table, vpn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-3-内核地址空间"><a href="#2-3-内核地址空间" class="headerlink" title="2.3 内核地址空间"></a>2.3 内核地址空间</h2><h3 id="2-3-1-内核地址空间概述"><a href="#2-3-1-内核地址空间概述" class="headerlink" title="2.3.1 内核地址空间概述"></a>2.3.1 内核地址空间概述</h3><p><img src="/../../../images/LearningOS/ch4-kernel-space.png" alt="ch4-kernel-space"><img src="/../../../images/LearningOS/ch4-kernel-space-2.png" alt="ch4-kernel-space-2"></p>
<p>上图摘自官方文档, 第一张图是内核的高地址空间, 第二章图是内核的低地址空间, 和之前<code>ch3</code>类似, 不同的应用程序拥有自己的内核栈, 不同内核栈之间拥有保护页, 说到这里, 那之前<code>ch3</code>的没有引入虚拟内存的内核地址空间不是和现在没啥区别吗? 确实, 因为这里内核地址空间采用的是<strong>恒等映射</strong>, 也就是内核的虚拟地址和实际物理地址完全相同, 这样也便于内核精确地控制内存。</p>
<p>但区别还是有的，也就是跳板 <code>Trampoline</code>, 这会在后文中介绍</p>
<h3 id="2-3-2-应用地址空间概述"><a href="#2-3-2-应用地址空间概述" class="headerlink" title="2.3.2 应用地址空间概述"></a>2.3.2 应用地址空间概述</h3><p><img src="/../../../images/LearningOS/ch4-user-space.png" alt="ch4-user-space"><br>上图摘自官方文档, 和之前的内容相比, 现在的地址克难攻坚在顶层多了<code>Trampoline</code>和<code>TrapContext</code>, 这涉及到引入虚拟内存后的上下文切换, 后面会详细描述</p>
<blockquote>
<blockquote>
<p>其实地址空间这一部分, 最复杂的是解析<code>elf</code>的工作, 这一部分<code>rCore</code>目前直接使用了第三方库实现, 没有深入</p>
</blockquote>
</blockquote>
<h1 id="3-引入虚拟内存后的上下文切换"><a href="#3-引入虚拟内存后的上下文切换" class="headerlink" title="3 引入虚拟内存后的上下文切换"></a>3 引入虚拟内存后的上下文切换</h1><p>这一部分才是我们这一章节的最核心的内容</p>
<h2 id="3-1-思考和ch3的变化"><a href="#3-1-思考和ch3的变化" class="headerlink" title="3.1 思考和ch3的变化"></a>3.1 思考和<code>ch3</code>的变化</h2><p>回忆<code>ch3</code>的上下文切换, 其在<code>trap</code>中将不同任务的上下文信息保存在自己的内核栈中, 我们注意到在<code>trap.S</code>中有这样的汇编代码:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__alltraps:</span><br><span class="line">    csrrw sp, sscratch, sp</span><br></pre></td></tr></table></figure>
<p>在陷入<code>trap</code>时, 应用程序将用户栈指针和内核栈指针交换, 然后将上下文信息存储在了内核栈上, 这在内核和用户公用一套地址空间时看起来是否自然, 但现在的问题是, 内核和用户的地址空间不一样, 换句话说就是<code>satp</code>中的根页表地址不一样。因此陷入内核时需要将内核地址空间的根页表地址(<code>token</code>)写入<code>satp</code>, 因此需要一个寄存器存储原来用户空间的<code>token</code>, 同时用户栈的指针也需要被存储, 但我们只有一个 <code>sscratch</code> 寄存器可用来进行周转。因此我们没有办法像原来一样将应用程序的上下文信息保存在内核栈中</p>
<h2 id="3-2-从新的trap-S分析TrapContext和Trampoline"><a href="#3-2-从新的trap-S分析TrapContext和Trampoline" class="headerlink" title="3.2 从新的trap.S分析TrapContext和Trampoline"></a>3.2 从新的<code>trap.S</code>分析<code>TrapContext</code>和<code>Trampoline</code></h2><p>先分析新的<code>trap.S</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">.altmacro</span><br><span class="line">.macro SAVE_GP n</span><br><span class="line">    sd x\n, \n*8(sp)</span><br><span class="line">.endm</span><br><span class="line">.macro LOAD_GP n</span><br><span class="line">    ld x\n, \n*8(sp)</span><br><span class="line">.endm</span><br><span class="line">    .section .text.trampoline</span><br><span class="line">    .globl __alltraps</span><br><span class="line">    .globl __restore</span><br><span class="line">    .align 2</span><br><span class="line">__alltraps:</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    <span class="comment"># now sp-&gt;*TrapContext in user space, sscratch-&gt;user stack</span></span><br><span class="line">    <span class="comment"># save other general purpose registers</span></span><br><span class="line">    sd x1, 1*8(sp)</span><br><span class="line">    <span class="comment"># skip sp(x2), we will save it later</span></span><br><span class="line">    sd x3, 3*8(sp)</span><br><span class="line">    <span class="comment"># skip tp(x4), application does not use it</span></span><br><span class="line">    <span class="comment"># save x5~x31</span></span><br><span class="line">    .<span class="built_in">set</span> n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        SAVE_GP %n</span><br><span class="line">        .<span class="built_in">set</span> n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    <span class="comment"># we can use t0/t1/t2 freely, because they have been saved in TrapContext</span></span><br><span class="line">    csrr t0, sstatus</span><br><span class="line">    csrr t1, sepc</span><br><span class="line">    sd t0, 32*8(sp)</span><br><span class="line">    sd t1, 33*8(sp)</span><br><span class="line">    <span class="comment"># read user stack from sscratch and save it in TrapContext</span></span><br><span class="line">    csrr t2, sscratch</span><br><span class="line">    sd t2, 2*8(sp)</span><br><span class="line">    <span class="comment"># load kernel_satp into t0</span></span><br><span class="line">    ld t0, 34*8(sp)</span><br><span class="line">    <span class="comment"># load trap_handler into t1</span></span><br><span class="line">    ld t1, 36*8(sp)</span><br><span class="line">    <span class="comment"># move to kernel_sp</span></span><br><span class="line">    ld sp, 35*8(sp)</span><br><span class="line">    <span class="comment"># switch to kernel space</span></span><br><span class="line">    csrw satp, t0</span><br><span class="line">    sfence.vma</span><br><span class="line">    <span class="comment"># jump to trap_handler</span></span><br><span class="line">    jr t1</span><br><span class="line"></span><br><span class="line">__restore:</span><br><span class="line">    <span class="comment"># a0: *TrapContext in user space(Constant); a1: user space token</span></span><br><span class="line">    <span class="comment"># switch to user space</span></span><br><span class="line">    csrw satp, a1</span><br><span class="line">    sfence.vma</span><br><span class="line">    csrw sscratch, a0</span><br><span class="line">    <span class="built_in">mv</span> sp, a0</span><br><span class="line">    <span class="comment"># now sp points to TrapContext in user space, start restoring based on it</span></span><br><span class="line">    <span class="comment"># restore sstatus/sepc</span></span><br><span class="line">    ld t0, 32*8(sp)</span><br><span class="line">    ld t1, 33*8(sp)</span><br><span class="line">    csrw sstatus, t0</span><br><span class="line">    csrw sepc, t1</span><br><span class="line">    <span class="comment"># restore general purpose registers except x0/sp/tp</span></span><br><span class="line">    ld x1, 1*8(sp)</span><br><span class="line">    ld x3, 3*8(sp)</span><br><span class="line">    .<span class="built_in">set</span> n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        LOAD_GP %n</span><br><span class="line">        .<span class="built_in">set</span> n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    <span class="comment"># back to user stack</span></span><br><span class="line">    ld sp, 2*8(sp)</span><br><span class="line">    sret</span><br></pre></td></tr></table></figure>
<p>这里先只分析<code>__alltraps</code>的代码:</p>
<p>通过注释我们看出, 此时的<code>sscratch</code>存储的是用户态下<code>TrapContext</code>的地址, 这里需要尤其注意, 尽管我们现在进入的内核模式(硬件会自动设置一些<code>csr</code>寄存器), 但是我们目前的地址空间还没有发送变化, 相关寄存器还是用户态时的内容, 也就是说, 此时我们是将上下文地址存储到了用户的地址空间中的一段连续的内存中, 这个区域也就是之前图中的<code>trapContext</code></p>
<p>存储完成后, 从<code>trapContext</code>的固定位置读取内核的<code>token</code>和内核栈的地址, 重新设置<code>sp</code>后并调用<code>sfence.vma</code>完成地址空间的切换, 这里的问题在于, 完成地址空间切换后, 我们的<code>pc</code>还是指向<code>__alltraps</code>的最后一句<code>jr t1</code>吗?</p>
<p>首先这是必要的, 不然操作系统就没法玩了。但由于地址空间发生了切换，要实现这一点，**<code>trap.S</code>中的代码在内核地址空间和用户地址空间必须是相同的映射吗, 这一块映射的地址段就是<code>Trampoline</code>**</p>
<p>接下来看看映射<code>Trampoline</code>的方法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">map_trampoline</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.page_table.<span class="title function_ invoke__">map</span>(</span><br><span class="line">        VirtAddr::<span class="title function_ invoke__">from</span>(TRAMPOLINE).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        PhysAddr::<span class="title function_ invoke__">from</span>(strampoline <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        PTEFlags::R | PTEFlags::X,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是<code>map_trampoline</code>方法直接被一个地址空间映射, 不属于一个<code>MapArea</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new_kernel</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">memory_set</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">new_bare</span>();</span><br><span class="line">        <span class="comment">// map trampoline</span></span><br><span class="line">        memory_set.<span class="title function_ invoke__">map_trampoline</span>();</span><br><span class="line">        <span class="comment">// map kernel sections</span></span><br><span class="line">        info!(<span class="string">&quot;.text [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, stext <span class="keyword">as</span> <span class="type">usize</span>, etext <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        info!(<span class="string">&quot;.rodata [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, srodata <span class="keyword">as</span> <span class="type">usize</span>, erodata <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        info!(<span class="string">&quot;.data [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, sdata <span class="keyword">as</span> <span class="type">usize</span>, edata <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        info!(</span><br><span class="line">            <span class="string">&quot;.bss [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>,</span><br><span class="line">            sbss_with_stack <span class="keyword">as</span> <span class="type">usize</span>, ebss <span class="keyword">as</span> <span class="type">usize</span></span><br><span class="line">        );</span><br><span class="line">        info!(<span class="string">&quot;mapping .text section&quot;</span>);</span><br><span class="line">        memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">            MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">                (stext <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">                (etext <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">                MapType::Identical,</span><br><span class="line">                MapPermission::R | MapPermission::X,</span><br><span class="line">            ),</span><br><span class="line">            <span class="literal">None</span>,</span><br><span class="line">        );</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="4-引入虚拟内存后的任务控制"><a href="#4-引入虚拟内存后的任务控制" class="headerlink" title="4 引入虚拟内存后的任务控制"></a>4 引入虚拟内存后的任务控制</h1><h2 id="4-1-任务控制块"><a href="#4-1-任务控制块" class="headerlink" title="4.1 任务控制块"></a>4.1 任务控制块</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskControlBlock</span> &#123;</span><br><span class="line">    <span class="comment">/// Save task context</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Maintain the execution status of the current process</span></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Application address space</span></span><br><span class="line">    <span class="keyword">pub</span> memory_set: MemorySet,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The phys page number of trap context</span></span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The size(top addr) of program which is loaded from elf file</span></span><br><span class="line">    <span class="keyword">pub</span> base_size: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入虚拟内存后, 需要添加地址空间<code>MemorySet</code>的结构体以及每个任务的<code>trap context</code>的物理页号, 这样以来, 内核才可以在任务控制时获取其<code>trap</code>的上下文信息</p>
<h2 id="4-2-任务运行的实例"><a href="#4-2-任务运行的实例" class="headerlink" title="4.2 任务运行的实例"></a>4.2 任务运行的实例</h2><p>其实<code>TaskControlBlock</code>很多地方都尽量修改, 但在理解了上下文切换的变化和挑板页<code>Trampoline</code>的原理后, 看看官方文档很容易理解, 就不展开了</p>
<p>这里还是以一个我画的流程图的形式来总结引入虚拟内存的变化, 这里从运行第一个程序开始<br><img src="/../../../images/LearningOS/ch4-switch.png" alt="ch4-switch.png"></p>
<p>图例说明:</p>
<ol>
<li>红色表示内核函数</li>
<li>蓝色表示用户函数或用户地址空间的内存段</li>
<li>紫色表示跳板页的中间状态</li>
</ol>
<p>注意, 这里上下文切换时, <code>App0</code>的<code>TaskContext</code>有2次使用:</p>
<ol>
<li><code>__alltraps</code>时使用了<code>TaskContext</code>:<br>这里的目的是切换<code>App0</code>的用户上下文和内核上下文</li>
<li><code>App0</code>切换到<code>App1</code>的<code>__switch</code>时使用了<code>TaskContext</code>:<br>这里是保存<code>App0</code>在内核态时的寄存器和内核栈指针, 也就是切换的是<code>App0</code>的内核态上下文和<code>App1</code>的上下文, 在这里<code>App1</code>的上下文是用户上下文, 因为<code>APP1</code>也是第一次运行, 但之运行一段时间后的上下文切换则不一定, 可能切换到某个<code>App</code>之前让出<code>Cpu</code>时执行到<code>__switch</code>的内核上下文, 例如这里的<code>App0</code></li>
</ol>
<p>这里由于太拥挤了, 没有画出<code>App0</code>之后恢复执行的流程, 这里简单说明一下:</p>
<ol>
<li>某一时刻另外的<code>App</code>因执行结束或者让出<code>CPU</code>, 又进入了<code>run_next_task</code></li>
<li>这次<code>run_next_task</code>选择下一个<code>task</code>是<code>App0</code></li>
<li>由于<code>App0</code>的<code>TaskContext</code>保存了上一次其在内核中被切换的上下文: 执行<code>run_next_task</code>时的返回地址<code>ra</code>, <code>ra</code>被加载后将按照下面的路径返回:<code>__switch</code> -&gt; <code>run_next_task</code> -&gt; <code>suspend_current_and_run_next</code> -&gt; <code>trap_handler</code></li>
<li>此后执行: <code>trap_return</code> -&gt; <code>__restore</code> -&gt; <code>之前让出CPu的用户代码</code>, 这个过程中的最后一步中, 之前恢复的<code>sepc</code>会在<code>sret</code>返回时会被加载到<code>pc</code></li>
</ol>

  </div>
</article>


    <div class="blog-post-comments">
        <div id="utterances_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/categories/">分类</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%BC%95%E5%85%A5%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">1.</span> <span class="toc-text">1 引入虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 虚拟地址空间的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 分页管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-SV39%E5%88%86%E9%A1%B5%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 SV39分页介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-SV39%E5%88%86%E9%A1%B5%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 SV39分页的代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E9%A1%B5%E5%B8%A7%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.4.1 页帧分配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E9%A1%B5%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.4.2 页表的查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%8B%86%E9%99%A4"><span class="toc-number">1.4.3.</span> <span class="toc-text">1.4.3 页表的创建与拆除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8E%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">2.</span> <span class="toc-text">2 基于虚拟内存的地址空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 地址空间结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%96%B0%E5%BB%BA%E5%92%8C%E6%8B%86%E9%99%A4MapArea%E6%98%A0%E5%B0%84"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 新建和拆除MapArea映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%86%85%E6%A0%B8%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 内核地址空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E5%86%85%E6%A0%B8%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%A6%82%E8%BF%B0"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 内核地址空间概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E5%BA%94%E7%94%A8%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%A6%82%E8%BF%B0"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 应用地址空间概述</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%BC%95%E5%85%A5%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%90%8E%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">3 引入虚拟内存后的上下文切换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%80%9D%E8%80%83%E5%92%8Cch3%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 思考和ch3的变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%BB%8E%E6%96%B0%E7%9A%84trap-S%E5%88%86%E6%9E%90TrapContext%E5%92%8CTrampoline"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 从新的trap.S分析TrapContext和Trampoline</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%BC%95%E5%85%A5%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%90%8E%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">4 引入虚拟内存后的任务控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 任务控制块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%BB%BB%E5%8A%A1%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 任务运行的实例</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/&text=清华大学开源操作系统训练营: rCore chapter4笔记"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/&title=清华大学开源操作系统训练营: rCore chapter4笔记"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/&is_video=false&description=清华大学开源操作系统训练营: rCore chapter4笔记"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=清华大学开源操作系统训练营: rCore chapter4笔记&body=Check out this article: http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/&title=清华大学开源操作系统训练营: rCore chapter4笔记"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/&title=清华大学开源操作系统训练营: rCore chapter4笔记"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/&title=清华大学开源操作系统训练营: rCore chapter4笔记"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/&title=清华大学开源操作系统训练营: rCore chapter4笔记"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/&name=清华大学开源操作系统训练营: rCore chapter4笔记&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2024/02/20/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/ch4%E7%AC%94%E8%AE%B0/&t=清华大学开源操作系统训练营: rCore chapter4笔记"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    ToniXWD
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

    <script type="text/javascript">
      var utterances_repo = 'ToniXWD/ToniXWD.github.io';
      var utterances_issue_term = 'pathname';
      var utterances_label = 'Comment';
      var utterances_theme = 'github-dark';

      (function(){
          var script = document.createElement('script');

          script.src = 'https://utteranc.es/client.js';
          script.setAttribute('repo', utterances_repo);
          script.setAttribute('issue-term', 'pathname');
          script.setAttribute('label', utterances_label);
          script.setAttribute('theme', utterances_theme);
          script.setAttribute('crossorigin', 'anonymous');
          script.async = true;
          (document.getElementById('utterances_thread')).appendChild(script);
      }());
  </script>

</body>
</html>
